<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
<head>
  <meta charset="UTF-8" />
  <title>9 Streams</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  <link type="text/css" rel="stylesheet" media="all" href="core.css" />
</head>
<body>
  <div id="sbo-rt-content"><section epub:type="chapter">
<p class="image"><img src="images/common-01.jpg" alt="Images" /></p>
<h2 class="h2p" id="ch9"><span id="page_541" epub:type="pagebreak"></span>9</h2>
<h2 class="h2p1">Streams</h2>
<p class="title-o"><span class="white">CERTIFICATION OBJECTIVES</span></p>
<p class="toc-l">•       Collections Streams and Filters</p>
<p class="toc-l">•       Iterate Using forEach Methods of Streams and List</p>
<p class="toc-l">•       Describe Stream Interface and Stream Pipeline</p>
<p class="toc-l">•       Filter a Collection by Using Lambda Expressions</p>
<p class="toc-l">•       Use Method References with Streams</p>
<p class="toc-l">•       Develop Code to Extract Data from an Object Using peek() and map() Methods Including Primitive Versions of the map() Method</p>
<p class="toc-l">•       Search for Data by Using Search Methods of the Stream Classes Including findFirst, findAny, anyMatch, allMatch, noneMatch</p>
<p class="toc-l">•       Develop Code That Uses the Optional Class</p>
<p class="toc-l">•       Develop Code That Uses Stream Data Methods and Calculation Methods</p>
<p class="toc-l">•       Sort a Collection Using the Stream API</p>
<p class="toc-l">•       Save Results to a Collection Using the Collect Method and Group/Partition Data Using the Collectors Class</p>
<p class="toc-l">•       Use flatMap() Methods in the Stream API</p>
<p class="toc-l">•       Use the Stream API with NIO.2</p>
<p class="toc-l">•       Use parallel Streams Including Reduction, Decomposition, Merging Processes, Pipelines and Performance</p>
<p class="toc-lq"><img src="images/tick.jpg" alt="Images" />     Two-Minute Drill</p>
<p class="toc-q"><strong>Q&amp;A</strong>   Self Test</p>
<p class="noindent-d"><span id="page_542" epub:type="pagebreak"></span><span class="dropcap">I</span>n the previous chapter we looked at how we can use lambda expressions to represent instances of classes that implement functional interfaces and explored a few places in the JDK where functional interfaces are used, like with the Logger’s <code>log()</code> method and with the new <code>Iterable.forEach()</code> method.</p>
<p class="indent">Well, get ready for more. In this chapter about streams, we’ll use the functional interfaces you just learned about. The <code>java.util.stream</code> package’s Stream interface has over 30 methods, and about three-quarters of those work with functional interfaces in some way.</p>
<p class="indent">Like lambdas and functional interfaces, streams are another new addition in Java 8. The syntax of streams will be new to you and will take some getting used to. As you go through the chapter, take time to practice writing examples and testing the code to get the hang of it. The concept of streams is something quite new, too; at first, you might think streams are just another way of organizing data, like a collection, but they are actually about processing data efficiently, sometimes in ways you might initially find unintuitive given how you’re used to programming in Java.</p>
<p class="indent">Because streams are related to collections (you can make a stream from a <code>Collection</code> type to process the data in the collection) and to lambdas (we’ll be using lambdas frequently to operate on streams); on the exam, you’ll often see streams questions mixed in with questions that use collections and lambdas. The certification objectives related to streams are also mixed in with collections, functional interfaces, and lambdas, as you’ll see throughout this chapter.</p>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch9lev1sec1"><strong>What Is a Stream? (OCP Objective 3.4)</strong></h3>
<p class="noindent"><em>3.4   Collections Streams and Filters.</em></p>
<p class="indentt">A <em>stream</em> is a sequence of elements (you can think of these elements as data) that can be processed with operations. That’s plenty vague as a definition, so to get a better handle on what a stream is, let’s make one:</p>
<p class="imageip"><img src="images/un542-01.jpg" alt="images" /></p>
<p class="noindent"><span id="page_543" epub:type="pagebreak"></span>Here, <code>myNums</code> is an array of three Integers. We’re using the <code>Arrays.stream()</code> method to create a stream from that array. The resulting stream, <code>myStream</code>, is a stream of Integers. What does the stream look like?</p>
<p class="imageip"><img src="images/un543-01.jpg" alt="images" /></p>
<p class="indent">This results in the output:</p>
<p class="imageip"><img src="images/un543-02.jpg" alt="images" /></p>
<p class="indent">Okay, so far this is clear as mud, right?!</p>
<p class="indent">Initially, you might think that a stream is a bit like a data structure, like a <code>List</code> or an array. After all, we’re making a stream out an array of three integers:</p>
<p class="imageip"><img src="images/un543-03.jpg" alt="images" /></p>
<p class="noindent">But streams are not a data structure to organize data like a <code>List</code> is or an array is; rather, they are a way to process data that you can think of as flowing through the stream, much like water flows through a stream in the real world. An <em>array</em> is a way of describing how data is organized and gives you flexible ways to access that data. Now, think of a stream as a way to <em>operate</em> on data that’s flowing from an array through the stream. We say that the array is the stream’s source (like a spring is the source of water for a real stream).</p>
<p class="indent">So far, <code>myStream</code> is just a description of where we’re sourcing data. In this example:</p>
<p class="imageip"><img src="images/un543-04.jpg" alt="images" /></p>
<p class="noindent">we’re saying “the source of the data for <code>myStream</code> is <code>myNums</code>, an array of three integers, 1, 2, 3.” That’s why when we try to display the stream, we don’t see any data; we just see a cryptic description of the object that’s describing how to get at the data.</p>
<p class="indent">Okay, so let’s add an operation and do something with the stream of elements:</p>
<p class="imageip"><img src="images/un543-05.jpg" alt="images" /></p>
<p class="noindent">The result is</p>
<p class="imageip"><img src="images/un543-06.jpg" alt="images" /></p>
<p class="indent">Here, we’ve added an operation <code>count()</code> to <code>myStream</code>. The <code>count()</code> method simply returns the count of elements in the stream as a long value. Getting a <span id="page_544" epub:type="pagebreak"></span>number from the stream, the count of elements, means that stream is done. That is, we can’t perform any more operations on the stream because the stream’s been turned into one number by the <code>count()</code> operation. We say that the <code>count()</code> operation is a “terminal operation” because the stream ends there: no more data flows through the stream after the <code>count()</code> is done.</p>
<p class="indent">The real power of streams comes from the “intermediate operations” you can perform between the source and the end of the stream. For instance, you could filter for even numbers (intermediate operation one), multiply each of those even numbers by 2 (intermediate operation two), and then display the results in the console (terminal operation). By specifying multiple operations on a stream, you are essentially defining a set of things you want to do in a particular order to the data in the source. You could write it all out using a <code>for</code> loop and multiple lines of code (possibly even using one or more temporary or new data structures), but with streams, you can be more concise.</p>
<p class="indent">You can string together as many of these intermediate operations as you like, but for now, we’ll begin with just one:</p>
<p class="imageip"><img src="images/un544-01.jpg" alt="images" /></p>
<p class="noindent">The result we get with this code is</p>
<p class="imageip"><img src="images/un544-02.jpg" alt="images" /></p>
<p class="indent">Now, rather than just counting the elements of the stream, we’re first filtering the stream, looking for elements whose value is greater than 1. Notice that the <code>filter()</code> method takes a <code>Predicate</code>, and recall from the previous chapter that a <code>Predicate</code> is an interface with one abstract method, <code>test()</code>, that takes a value and returns a boolean. Here, we’re representing the <code>Predicate</code> with a lambda expression; the value we take as an argument is one element from the stream of data; and we return true if the value of the element is greater than 1. You can read the code</p>
<p class="imageip"><img src="images/un544-03.jpg" alt="images" /></p>
<p class="noindent">like this: “As the elements of <code>myStream</code> flow by, keep only those greater than 1, and count how many elements there are.” The <code>filter()</code> method is calling the <span id="page_545" epub:type="pagebreak"></span><code>test()</code> method of the <code>Predicate</code> you pass to <code>filter()</code> behind the scenes, and if the value passes the test, that value gets passed on to <code>count()</code>.</p>
<p class="indent">Notice that the <code>filter()</code> method of <code>myStream</code> produces a stream. It’s a slightly modified stream consisting only of elements whose values are greater than 1. We’re now calling the <code>count()</code> method on that filtered stream, rather than on the original <code>myStream</code>. Intermediate operations always produce another stream—that’s how we can chain multiple operations together to manipulate the data as it flows by in the stream. As long as we keep doing intermediate operations, we keep the stream of data flowing; it ends only when we perform a terminal operation like <code>count()</code>. That turns the stream into one thing—say, a number—and ends the stream. We’ll look at streams with multiple intermediate operations shortly.</p>
<p class="indent">Now, let’s try filtering for elements &gt; 2 and count the results:</p>
<p class="imageip"><img src="images/un545-01.jpg" alt="images" /></p>
<p class="noindent">Run that code and you’ll get an exception:</p>
<p class="imageip"><img src="images/un545-02.jpg" alt="images" /></p>
<p class="noindent">Hmm. What does it mean the “stream has already been operated upon or closed”?</p>
<p class="indent">Streams can be used only once. To turn again to our analogy: Imagine you’re standing on the bank of the stream. Once the water in the stream has flowed by you, you can’t see it again. That water is gone, and you can’t get it back.</p>
<p class="indent">No problem, we can just create the stream again. In Java, streams are lightweight objects, so you can create multiple streams if you need to:</p>
<p class="imageip"><img src="images/un545-03.jpg" alt="images" /></p>
<p class="indent">We can’t reuse <code>myStream</code>, so here, we’ve created a new stream from the <code>myNums</code> array. We’re filtering that stream using a <code>Predicate</code> that tests for an element <span id="page_546" epub:type="pagebreak"></span>greater than 2 and then counting the elements that pass that test. We do all three things: create the stream, filter the stream, and count the elements in one line of code.</p>
<p class="indent">In our example, we have only 1 element greater than 2, so we see this as the result:</p>
<p class="imageip"><img src="images/un546-01.jpg" alt="images" /></p>
<p class="indent">In Java, a stream is an object that gets its data from a source, but it doesn’t store any data itself. The data flowing through the stream can be operated on, multiple times if we want, with intermediate operations, like <code>filter()</code>. The stream ends when we use a terminal operation, like <code>count()</code>, and once we’ve used a stream, we can’t reuse it.</p>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch9lev1sec2"><strong>How to Create a Stream (OCP Objectives 3.5 and 9.3)</strong></h3>
<p class="noindent"><em>3.5   Iterate using forEach methods of Streams and List.</em></p>
<p class="noindent"><em>9.3   Use Stream API with NIO.2.</em></p>
<p class="indentt">There are a variety of ways you can create a stream. Given that streams are for data processing, you’ll probably find you most often create streams from collections, arrays, and files. The collection, array, or file you use to create the stream is the “source” of the stream and provides the data that will flow through the stream. Remember that the stream itself does not contain any data; it operates on the data that is contained in the source, as that data flows through the stream operations.</p>
<h4 class="h4" id="ch9lev2sec1">Create a Stream from a Collection</h4>
<p class="noindent">Let’s step through some examples of how to create a stream. First, here’s how you can create a stream from a basic <code>List</code>, one of the collection types:</p>
<p class="imageip"><img src="images/un546-02.jpg" alt="images" /></p>
<p class="noindent"><span id="page_547" epub:type="pagebreak"></span>This code produces the output:</p>
<p class="imageip"><img src="images/un547-01.jpg" alt="images" /></p>
<p class="indent">What we’re doing in this code is first creating a <code>List</code> of <code>Doubles</code>; then we’re using that <code>List</code> as a source for a stream that filters values, in this case temperatures greater than 110.0, and counts them. Notice that to create the stream, we’re calling the <code>stream()</code> method of the <code>tempsInPhoenix List</code>. This method is a default method of the <code>Collection</code> interface and so is inherited by all classes that implement <code>Collection</code>. The <code>stream()</code> method’s signature is</p>
<p class="imageip"><img src="images/un547-02.jpg" alt="images" /></p>
<p class="indent">You can see that <code>stream()</code> returns an object of type <code>Stream</code>, with a generic object type parameter, meaning the stream is a stream of any object type. If we were to split the line where we create the stream in the code above into two and store the stream in a variable, we’d write the code like this:</p>
<p class="imageip"><img src="images/un547-03.jpg" alt="images" /></p>
<p class="noindent">using <code>Double</code> as the type parameter for the stream whose source is a <code>List</code> of <code>Doubles</code>.</p>
<p class="indent">Don’t forget that a <code>Map</code> (<code>HashMap</code>, <code>TreeMap</code>, etc.) is not a collection inheriting from <code>Collection</code>. If you want to stream a <code>Map</code>, you must first use the <code>entrySet()</code> method to turn the <code>Map</code> into a <code>Set</code>, which <em>is</em> a <code>Collection</code> type:</p>
<p class="imageip"><img src="images/un547-04.jpg" alt="images" /></p>
<p class="noindent">Here, we create a <code>HashMap</code> and add three items to the <code>Map</code>, each with a <code>String</code> and <code>Integer</code> value—a dog’s name and age. Then we stream the dog data from the <code>Map</code> and count the number of dogs older than 4.</p>
<p class="indent">If we try to stream the <code>Map</code> directly, we’ll get a compile-time error. Instead, we first call <code>entrySet()</code> on the <code>Map</code> and then call <code>stream()</code> on the resulting <code>Set</code>. We then call the <code>filter()</code> operation on this stream and get a <code>Map.Entry</code> object as the argument to the <code>Predicate</code> lambda we pass to the filter. We filter to get only dogs older than 4 and count the results (there are two).</p>
<h4 class="h4" id="ch9lev2sec2"><span id="page_548" epub:type="pagebreak"></span>Build a Stream with Stream.of()</h4>
<p class="noindent"><code>Stream.of()</code> is quite flexible; it works with any object values, so you can create a <code>Stream</code> of <code>Strings</code>, <code>Integers</code>, <code>Doubles</code>, etc. The method signature is</p>
<p class="imageip"><img src="images/un548-01.jpg" alt="images" /></p>
<p class="noindent">meaning you can supply the <code>of()</code> method with any number of arguments, and you get back an ordered stream of those values.</p>
<p class="indent">We can use <code>Stream.of()</code> to create a stream from our array of Integers, <code>myNums</code>, like this:</p>
<p class="imageip"><img src="images/un548-02.jpg" alt="images" /></p>
<p class="noindent">Then we use <code>myStream</code> just like we did before to filter and count the items.</p>
<p class="indent">We can make that code even shorter by skipping declaring the array altogether and supply Integer values directly, like this:</p>
<p class="imageip"><img src="images/un548-03.jpg" alt="images" /></p>
<p class="noindent">The source of the <code>Stream</code> here is a little fuzzy; you aren’t actually storing the data values in a data structure first, like you are if you’re streaming the <code>myNums</code> array. The source is there; it’s just hidden behind the scenes.</p>
<h4 class="h4" id="ch9lev2sec3">Create a Stream from an Array</h4>
<p class="noindent">You’ve already seen how to use <code>Arrays.stream()</code> to stream an array; earlier we created an array of Integers and streamed it. Here’s another example of streaming an array, this time, an array of Strings:</p>
<p class="imageip"><img src="images/un548-04.jpg" alt="images" /></p>
<p class="noindent">And we see 3 as the result for the number of dogs in the array. (Of course, this code is completely contrived as you’d never stream an array to count the number of items, but you get the point, we hope).</p>
<p class="indent">Another way to create a stream from an array is to use the <code>Stream.of()</code> method. For our example with the Strings of dog names, we could rewrite the line to create the stream like this:</p>
<p class="imageip"><img src="images/un548-05.jpg" alt="images" /></p>
<h4 class="h4" id="ch9lev2sec4"><span id="page_549" epub:type="pagebreak"></span>Create a Stream from a File</h4>
<p class="noindent">Using a stream to process data in a file is easy. You know you can use <code>Files</code> to read data from a file; the static <code>lines()</code> method of <code>Files</code> returns a <code>Stream</code>, so we can stream the data using the file as the source. Here is the signature of the <code>Files.lines()</code> method:</p>
<p class="imageip"><img src="images/un549-01.jpg" alt="images" /></p>
<p class="noindent">So to create a stream from a file you write:</p>
<p class="imageip"><img src="images/un549-02.jpg" alt="images" /></p>
<p class="noindent">This sets up the stream, but how do you process the data from the stream? You can use the <code>Stream</code>’s <code>forEach()</code> method:</p>
<p class="imageip"><img src="images/un549-03.jpg" alt="images" /></p>
<p class="indent">The <code>forEach()</code> method on a stream works much like the <code>forEach()</code> method on a collection. It takes a <code>Consumer</code>, which we can represent with a lambda expression, and processes each line from the file in the body of the lambda. The <code>File.lines()</code> method provides one line at a time from the file as each data element in the stream, which makes processing data from the file easy.</p>
<p class="indent">Here’s an example to bring this together. We have a file, “dvdinfo.txt,” containing the name, genre, and star of a movie, one per line:</p>
<p class="imageip"><img src="images/un549-04.jpg" alt="images" /></p>
<p class="indent">We want to read the lines of the file, creating a new <code>DVDInfo</code> object for each movie entry:</p>
<p class="imageip"><img src="images/un549-05.jpg" alt="images" /></p>
<p class="indent"><span id="page_550" epub:type="pagebreak"></span>Here’s how we can do that using the file as a source for a stream, and using the <code>forEach()</code> method to process each line from the file:</p>
<p class="imageip"><img src="images/un550-01.jpg" alt="images" /></p>
<p class="noindent">We see the output from printing the DVDs:</p>
<p class="imageip"><img src="images/un550-02.jpg" alt="images" /></p>
<p class="indent">When processing data from a file using a stream with <code>forEach()</code> like we do here, remember that within the lambda expression we pass to <code>forEach()</code>, all variables must be final or effectively final, so we can’t modify a variable directly (e.g., by changing its value to a value from the file). However, also remember that we <em>can</em> add to or modify the fields of an object from within the lambda expression, so that’s how we can add each DVD to the <code>List</code> of <code>dvds</code>. The <code>dvds List</code> is effectively final (we don’t try to create a new <code>List</code> object and assign it to the <code>dvds</code> property within the lambda), but the contents of the <code>List</code> can still be modified by adding new DVDs to it. As a result, once the stream terminates (i.e., the last line from the file is read), we have all the DVDs from the file stored in the <code>dvds List</code>. We must store the DVDs somewhere if we want to use them after the stream is complete because the stream itself doesn’t hold any data! However, there’s a better <span id="page_551" epub:type="pagebreak"></span>way to store the DVDs in the <code>dvd</code>s <code>List</code>, which we’ll see later on in the chapter, so put a bookmark here and we’ll return to this example later. For more <code>Files</code> methods that create streams, check the Online Appendix.</p>
<p class="indent">The <code>forEach()</code> method of <code>Stream</code> is another example of a terminal operation (along with <code>count()</code>, which we saw earlier). It does not produce another stream; rather it takes each item flowing by in the stream and consumes it (with a <code>Consumer</code>). It doesn’t produce anything (i.e., <code>forEach()</code> is void), so whatever you want to do with the data you’re processing with <code>forEach()</code> must happen in the <code>Consumer</code> you pass to it.</p>
<h4 class="h4" id="ch9lev2sec5">Primitive Value Streams</h4>
<p class="noindent">As you might expect, there are also primitive streams designed to avoid autoboxing, for <code>double</code>s, <code>int</code>s, and <code>long</code>s. These are <code>DoubleStream</code>, <code>IntStream</code>, and <code>LongStream</code>, respectively. So, you can create a <code>DoubleStream</code> like this:</p>
<p class="imageip"><img src="images/un551-01.jpg" alt="images" /></p>
<p class="noindent">Notice there’s no type parameter on the stream because this is a stream of <code>double</code> values and that’s specified by the type itself, <code>DoubleStream</code>.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>Keep in mind the difference between a <code>Stream&lt;Double&gt;</code> and <code>DoubleStream</code>. The first is a stream of <code>Double</code> objects; the second is a stream of <code>double</code> values. If you create a <code>List&lt;Double&gt;</code> and then stream it:</em></strong></p>
<p class="noindent1"><img src="images/un551-02.jpg" alt="images" /></p>
<p class="noindent"><strong><em>the stream is type <code>Stream&lt;Double&gt;</code>. Don’t get fooled on the exam with this small distinction!</em></strong></p>
</div>
<h4 class="h4" id="ch9lev2sec6">Summary of Methods to Create Streams</h4>
<p class="noindent">As you’ve just seen, there are a variety of ways to make streams—from collections, arrays, files, and values. <a href="ch9.xhtml#ch9tab1">Table 9-1</a> summarizes the methods you should be familiar with for the exam. And keep a close eye on those types; it can be easy to slip up and think you’re creating a <code>DoubleStream</code> when you’re creating a <code>Stream&lt;Double&gt;</code>! Note: This is not an exhaustive list of all the ways to create streams, so see each interface/class for more details and options.</p>
<p class="tabcap" id="ch9tab1"><span id="page_552" epub:type="pagebreak"></span><span class="table"><strong>TABLE 9-1</strong></span> Methods to Create Streams</p>
<p class="imaget"><img src="images/tab09-01.jpg" alt="Images" /></p>
<h4 class="h4" id="ch9lev2sec7">Why Streams?</h4>
<p class="noindent">You might be wondering why streams were added to Java. So far the examples you’ve seen are relatively simple, and you could easily accomplish the same thing using iteration over a <code>Collection</code>. The code might be a bit more concise, but it doesn’t seem to really do anything fantastically different.</p>
<p class="indent">The main reason to use streams is when you start doing multiple intermediate operations. So far, we’ve been performing only one intermediate operation: a filter, using a variety of different <code>Predicates</code> to filter the data we get from the stream before we count it. However, when we use multiple intermediate operations, we start seeing the benefits of streams.</p>
<p class="indent">First, here’s a quick example:</p>
<p class="imageip"><img src="images/un552-01.jpg" alt="images" /></p>
<p class="imageip"><span id="page_553" epub:type="pagebreak"></span><img src="images/un553-01.jpg" alt="images" /></p>
<p class="noindent">Here, we’ve got a list of names. Let’s say we want to see the names that begin with “B” or “C” and have a length &gt; 3.</p>
<p class="indent">First, we stream the names from the source <code>List</code>, <code>names</code>. Then, we filter on the starting letter “B” or “C”. The result is that only names that start with “B” or “C” get passed through to the next filter. The next filter checks the length of the string and only passes through strings whose length is greater than 3. Both of these filter operations are “intermediate operations” because the stream continues; the stream is slightly modified (some data elements are discarded if they don’t pass the test in the filter), but any data elements left in the stream continue flowing through the stream.</p>
<p class="indent">Finally we have a “terminal operation” that ends the stream: the <code>forEach()</code> method, which just prints the names. And we see the output:</p>
<p class="imageip"><img src="images/un553-02.jpg" alt="images" /></p>
<p class="noindent">You’re probably saying to yourself, what’s the big deal? We could do the same thing using iteration, right?</p>
<p class="indent">The big deal is that streams use something called a “pipeline,” which can, in some circumstances, dramatically improve the efficiency of data processing. To understand how the stream pipeline works, let’s break the above code down a bit more and see what happens in each step.</p>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch9lev1sec3"><strong>The Stream Pipeline (OCP Objective 3.6)</strong></h3>
<p class="noindent"><em>3.6   Describe Stream interface and Stream pipeline.</em></p>
<p class="indentt">A stream pipeline consists of three parts: a source, zero or more intermediate operations, and a terminal operation. The <em>source</em> describes where the data is coming from; the <em>intermediate operations</em> operate on the stream and produce another, perhaps modified, stream; and the <em>terminal operation </em>ends the stream and typically produces a value or some output.</p>
<p class="indent"><span id="page_554" epub:type="pagebreak"></span>So the stream pipeline in our code above defines the <code>names List</code> as the source for the stream, contains two intermediate operations that filter the data, and then terminates with <code>forEach()</code>, which prints the data:</p>
<p class="imageip"><img src="images/un554-01.jpg" alt="images" /></p>
<p class="indent">One analogy often used at this point is an assembly line. When you stream the names <code>List</code>, the first data element of the list is streamed to the first filter operation. At that point the second filter and the <code>forEach()</code> are just waiting for a data element. Once the first filter is complete, that data element is possibly discarded, if it doesn’t begin with a “B” or “C”, in which case the second filter and the <code>forEach()</code> never see it. This makes the subsequent stream more efficient.</p>
<p class="indent">If the data element is not discarded, then it’s passed along to the second filter, which starts working on that element. In the meantime, the second data element is streamed to the first filter. Just like the assembly line, we now have the first filter working on the second data element, while the second filter is still working on the first one.</p>
<p class="indent">If the second filter’s <code>Predicate</code> test is passed on the first data element, that element is passed along to the <code>forEach()</code>, which starts working on it (by printing it out). In the meantime, the second data element is passed to the second filter, assuming it passes the <code>Predicate</code> test in the first filter. Then the third data element is streamed to the first filter.</p>
<p class="indent">As you can see, the assembly-line analogy works pretty well for the pipeline. Like an assembly line, we can get some efficiencies working with streams for two reasons: First, we can do multiple operations on data in one pass, and Java is optimized so it keeps minimal intermediate state during the operations part of the pipeline. Second, in some circumstances, we can parallelize streams to take advantage of the underlying architecture of the system and do parallel computations very easily. Not all streams can be parallelized, but some can. We’ll talk more about parallel streams later in “A Taste of Parallel Streams.”</p>
<p class="indent">There’s one other thing you should know about streams: they are lazy! And, despite what you might think, lazy streams can be more efficient.</p>
<h4 class="h4" id="ch9lev2sec8"><span id="page_555" epub:type="pagebreak"></span>Streams Are Lazy</h4>
<p class="indent">Look again at the code:</p>
<p class="imageip"><img src="images/un555-01.jpg" alt="images" /></p>
<p class="noindent">What do you think happens if we write the following instead:</p>
<p class="imageip"><img src="images/un555-02.jpg" alt="images" /></p>
<p class="noindent">That is, we’ve written the pipeline without the <code>forEach()</code> terminal operation.</p>
<p class="indent">You know that what you get back from the second <code>filter()</code> is another stream. But has anything actually happened yet? Is any data flowing through the stream?</p>
<p class="indent">The answer is no. Nothing has happened. Going back to the assembly-line analogy, the worker at station 1 (filter one) is still sitting idle, as is the worker at station 2 (filter two). That’s because no terminal operation has been executed yet. We’ve got everything set up, but nothing to kick-start the data processing.</p>
<p class="indent">Not until the <code>forEach()</code> is executed does anything happen. As soon as the terminal operation is executed, then the assembly line kicks into gear, and the data starts flowing from the source through the stream and into the operations.</p>
<p class="indent">It’s important to note here that our analogies of the water stream and the assembly line break down when you remember that streams don’t hold any data. Even though we talk about data elements as “flowing through the stream,” the data is never “in” the stream (unlike water that really is in a real-life stream and items that really are in an assembly line). The operations you define on a stream are how you specify ways to manipulate the data that’s in the source in a particular order. In that sense, of course, streams are lazy because no data is flowing, even though it helps us to think about streams that way.</p>
<p class="indent">This laziness makes streams more efficient because the JDK can perform optimizations to combine the operations efficiently, to operate on the data in a single pass, and to reduce operations on data whenever possible. If it’s not necessary to run an operation on a piece of data (e.g., because we’ve already found the data element we’re looking for, or because we’ve eliminated a data element in a prior intermediate operation, or because we’ve limited the number of data elements we want to operate on), then we can avoid even getting the data element from the source.</p>
<p class="indent"><span id="page_556" epub:type="pagebreak"></span>For most, if not all, of the simple examples we’ll be working with in this book in preparation for the exam, the stream pipeline will not offer any tremendous advantage beyond thinking about data processing in a new way, and perhaps more concise code. However, once you get in the real world and start working with large amounts of data, you may realize the benefits of streams from an efficiency standpoint, especially if you can work with streams that can be parallelized (which we’ll get to later, as we said before).</p>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch9lev1sec4"><strong>Operating on Streams (OCP Objectives 3.7 and 5.1)</strong></h3>
<p class="noindent"><em>3.7   Filter a collection by using lambda expressions.</em></p>
<p class="noindent"><em>5.1   Develop code to extract data from an object using peek() and map() methods including primitive versions of the map() method.</em></p>
<p class="indentt">You may have heard the expression “map-filter-reduce”: a general abstraction to describe functions that operate on a sequence of elements. It perfectly describes what we are often doing with streams: we might “map” an input to a slightly different output, then “filter” that output by some criteria, and finally “reduce” to a single value or to a printed output. When you map-filter-reduce, you are simply specifying a sequence of operations to be performed on the data in the stream’s source that leads to a result. As we said earlier, instead of using a stream, you could create a <code>for</code> loop over the source data structure yourself, apply each of the operations in turn, accumulate the results into a new data structure, and you’d accomplish the same thing as a stream. The advantage of a stream is twofold: you can (often) write a sequence of operations to perform on the stream more concisely, and you can (sometimes) take advantage of some optimizations the JDK does under the covers to perform those operations more efficiently.</p>
<p class="indent">With streams, we take the map-filter-reduce abstraction and translate it into operations using the <code>map()</code>, <code>filter()</code>, and <code>reduce()</code> methods (and their variations) on a stream.</p>
<p class="indent">You’ve already seen the Java <code>Stream</code>’s <code>filter()</code> method. As we said earlier, <code>filter()</code> takes a <code>Predicate</code> and tests each element in the stream pipeline, producing a stream of elements that pass the test.</p>
<p class="indent"><span id="page_557" epub:type="pagebreak"></span>The <code>Stream</code>’s <code>map()</code> method is another intermediate operation; however, unlike <code>filter()</code>, <code>map()</code> doesn’t winnow down the elements of a stream; rather, <code>map()</code> transforms elements of a stream. For instance, <code>map()</code> might compute the square of a number, mapping a stream of numbers to a stream of their squares. Or <code>map()</code> might get the age of a <code>Person</code> so that the next step (say, a filter) can find ages greater than 21.</p>
<p class="indent">The <code>map()</code> method takes a <code>Function</code>. Remember from the previous chapter that the purpose of a <code>Function</code> is to transform a value. The <code>Function</code>’s <code>apply()</code> method takes one value and produces another value (not necessarily of the same type), so the <code>Function</code> you pass to <code>map()</code> will “map” one value to another. The <code>Function</code>’s functional method <code>apply()</code> that you pass into <code>map()</code> gets called by <code>map()</code> behind the scenes, and the value returned from <code>apply()</code> gets passed on to the next operation in the stream pipeline.</p>
<p class="indent">Reduce is both a general method, <code>reduce()</code>, as well as a specific method like <code>count()</code> and others you’ll see shortly. All reductions are also terminal operations. Reduction operations are designed to combine multiple inputs into one summary result, which could be a single number, like the reduction operation <code>count()</code> produces, or a collection of values, which we’ll see examples of later.</p>
<p class="indent">The <code>Stream</code>’s <code>reduce()</code> method is a general method for reducing a stream to a value; the basic version of <code>reduce()</code> takes a <code>BiFunction</code> (a <code>Function</code> whose <code>apply()</code> method takes two arguments and produces one value) and applies it to pairs of elements from the stream, returning a value. You can think of <code>reduce()</code> as a way to “accumulate” a result, such as summing the values of a stream. Reductions like <code>count()</code>, <code>sum()</code>, and <code>average()</code> are defined as methods of streams; if you want a custom reduce function you can define it yourself using <code>reduce()</code>.</p>
<p class="indent">(Notice how all those functional interfaces from the previous chapter are showing up here?)</p>
<p class="indent">As we work with map-filter-reduce, keep in mind that the stream pipeline specifies a sequence of operations to perform on the data in a source data structure, like an array. There is one stream of data that gets modified and winnowed (the <em>map-filter</em> part) as it passes through the pipeline, and eventually, the data elements in the stream are reduced (the <em>reduce</em> part) to a value (when the stream is no longer a stream again, but rather a single value or another data structure).</p>
<p class="indent">Let’s take a look at a map-filter-reduce set of operations on a stream. We’ll define a <code>List</code> of <code>Integers</code>, take the square of each <code>Integer</code>, test to see whether the square is greater than 20, and if it is, we’ll add 1 to a count, <code>result</code>. Before we do, we’ll look at how we might do this with Java 7, so we can compare it with how we compute this using streams.</p>
<p class="indent"><span id="page_558" epub:type="pagebreak"></span>Here’s the Java 7 way:</p>
<p class="imageip"><img src="images/un558-01.jpg" alt="images" /></p>
<p class="noindent">With the output:</p>
<p class="imageip"><img src="images/un558-02.jpg" alt="images" /></p>
<p class="noindent">We’re simply creating a <code>List</code>, and using a <code>for</code> loop to iterate over the list, compute the square, print out the square if it is greater than 20, and print the number of squares &gt; 20.</p>
<p class="indent">And here’s the Java 8 way, with streams:</p>
<p class="imageip"><img src="images/un558-03.jpg" alt="images" /></p>
<p class="noindent">With the output:</p>
<p class="imageip"><img src="images/un558-04.jpg" alt="images" /></p>
<p class="noindent">Here, we’re streaming the <code>List</code> of <code>Integers</code>, first mapping the number from the stream to its square, then filtering the squares so that we keep only those squares greater than 20, and then reducing using the <code>count()</code> operation to count the squares &gt; 20.</p>
<p class="indent">Which code do you like better? You’re very familiar with the <code>for</code> loop iteration; the stream pipeline with a map-filter-reduce sequence is likely new to you. They <span id="page_559" epub:type="pagebreak"></span>both accomplish the same thing. Using streams like this has the potential to be a bit more efficient (not so much with this particular example because it’s so simple) and is more concise.</p>
<p class="indent">Notice that we can’t print the number with its square using the streams way. Why? Because by the time we get to the <code>count()</code> reduction operation, the only elements we have access to in the stream are the squares of the numbers. The original numbers are stored only in the original <code>List</code>. And don’t be tempted to try to somehow keep track of the index of the square; that won’t work and doesn’t fit the patterns of how we use stream pipelines.</p>
<p class="indent">We can create a “sort of” solution to the problem like this, however:</p>
<p class="imageip"><img src="images/un559-01.jpg" alt="images" /></p>
<p class="noindent">And see the output:</p>
<p class="imageip"><img src="images/un559-02.jpg" alt="images" /></p>
<p class="indent">The method <code>peek()</code> is an intermediate operation that allows you to “peek” into the stream as the elements flow by. It takes a <code>Consumer</code> and produces the same exact stream as it’s called on, so it doesn’t change the values or filter them in any way. Here we’re using it to peek at the numbers in the original stream before we map those numbers to squares and then filter them. We see all the numbers in the original stream, rather than just the numbers that have squares greater than 20.</p>
<p class="indent">You might feel a bit limited by this, but remember that streams are designed for data processing, so typically we’re looking for the result of a sequence of operations applied to a big set of data, and, other than when we’re debugging, we’re not going to be looking at the data as it flows by.</p>
<p class="indent">A more typical example of a map-filter-reduce operation might be to stream a data set of readings, map the stream to get a particular value from a reading, filter that stream to eliminate any outliers, and then find the average reading of that stream. We’ll tackle this example next, and in the process, you’ll see a new way to map values and learn about the concept of “optional” values.</p>
<p class="title-o"><span id="page_560" epub:type="pagebreak"></span><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch9lev1sec5"><strong>Map-Filter-Reduce with average() and Optionals (OCP Objectives 5.3 and 5.4)</strong></h3>
<p class="noindent"><em>5.3   Develop code that uses the Optional class.</em></p>
<p class="noindent"><em>5.4   Develop code that uses Stream data methods and calculation methods.</em></p>
<p class="indentt">Imagine you have a piece of equipment that’s taking a reading once per week, and you want to find the average of the readings you’ve measured so far this year. You know that the readings should probably be between 406 and 407, so you decide to throw away readings that are less than 406 or greater than 407 because those may be errors.</p>
<p class="indent">You start by creating a class for the readings:</p>
<p class="imageip"><img src="images/un560-01.jpg" alt="images" /></p>
<p class="noindent">Each reading gets stored with its value, along with the year, month, and day, in a <code>Reading</code> object, and the <code>Reading</code> objects are stored in a <code>List</code>:</p>
<p class="imageip"><img src="images/un560-02.jpg" alt="images" /></p>
<p class="indent">Now let’s use a stream to find the average of the readings that are between 406 and 407. The first thing we’ll do is stream the <code>readings</code>:</p>
<p class="imageip"><img src="images/un560-03.jpg" alt="images" /></p>
<p class="indent"><span id="page_561" epub:type="pagebreak"></span>For this computation, we’re interested only in the value portion of the readings because we’re trying to get the average. We can map each reading to its value, essentially converting the reading to a single <code>double</code> value. But we can’t use <code>map()</code> because <code>map()</code> takes a <code>Function</code> whose <code>apply()</code> method takes an object and returns an object. Here’s the method signature of <code>map()</code>:</p>
<p class="imageip"><img src="images/un561-01.jpg" alt="images" /></p>
<p class="indent">As we said earlier, <code>map()</code> takes a <code>Function</code> (called <code>mapper</code> in the signature above). <code>map()</code> applies that <code>Function</code> (by calling the <code>apply()</code> method) on each value in the stream. Recall that the <code>Function</code>’s <code>apply()</code> method takes an object and returns an object. So if we call <code>map()</code> on a <code>Stream</code> of objects, like we want to do here with our stream of <code>Reading</code> objects, what we get back is also a stream of objects. But <code>Reading.value</code> is a <code>double</code>, not a <code>Double</code>, so what we really want to get back is a stream of <code>double</code>s.</p>
<p class="indent">Is there a solution? Yes, of course! The <code>Stream.mapToDouble()</code> method takes a <code>ToDoubleFunction</code>, whose <code>applyAsDouble()</code> method takes an object and returns a <code>double</code>:</p>
<p class="imageip"><img src="images/un561-02.jpg" alt="images" /></p>
<p class="noindent">This is exactly what we need, so the next step in the stream pipeline is <code>mapToDouble()</code>:</p>
<p class="imageip"><img src="images/un561-03.jpg" alt="images" /></p>
<p class="indent">We use a lambda expression for the <code>ToDoubleFunction</code>, pass in a <code>Reading</code> object, <code>r</code>, to the <code>applyAsDouble()</code> method (which gets called by <code>mapToDouble()</code> behind the scenes), and get back the <code>double</code> value, <code>r.value</code>.</p>
<p class="indent">Keeping track of the type in these situations is tricky! Notice: what we get back from the <code>mapToDouble()</code> method of the <code>Stream</code> that we created with <code>readings.stream()</code> is a <code>DoubleStream</code>:</p>
<p class="imageip"><img src="images/un561-04.jpg" alt="images" /></p>
<p class="noindent">So by calling <code>mapToDouble()</code>, we’ve converted the initial <code>Stream</code> of <code>Reading</code> objects (<code>Stream&lt;Reading&gt;</code>) into a stream of <code>doubles</code>, and that stream has the type <code>DoubleStream</code>.</p>
<p class="indent">The capitalization on these types can be very confusing. Don’t mix up a <code>DoubleStream</code> with a <code>Stream&lt;Double&gt;</code> here, or forget that <code>ToDoubleFunction</code>’s <code>applyAsDouble()</code> method returns a <code>double</code>. It’s easy to get mixed up on this issue and think you’re working with <code>Double</code>s when you’re actually working with <code>double</code>s (or vice versa), and in this case, it matters a lot, as you’ll see shortly.</p>
<p class="indent"><span id="page_562" epub:type="pagebreak"></span>After all that, where are we?</p>
<p class="imageip"><img src="images/un562-01.jpg" alt="images" /></p>
<p class="noindent">We’ve mapped the stream of <code>Reading</code> objects into a stream of <code>double</code>s, and next we want to filter the stream so we keep only the values greater than or equal to 406.0 and less than 407.0:</p>
<p class="imageip"><img src="images/un562-02.jpg" alt="images" /></p>
<p class="noindent">We’ve changed the variable we’re using in the lambda expression in <code>filter()</code> from <code>r</code> (for <code>Reading</code>) to <code>v</code> (for <code>value</code>) as a reminder that the stream we’re filtering is a <code>DoubleStream</code>: that is, a stream of the <code>double</code> values from the <code>List</code> of <code>Readings</code>.</p>
<p class="indent">Note again that at this point in the computation, nothing has actually happened. The stream is lazy! No computation is going on until we get to the reduce part of the map-filter-reduce: the terminal operation. So far we have a source (the <code>List</code> of <code>Readings</code>), a stream, and two intermediate operations.</p>
<p class="indent">The reduction operation we are going to use is the <code>average()</code> method. But if you look for <code>average()</code> in the <code>Stream</code> interface, you will not find it. That’s because <code>average()</code> is a method of the <code>DoubleStream</code> interface (and its primitive cousins, <code>IntStream</code> and <code>LongStream</code>). That makes sense because <code>average()</code> is designed to work with numbers, not objects. And it’s convenient that we mapped the stream of <code>Readings</code> into a stream of <code>doubles</code> (we <em>do</em> plan ahead for these examples).</p>
<p class="indent">Here is the type signature for the <code>DoubleStream</code>’s <code>average()</code> method:</p>
<p class="imageip"><img src="images/un562-03.jpg" alt="images" /></p>
<p class="noindent">You probably expected <code>average()</code> to return a <code>double</code>, right? And what on earth is this <code>OptionalDouble</code> thing?</p>
<p class="indent">An <code>OptionalDouble</code> is one of several types of optionals that are new in Java 8, which represent values that may or may not be there. Strange! Why would the average of our readings not be there?</p>
<p class="indent">Well, think about it this way. What if the source is empty? That is, what if our <code>List</code> of <code>Readings</code> is empty? Or what if, when we filter the stream, the filter eliminates all the values from the stream, so the result of the filter is an empty stream? We don’t know until we get to <code>average()</code> whether there’s anything actually <em>in</em> the stream (remember, the stream is lazy). And, as you know, the average value of a set of values is computed by adding up all the values and then dividing <span id="page_563" epub:type="pagebreak"></span>by the number of values. If the number of values is 0, then you’d be dividing by 0, which, as we all know, is a <em>very bad thing to do</em>.</p>
<p class="indent">Whenever we compute the average of some collection of values, we always have to check to make sure there’s at least one of them so we don’t get ourselves into this situation. But if we forget to check to see whether our source is empty before we stream it, or, perhaps more likely, we’re in the middle of a stream pipeline and we’ve created an empty stream by filtering out all the values, presto: we’re in a situation where we’re trying to compute the average of an empty stream and we’re going to get ourselves into trouble. Optionals help prevent that trouble.</p>
<p class="indent">It doesn’t make sense to return <code>null</code> in this situation because we’re expecting a primitive <code>double</code>. And it doesn’t make sense to return 0.0 because that could be a valid result for the average. Instead, we get back an <code>OptionalDouble</code>, which is a <code>double</code> value that might or might not be there. To finish off this line of code, we terminate the stream pipeline with a call to <code>average()</code> and store the result in an <code>OptionalDouble</code> variable, <code>avg</code>:</p>
<p class="imageip"><img src="images/un563-01.jpg" alt="images" /></p>
<p class="noindent">If you try to print the value of <code>avg</code>, like this:</p>
<p class="imageip"><img src="images/un563-02.jpg" alt="images" /></p>
<p class="noindent">what you see is</p>
<p class="imageip"><img src="images/un563-03.jpg" alt="images" /></p>
<p class="noindent">The correct result—that is, the average of the readings—is 406.2125, but we’re seeing that result wrapped an <code>OptionalDouble</code>. How do you get a <code>double</code> value out of an <code>OptionalDouble</code>? You use the <code>getAsDouble()</code> method:</p>
<p class="imageip"><img src="images/un563-04.jpg" alt="images" /></p>
<p class="noindent">And now you’ll see the result:</p>
<p class="imageip"><img src="images/un563-05.jpg" alt="images" /></p>
<p class="indent">The problem with this code, however, is if the <code>OptionalDouble</code> is empty, then you’ll get a <code>NoSuchElementException</code>. Just because you get an <code>OptionalDouble</code> back from <code>average()</code> doesn’t mean you completely abdicate responsibility for checking to make sure there’s a value there before you try to use it!</p>
<p class="indent"><span id="page_564" epub:type="pagebreak"></span>If you do try to call <code>getAsDouble()</code> on an empty <code>OptionalDouble</code>, you’ll see</p>
<p class="imageip"><img src="images/un564-01.jpg" alt="images" /></p>
<p class="noindent">meaning you’re trying to get a <code>double</code> that isn’t there. A better way to write this code is to first check to make sure there is a value <em>present</em> in the <code>OptionalDouble</code> with the <code>isPresent()</code> method:</p>
<p class="imageip"><img src="images/un564-02.jpg" alt="images" /></p>
<p class="indent">If there’s a value, we print it; otherwise, we print a message saying the optional must have been empty. Now if you run the code on an empty <code>List</code>, or a <code>List</code> with no values in the 406–407 range, you won’t get a runtime error and you’ll see the message:</p>
<p class="imageip"><img src="images/un564-03.jpg" alt="images" /></p>
<p class="indent">Whew! We finally have our average value, 406.2125, for our <code>List</code> of <code>Readings</code> using a stream pipeline. That was a lot to take in. We introduced map-filter-reduce, talked about how map works in more detail and how map and filter differ, and introduced optionals, which we’ll be returning to in more detail.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>There’s ample room for confusion with <code>DoubleStream, Stream&lt;Double&gt;, getAsDouble()</code>, etc. Adding to the confusion is that sometimes a reduction will return an <code>OptionalDouble</code> and sometimes an <code>Optional&lt;Double&gt;</code> (and, likewise, for <code>long/Long</code> and <code>int/Integer</code>).</em></strong></p>
<p class="indent"><strong><em>This is a good time to pay close attention to types, type parameters, and method signatures. There will be times on the exam when you’ll have to select the correct type as part of your answer, and knowing the difference between <code>DoubleStream</code> and <code>Stream&lt;Double&gt;</code> or <code>OptionalDouble</code> and <code>Optional&lt;Double&gt;</code> will be the key to choosing the correct answer.</em></strong></p>
</div>
<h4 class="h4" id="ch9lev2sec9"><span id="page_565" epub:type="pagebreak"></span>Reduce</h4>
<p class="noindent">What we did with this example code is take a source, a <code>List</code> of <code>Readings</code>, stream it, map the readings (mapping a <code>Reading</code> to a <code>double</code>), filter the values (keeping only values between 406 and 407), and then reduce (by taking the average). Let’s return to the reduce part of map-filter-reduce.</p>
<p class="indent">You’ve seen a couple of reductions so far: <code>count()</code> and <code>average()</code>. The <code>count()</code> method is defined for both <code>Stream</code> and the primitive versions of <code>Stream</code>: <code>IntStream</code>, <code>LongStream</code>, and <code>DoubleStream</code>, while <code>average()</code> is defined only for the primitive streams. Other handy methods defined on the primitive streams include <code>min()</code>, <code>max()</code>, and <code>sum()</code>, which result in the minimum value in a stream, the maximum value in a stream, and the sum of the values in a stream.</p>
<p class="indent">Like <code>average()</code>, <code>min()</code> and <code>max()</code> also return optional values. If you are looking for the <code>max()</code> reading in our <code>List</code> of <code>Reading</code>s, you’d write:</p>
<p class="imageip"><img src="images/un565-01.jpg" alt="images" /></p>
<p class="indent">Looking at the type signature of <code>sum()</code>, however, you will probably notice that <code>sum()</code> does not return an optional value. Rather, <code>DoubleStream.sum()</code> returns a <code>double</code>. Why do <code>average()</code>, <code>max()</code>, and <code>min()</code> return optionals, but <code>sum()</code> does not?</p>
<p class="indent">As with <code>average()</code>, it makes no sense to take the <code>max()</code> or <code>min()</code> of an empty stream. Therefore, an optional value is returned, indicating that a value may not exist.</p>
<p class="indent">Taking the <code>sum()</code> of an empty list makes a little more sense if you assume the sum of an empty stream is 0.0. And, in fact, if you try to <code>sum()</code> an empty <code>DoubleStream</code>, that’s exactly what you’ll get:</p>
<p class="imageip"><img src="images/un565-02.jpg" alt="images" /></p>
<p class="noindent">produces the output:</p>
<p class="imageip"><img src="images/un565-03.jpg" alt="images" /></p>
<p class="indent"><span id="page_566" epub:type="pagebreak"></span>By default, the sum of an empty stream is 0. Let’s take a look at how you can write your own reduction methods with <code>reduce()</code> and have an opportunity to provide a default value in case you have an empty stream.</p>
<h4 class="h4" id="ch9lev2sec10">Using reduce()</h4>
<p class="noindent">The methods <code>count()</code>, <code>average()</code>, <code>min()</code>, <code>max()</code>, and <code>sum()</code> are all reduction methods already defined on streams. You can also define your own reductions using the <code>reduce()</code> method. We’ll rewrite the code to sum the values in the (original, nonempty) <code>readings</code> list using <code>reduce()</code> rather than <code>sum()</code>.</p>
<p class="indent">What is <code>sum()</code> doing to “reduce” a <code>DoubleStream</code> of <code>double</code> values into one value? It’s taking values as they flow from the stream and adding them up, so that’s what we need to do in <code>reduce()</code> if we want to create our own sum reduction method.</p>
<p class="indent">If we look at the type signature of <code>DoubleStream.reduce()</code>, we see</p>
<p class="imageip"><img src="images/un566-01.jpg" alt="images" /></p>
<p class="indent">In the previous chapter, we looked only at <code>UnaryOperator</code>s, but hopefully, if you studied the Java 8 Functional APIs a bit further, you ran across <code>BinaryOperator</code>s, which are like <code>UnaryOperator</code>s except their functional methods take two values as arguments, rather than one. And recall that operators are a special case of <code>Function</code> in that the arguments and the return value of the functional method must be the same type.</p>
<p class="indent">A <code>DoubleBinaryOperator</code> is an operator whose functional method, <code>applyAsDouble()</code>, takes two <code>double</code> values and returns a <code>double</code>.</p>
<p class="indent">To write our own method to sum all the values in the stream using <code>reduce()</code>, we pass a <code>DoubleBinaryOperator</code> to <code>reduce()</code>, which adds the two arguments together and returns the sum:</p>
<p class="imageip"><img src="images/un566-02.jpg" alt="images" /></p>
<p class="noindent">And we see the output:</p>
<p class="imageip"><img src="images/un566-03.jpg" alt="images" /></p>
<p class="indent">The <code>reduce()</code> method sums all the values in the stream, two at a time, to get a total sum. In other words, it computes the final result by “accumulating” the values coming in from the stream.</p>
<p class="indent"><span id="page_567" epub:type="pagebreak"></span>You might wonder, well, how does this work when we are streaming elements one at a time? If you’re thinking of the assembly-line analogy, you might be thinking of <code>reduce()</code> as the last station on the assembly line and imagining <code>reduce()</code> getting one element at a time.</p>
<p class="indent">Again, think of reductions as <em>accumulators:</em> they accumulate values from the stream so they can compute one value. It’s as if the final station in the assembly line is putting all the values from the stream into one big box in order to do the terminal operation on them.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>Don’t forget: this analogy of the assembly line isn’t quite correct. We think of elements flowing through a stream one at a time, like items on an assembly line, but in reality, it doesn’t quite work that way. There is no data in a stream; we’re simply defining operations on the stream’s source (a data structure) that happen in a particular sequence and then get a result by terminating with a reduction. Although it’s helpful to think of it like a stream of water or an assembly line as a way to understand streams, how the JDK handles that computation internally is probably quite different: with optimizations and even parallelization, the reality is not like the analogy.</em></strong></p>
</div>
<p class="indent">Take another look at the code above and notice that when we switched from <code>sum()</code> to <code>reduce()</code>, we had to go back to using <code>OptionalDouble</code> for the result. That’s because <code>reduce()</code> is a general reduction function that takes any <code>DoubleBinaryOperator</code>. We know that the <code>applyAsDouble()</code> method must produce a number, but in the situation where the stream is empty, that <code>applyAsDouble()</code> method will never get called, so we need a way to say there might not be a result at all. Again, that’s what the <code>OptionalDouble</code> says.</p>
<p class="indent">There’s another <code>reduce()</code> method in <code>DoubleStream</code> that takes an <em>identity</em> along with an accumulator function and returns a <code>double</code>:</p>
<p class="imageip"><img src="images/un567-01.jpg" alt="images" /></p>
<p class="indent">The identity argument serves two roles: it provides an initial value and a value to return if the stream is empty.</p>
<p class="indent">If you provide the identity value, you’re providing an initial value for the result of applying the accumulator function, <code>op</code>. The sum is computed by adding values from the stream to this initial value, and when the stream is empty, the identity provides a default result for the sum. For a method that produces a sum, it makes sense for <span id="page_568" epub:type="pagebreak"></span>that identity value to be 0.0. Because we have a value to return when the stream is empty, we no longer have to use an <code>OptionalDouble</code> because we’ll always get a value back:</p>
<p class="imageip"><img src="images/un568-01.jpg" alt="images" /></p>
<h4 class="h4" id="ch9lev2sec11">Associative Accumulations</h4>
<p class="noindent">We just showed you how to use <code>reduce()</code> to build your own function that sums up the values in a stream. So you might be thinking, hey I could try the same thing for average. You might even try writing the following code:</p>
<p class="imageip"><img src="images/un568-02.jpg" alt="images" /></p>
<p class="noindent">What you might see is</p>
<p class="imageip"><img src="images/un568-03.jpg" alt="images" /></p>
<p class="noindent">Not only is that answer different from the one we got before (which was 406.2125), but you also might get a different answer from ours. What is going on here?</p>
<p class="indent">Let’s take a look at how we replaced the call to <code>average()</code> with a call to <code>reduce()</code>:</p>
<p class="imageip"><img src="images/un568-04.jpg" alt="images" /></p>
<p class="noindent">As we did with sum, we’re passing a <code>DoubleBinaryOperator</code> to <code>reduce</code>, whose functional method takes two values. We’re summing those two values and dividing by two. The idea is that <code>reduce()</code> operates on two values from the stream at a time, so we’ll get an average for two values and then average that result with the next value that comes in from the stream. It sounds like it should work, but it clearly doesn’t. Something’s up.</p>
<p class="indent"><span id="page_569" epub:type="pagebreak"></span>The problem is that <code>average()</code>—unlike <code>sum()</code>, <code>max()</code>, and <code>min()</code>—is not <em>associative</em>. If you stretch your mind back to high-school algebra, you might (or might not) recall that an operator is associative if the following is true:</p>
<p class="imageip"><img src="images/un569-01.jpg" alt="images" /></p>
<p class="noindent">Addition is associative, thus,</p>
<p class="imageip"><img src="images/un569-02.jpg" alt="images" /></p>
<p class="noindent">The parentheses indicate which operators to apply first. So, on the left, we compute 1 + 2, get 3, and then add 3, to get 6. On the right, we compute 2 + 3, get 5, and then add 1, to get 6 again. We get the same result; therefore, addition (i.e., <code>sum()</code>) is associative.</p>
<p class="indent">Our problem with the code above that replaces the call to <code>average()</code> with a <code>reduce()</code>:</p>
<p class="imageip"><img src="images/un569-03.jpg" alt="images" /></p>
<p class="noindent">is that average is <em>not</em> an associative operator. That might seem odd; it feels like it should be associative, but it’s really not.</p>
<p class="indent">The average of 1, 2, and 3 is 2, right?</p>
<p class="bq">1 + 2 + 3 = 6. 6 / 3 = 2</p>
<p class="noindent">Yep.</p>
<p class="bq">Okay, now try this:</p>
<p class="bq">The average of 1 and 2 = 1.5</p>
<p class="bq">The average of 1.5 and 3 = 2.25</p>
<p class="noindent">And this:</p>
<p class="bq">The average of 2 and 3 = 2.5</p>
<p class="bq">The average of 2.5 and 1 = 1.75</p>
<p class="noindent">Average is clearly <em>not</em> associative!</p>
<p class="indent">Reduction operations <em>must</em> be associative in order to work correctly with streams. That’s why you can’t define your own average function with <code>reduce()</code>; average is not associative. So to take the average of a stream, you must use the <code>average()</code> method.</p>
<p class="indent">What about <code>min()</code> and <code>max()</code>? They are both associative reductions. Try writing your own versions using <code>reduce()</code>. Convince yourself that these operators <span id="page_570" epub:type="pagebreak"></span>really are associative and then try writing the code to find the min and max of a stream of values.</p>
<h4 class="h4" id="ch9lev2sec12">map-filter-reduce Methods</h4>
<p class="noindent">With map, as with all things streams, there are a variety of options depending on the types you are working with. Review <a href="ch9.xhtml#ch9tab2">Table 9-2</a> to get a sense of the patterns of names used with streams and primitive streams. (Note: This is not an exhaustive list of all the ways to map, filter, and reduce, so see each interface for more details and options.)</p>
<p class="tabcap" id="ch9tab2"><span class="table"><strong>TABLE 9-2</strong></span> Methods to Map, Filter, and Reduce</p>
<p class="imaget"><img src="images/tab09-02-1.jpg" alt="Images" /></p>
<p class="imaget"><span id="page_571" epub:type="pagebreak"></span><img src="images/tab09-02-2.jpg" alt="Images" /></p>
<p class="indent"><span id="page_572" epub:type="pagebreak"></span>The key idea to remember with map-filter-reduce is the purpose of each: <code>map()</code> maps values to modify the type or create a new value from the existing value, but without changing the number of elements in the stream you’re working with; <code>filter()</code> potentially winnows the values you’re working with, depending on the result of the <code>Predicate</code> test; and <code>reduce()</code> (and its equivalents) changes the stream of values to one value (or a collection of values) as a terminal operation.</p>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch9lev1sec6"><strong>Optionals (OCP Objective 5.3)</strong></h3>
<p class="noindent"><em>5.3   Develop code that uses the Optional class.</em></p>
<p class="indentt">We’ve explored optionals a bit, and now it’s time to dig in a bit more as optionals are an important part of working with streams and you’ll encounter optionals on the exam. You’ll need to make sure you know which stream operations return optionals and the correct type for those optionals. <a href="ch9.xhtml#ch9tab3">Table 9-3</a> summarizes the methods that result in optionals that we cover in this chapter.</p>
<p class="tabcap" id="ch9tab3"><span class="table"><strong>TABLE 9-3</strong></span> Stream Methods That Return Optionals</p>
<p class="imaget"><img src="images/tab09-03.jpg" alt="Images" /></p>
<p class="indent"><span id="page_573" epub:type="pagebreak"></span>What is an optional? It’s a container that may or may not contain a value. You can think of an optional as a wrapper around a value and that wrapper provides various methods to determine whether a value is there and, if it is, to get that value.</p>
<p class="indent">Optionals show up a lot with streams, because, as you’ve seen, if a stream is empty at any part of the pipeline, then there’s a chance that no value will be returned by the terminal operation of a stream pipeline. Optionals provide a way for the JDK to handle that situation without having to throw a runtime exception.</p>
<p class="indent">The types of optionals include <code>Optional&lt;T&gt;</code> (for objects) and three primitive optionals, <code>OptionalDouble</code>, <code>OptionalInt</code>, and <code>OptionalLong</code>.</p>
<p class="indent">You’ve seen how we used <code>OptionalDouble</code> with the <code>average()</code> operation; now let’s take a look at how we might use <code>Optional&lt;Double&gt;</code> for comparison:</p>
<p class="imageip"><img src="images/un573-01.jpg" alt="images" /></p>
<p class="noindent">You should see the output:</p>
<p class="imageip"><img src="images/un573-02.jpg" alt="images" /></p>
<p class="indent">We’re creating a stream of <code>Double</code> values, using <code>Stream.of()</code> (notice that the <code>double</code>s are being autoboxed into <code>Double</code>s to create the <code>Stream&lt;Double&gt;</code>), and then we’re using the stream terminal operation method, <code>findFirst()</code>, to find the first element of the stream.</p>
<p class="indent">We’ll get into <code>findFirst()</code> in more detail later, but what it does, as you might guess, is find the first element of the stream. Typically, you’ll use <code>findFirst()</code> after filtering the stream, but here, we just want to return the first element of the original stream.</p>
<p class="indent">That element is a <code>Double</code> object, so the type we use for the return value from <code>findFirst()</code> is <code>Optional&lt;Double&gt;</code>. Note that <code>OptionalDouble</code> will not work here! Why? Because <code>findFirst()</code> is operating on a stream of <code>Double</code>s, not a stream of <code>double</code>s. Again, pay very close attention to the types here.</p>
<p class="indent">Just like before, now that we have an optional value, we need to first test to see whether it’s present, with <code>isPresent()</code>, before trying to get that <code>Double</code> value from the <code>Optional</code>. Because we’re working with a <code>Double</code> object rather than a primitive type, the method we use to get the value is <code>get()</code>.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><span id="page_574" epub:type="pagebreak"></span><strong><em>Recall that the method for <code>OptionalDouble</code> is <code>getAsDouble()</code>, and note the patterns for the method names for optionals and primitive optionals:</em></strong></p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><em>Get a value from an <code>Optional&lt;T&gt;: get()</code></em></strong></p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><em>Get a value from an <code>OptionalDouble: getAsDouble()</code></em></strong></p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><em>Get a value from an <code>OptionalInt: getAsInt()</code></em></strong></p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><em>Get a value from an <code>OptionalLong: getAsLong()</code></em></strong></p>
</div>
<p class="indent">Another way to test to see whether an optional contains a value and, if it does, to then get that value, is the <code>ifPresent()</code> method. This method takes a <code>Consumer</code> and tests to see whether the optional value is present; if it is, then the unwrapped value is passed to the <code>Consumer</code>:</p>
<p class="imageip"><img src="images/un574-01.jpg" alt="images" /></p>
<p class="noindent">Note here that the type of <code>n</code> is <code>Double</code>, not <code>Optional&lt;Double&gt;</code>, so to print <code>n</code>, we just write <code>n</code>, not <code>n.get()</code>. You’ll see the output:</p>
<p class="imageip"><img src="images/un574-02.jpg" alt="images" /></p>
<p class="noindent">If your <code>doublesStream</code> is empty, then you will not see any output at all.</p>
<p class="indent">You can create your own optionals, too. For instance, here’s how to create an <code>Optional&lt;Dog&gt;</code> (using our previous class for <code>Dog</code>):</p>
<p class="imageip"><img src="images/un574-03.jpg" alt="images" /></p>
<p class="noindent">This will give you the output:</p>
<p class="imageip"><img src="images/un574-04.jpg" alt="images" /></p>
<p class="indent">What happens if <code>boi</code> happens to be <code>null</code>? Try this:</p>
<p class="imageip"><img src="images/un574-05.jpg" alt="images" /></p>
<p class="noindent">Run it and you’ll see the error:</p>
<p class="imageip"><img src="images/un574-06.jpg" alt="images" /></p>
<p class="indent"><span id="page_575" epub:type="pagebreak"></span>If you are in a situation in which you might be creating an optional from a <code>null</code> object, then you have to take an extra precaution and use the <code>Optional.ofNullable()</code> method rather than <code>Optional.of()</code>. The <code>ofNullable()</code> method creates the optional if the object you pass in is not <code>null</code>; otherwise, it creates an empty optional:</p>
<p class="imageip"><img src="images/un575-01.jpg" alt="images" /></p>
<p class="noindent">You should see the output:</p>
<p class="imageip"><img src="images/un575-02.jpg" alt="images" /></p>
<p class="indent">You can also create empty optionals directly. Assume we have a <code>List</code> of <code>Dog</code> objects. We can create an empty <code>Optional&lt;Dog&gt;</code> and then assign it a value later by streaming the <code>List</code> of <code>Dogs</code>, using <code>findFirst()</code> to find the first <code>Dog</code>:</p>
<p class="imageip"><img src="images/un575-03.jpg" alt="images" /></p>
<p class="noindent">Run this code and you’ll see</p>
<p class="imageip"><img src="images/un575-04.jpg" alt="images" /></p>
<p class="indent">Another way to handle an empty optional is the <code>orElse()</code> method. With this method you get the value in the optional, or, if that optional is empty, you get the value you specify with the <code>orElse()</code> method:</p>
<p class="imageip"><img src="images/un575-05.jpg" alt="images" /></p>
<p class="noindent">You will get the output:</p>
<p class="imageip"><img src="images/un575-06.jpg" alt="images" /></p>
<p class="indent">Try changing <code>emptyDog</code> to <code>optionalBoi</code>:</p>
<p class="imageip"><img src="images/un575-07.jpg" alt="images" /></p>
<p class="imageip"><span id="page_576" epub:type="pagebreak"></span><img src="images/un576-01.jpg" alt="images" /></p>
<p class="noindent">And now you should see</p>
<p class="imageip"><img src="images/un576-02.jpg" alt="images" /></p>
<p class="noindent">because <code>optionalBoi</code> does, indeed, contain a <code>Dog</code>, <code>boi</code>.</p>
<p class="indent"><a href="ch9.xhtml#ch9tab4">Table 9-4</a> summarizes the <code>Optional</code> methods.</p>
<p class="tabcap" id="ch9tab4"><span class="table"><strong>TABLE 9-4</strong></span> Methods of the Optional Class</p>
<p class="imaget"><img src="images/tab09-04.jpg" alt="Images" /></p>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch9lev1sec7"><strong>Searching and Sorting with Streams (OCP Objectives 5.2 and 5.5)</strong></h3>
<p class="noindent"><em>5.2   Search for data by using search methods of the Stream classes including findFirst, findAny, anyMatch, allMatch, noneMatch.</em></p>
<p class="noindent"><em>5.5   Sort a collection using Stream API.</em></p>
<p class="indentt">The <code>Stream</code> interface provides several methods for searching for elements in streams: <code>allMatch</code>, <code>anyMatch</code>, <code>noneMatch</code>, <code>findFirst</code>, and <code>findAny</code>. All <span id="page_577" epub:type="pagebreak"></span>of these operations are terminal operations; that is, they all return a single value, not a stream.</p>
<p class="indent">In addition, all of these operations are <em>short-circuiting</em> operations: that is, as soon as the result is determined, then the operation stops. So, for instance, if you are using <code>allMatch()</code> to determine whether each element passes a matching test, as soon as an element that doesn’t pass the test is found, the operation stops, and the boolean result, <code>false</code>, is returned. All these operations can also be parallelized, so all can operate on streams efficiently.</p>
<h4 class="h4" id="ch9lev2sec13">Searching to See Whether an Element Exists</h4>
<p class="noindent">The methods <code>allMatch()</code>, <code>anyMatch()</code>, and <code>noneMatch()</code> all take a <code>Predicate</code> to do a matching test and return a boolean. Let’s go back to our trusty dogs, and try these methods on a stream of dogs. Here’s the <code>Dog</code> class:</p>
<p class="imageip"><img src="images/un577-01.jpg" alt="images" /></p>
<p class="noindent">And here’s a <code>List</code> of dogs:</p>
<p class="imageip"><img src="images/un577-02.jpg" alt="images" /></p>
<p class="indent">Now that we’ve got a <code>List</code> of dogs, we can stream it and perform stream pipeline operations on the dogs.</p>
<p class="indent"><span id="page_578" epub:type="pagebreak"></span>First, we’ll look for dogs whose weight is greater than 50 pounds and whose names start with <code>"c"</code> using <code>anyMatch()</code>. The <code>anyMatch()</code> method will stop searching as soon as it’s found at least one dog whose name starts with “c”:</p>
<p class="imageip"><img src="images/un578-01.jpg" alt="images" /></p>
<p class="noindent">You should see the output:</p>
<p class="imageip"><img src="images/un578-02.jpg" alt="images" /></p>
<p class="noindent">The dog that matched must be “charis” because he weighs over 50 pounds.</p>
<p class="indent">Now let’s use <code>allMatch()</code> to find whether all the dogs in the list have an age greater than 5. Here, we map the stream of dogs to a stream of their ages first and then use <code>allMatch()</code> to check each dog to make sure each has an age greater than 5795. <code>allMatch()</code> will stop and return false as soon as it finds any dog that fails this test.</p>
<p class="imageip"><img src="images/un578-03.jpg" alt="images" /></p>
<p class="noindent">All our dogs are older than 5, so you should see</p>
<p class="imageip"><img src="images/un578-04.jpg" alt="images" /></p>
<p class="indent">Finally, we’ll use <code>noneMatch()</code> to make sure that none of the dogs in the stream are named <code>"red"</code>. First, we map the stream of dogs to a stream of the dog names, and then we use <code>noneMatch()</code> to check the name:</p>
<p class="imageip"><img src="images/un578-05.jpg" alt="images" /></p>
<p class="noindent">Since none of our dogs have the name “red,” you should see</p>
<p class="imageip"><img src="images/un578-06.jpg" alt="images" /></p>
<h4 class="h4" id="ch9lev2sec14"><span id="page_579" epub:type="pagebreak"></span>Searching to Find and Return an Object</h4>
<p class="noindent">All of these matching methods determine whether a match exists or not. If you want to actually get back a result of a match, then you can use <code>findFirst()</code> or <code>findAny()</code>. Neither of these methods takes an argument, so you need to filter first to narrow down the elements you might be searching for. Because <code>filter()</code> could potentially filter out all the elements of the stream, leaving you with an empty stream, you can guess that <code>findFirst()</code> and <code>findAny()</code> both return optionals in case they are called on empty streams; in which case, there is no valid result and the optional will be empty.</p>
<p class="indent">Let’s use <code>findAny()</code> to find any <code>Dog</code> in our list of dogs that weighs more than 50 pounds and whose name begins with <code>"c"</code>. You already know we have one of these dogs (we had a true result when we did the same test earlier with <code>anyMatch()</code>), but this time we want to actually get a <code>Dog</code> object back and use it.</p>
<p class="imageip"><img src="images/un579-01.jpg" alt="images" /></p>
<p class="noindent">The output is</p>
<p class="imageip"><img src="images/un579-02.jpg" alt="images" /></p>
<p class="indent">In this example, only one dog passed the tests in both filters; only “charis” weighs more than 50 pounds and has a name beginning with <code>"c"</code>. So <code>findAny()</code> returns the one dog left in the stream when we call that operation.</p>
<p class="indent">But what if there’s more than one dog in the stream when we call <code>findAny()</code>? For instance, if we look for any dog whose age is older than 5, all the dogs will pass that filter test, so all the dogs will still be in the stream when we call <code>findAny()</code>:</p>
<p class="imageip"><img src="images/un579-03.jpg" alt="images" /></p>
<p class="noindent">You’ll probably see the output:</p>
<p class="imageip"><img src="images/un579-04.jpg" alt="images" /></p>
<p class="indent"><span id="page_580" epub:type="pagebreak"></span>Of course, boi happens to be the first dog in the stream, but technically <code>findAny()</code> could return <em>any</em> of the dogs in the stream. There’s no guarantee it will be the first one (particularly when you parallelize the stream, which we’ll get to later on).</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>Don’t forget that all these matching and finding methods are short-circuiting. That means that as soon as <code>findAny()</code> finds a dog that matches, everything stops.</em></strong></p>
<p class="indent"><strong><em>Let’s add a <code>peek()</code> at just the right spot to see what’s happening in the stream when we run this code. Give this a try:</em></strong></p>
<p class="noindent1"><img src="images/un580-01.jpg" alt="images" /></p>
<p class="noindent"><strong><em>Remember that <code>peek()</code> allows you to “peek” into the stream. It takes a <code>Consumer</code> and returns exactly the same stream as you call it on, so it makes no changes to anything. It’s simply a window to what’s flowing by on the stream.</em></strong></p>
<p class="indent"><strong><em>Run this and you’ll probably see</em></strong></p>
<p class="noindent1"><img src="images/un580-02.jpg" alt="images" /></p>
<p class="indent"><strong><em>So if you’re asked on the exam what output you’ll see with a <code>peek()</code>, make sure you understand how this works. You might be tempted to choose an answer that shows all the dogs printed with the peek and then <code>boi</code> for the final print, but that wouldn’t be correct.</em></strong></p>
</div>
<h4 class="h4" id="ch9lev2sec15">Sorting</h4>
<p class="noindent">We often want to sort things stored in data structures, so it makes sense we might want to sort elements flowing through a stream pipeline, too. The <code>Stream</code> interface includes a <code>sorted()</code> method that you can use to sort a stream of elements by natural order or by providing a <code>Comparator</code> to determine the order.</p>
<p class="indent"><span id="page_581" epub:type="pagebreak"></span>Sorting by natural order is easy: just add the <code>sorted()</code> operator into the stream pipeline, like this:</p>
<p class="imageip"><img src="images/un581-01.jpg" alt="images" /></p>
<p class="noindent">If you run this code, you’ll see the output:</p>
<p class="imageip"><img src="images/un581-02.jpg" alt="images" /></p>
<p class="indent">What if you want to sort more complex objects, like <code>Duck</code> objects? Here’s a <code>Duck</code>:</p>
<p class="imageip"><img src="images/un581-03.jpg" alt="images" /></p>
<p class="indent">We’ve gone ahead and made the <code>Duck</code> a <code>Comparable</code> and implemented the <code>compareTo()</code> method that sorts by name so we can sort these <code>Ducks</code>:</p>
<p class="imageip"><img src="images/un581-04.jpg" alt="images" /></p>
<p class="noindent"><span id="page_582" epub:type="pagebreak"></span>Run this code and you should see</p>
<p class="imageip"><img src="images/un582-01.jpg" alt="images" /></p>
<p class="noindent">The <code>compareTo()</code> method we provided in the <code>Duck</code> class sorts the ducks by their names.</p>
<p class="indent">What if you want to change the sort when you stream the ducks? You can use <code>sorted()</code> with a <code>Comparator</code>:</p>
<p class="imageip"><img src="images/un582-02.jpg" alt="images" /></p>
<p class="noindent">Here, you’re providing a <code>Comparator</code> to <code>sorted()</code> that it will use to sort the <code>Ducks</code> (instead of the <code>compareTo()</code> method in the <code>Duck</code> class). The result is</p>
<p class="imageip"><img src="images/un582-03.jpg" alt="images" /></p>
<p class="noindent">Now the ducks are sorted by age.</p>
<p class="indent">Comparators are handy because they can be defined separately from the class, like we did to sort the ducks by age rather than by name (which is the default sort order, defined by the <code>Comparable</code>).</p>
<p class="indent">Above, we passed the <code>Comparator</code> directly to the <code>sorted()</code> method using a lambda expression. If we wanted to, we could write out the <code>Comparator</code> separately, assign it to a variable, and then pass that variable to <code>sorted()</code>, like this:</p>
<p class="imageip"><img src="images/un582-04.jpg" alt="images" /></p>
<p class="indent">You’ve seen us use comparators like this before (in the previous chapter). <code>Comparator</code> also has some handy static methods that you’re likely to see when defining comparators for use with streams: <code>comparing()</code>, <code>reversed()</code>, and <code>thenComparing()</code>.</p>
<p class="indent">Let’s write three <code>Comparator</code>s to sort ducks by their <code>color</code>, by their <code>name</code>, and by their <code>age</code>, using the <code>Comparator.comparing()</code> method. The <code>comparing()</code> method takes a <code>Function</code> whose functional method expects a property to sort by, <span id="page_583" epub:type="pagebreak"></span>like <code>Duck.age</code>, as an argument and returns a <code>Comparator</code> that compares objects by that property.</p>
<p class="imageip"><img src="images/un583-01.jpg" alt="images" /></p>
<p class="indent">Here, we’re using a method reference to specify each <code>Function</code> that <code>comparing()</code> will use to get the properties of the <code>Duck</code> we want to compare by for each <code>Comparator</code>. Now that we have these comparators, we can use them to sort ducks in various combinations.</p>
<p class="indent">We can sort by age:</p>
<p class="imageip"><img src="images/un583-02.jpg" alt="images" /></p>
<p class="noindent">Or sort by age reversed:</p>
<p class="imageip"><img src="images/un583-03.jpg" alt="images" /></p>
<p class="noindent">Note that <code>reversed()</code> is a method of the <code>Comparator</code>, that returns a new <code>Comparator</code> that has the reverse ordering.</p>
<p class="indent">We can also sort by one property and then by another property, using the <code>thenComparing()</code> method. <code>thenComparing()</code> returns a <code>Comparator</code> that compares first by the <code>Comparator</code> you call it on and then by the <code>Comparator</code> you pass in. To sort by name, and then by age, we’ll write:</p>
<p class="imageip"><img src="images/un583-04.jpg" alt="images" /></p>
<p class="indent">Before we do that, let’s add a few more <code>Duck</code>s:</p>
<p class="imageip"><img src="images/un583-05.jpg" alt="images" /></p>
<p class="noindent">We have our original four ducks, as well as four new ducks with the same names but different colors and all much older. (Think of these as the “bizarro” ducks.)</p>
<p class="indent"><span id="page_584" epub:type="pagebreak"></span>Now let’s sort the ducks, first by name and then by age:</p>
<p class="imageip"><img src="images/un584-01.jpg" alt="images" /></p>
<p class="noindent">The result is:</p>
<p class="imageip"><img src="images/un584-02.jpg" alt="images" /></p>
<p class="indent">And, of course, we could sort by color and then by age:</p>
<p class="imageip"><img src="images/un584-03.jpg" alt="images" /></p>
<p class="noindent">Or a variety of other combinations.</p>
<p class="indent">Finally, another method of <code>Stream</code> that comes in handy when sorting streams is <code>distinct()</code>. This method returns a stream with distinct elements, so if an element is repeated in the stream, you’ll end up with only one of them.</p>
<p class="indent">Let’s say, for instance, that you want to see how many different colors your ducks are. You only need to see the color once, even if you have multiple ducks with the same color.</p>
<p class="indent">Here’s a revised List of Ducks:</p>
<p class="imageip"><img src="images/un584-04.jpg" alt="images" /></p>
<p class="noindent">You can see that we have 1 yellow, 2 brown, 2 mottled, and 2 white ducks.</p>
<p class="indent">To get the list of distinct colors of ducks, we’ll first map each <code>Duck</code> to its color, then use <code>distinct()</code> to make sure we get a stream of distinct color <code>String</code>s, and then print those:</p>
<p class="imageip"><img src="images/un584-05.jpg" alt="images" /></p>
<p class="noindent"><span id="page_585" epub:type="pagebreak"></span>And we see</p>
<p class="imageip"><img src="images/un585-01.jpg" alt="images" /></p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>We slipped some method references into this section: <code>Duck::getColor, Duck::getName, Duck::getAge,</code> and <code>System.out::println</code>. Recall from the previous chapter when we described how <code>System.out::println</code> is</em> a method reference: a <em>shorthand for a lambda expression. For example, we replaced a lambda expression like this:</em></strong></p>
<p class="noindent1"><img src="images/un585-02.jpg" alt="images" /></p>
<p class="noindent"><strong><em>with a method reference like this:</em></strong></p>
<p class="noindent1"><img src="images/un585-03.jpg" alt="images" /></p>
<p class="indent"><strong><em>Method references simply replace lambda expressions that do nothing except call another function. For this instance method reference, System.out is the class and <code>println</code> is the instance method. We use the <code>"::"</code> syntax to indicate the method reference.</em></strong></p>
<p class="indent"><strong>Take another look at <code>Duck::getColor, Duck::getName,</code> and <code>Duck::getAge.</code> These, too, are method references to instance methods. They are a type of method reference that refers to a nonstatic method of an instance of a type. If we wrote those method references out as lambda expressions, they’d look like this:</strong></p>
<p class="noindent1"><img src="images/un585-04.jpg" alt="images" /></p>
<p class="indent"><strong><em>So, for instance, the lambda <code>d -&gt; d.getColor()</code> is a <code>Function</code> whose functional method takes an object of type <code>Duck</code> and returns an object of type <code>String</code>, mapping a <code>Duck</code> to his or her color.</em></strong></p>
<p class="indent"><strong><em>The code</em></strong></p>
<p class="noindent1"><img src="images/un585-05.jpg" alt="images" /></p>
<p class="indent"><strong><em>uses an instance method reference to replace the lambda, where the instance we’re using is an instance of <code>Duck</code> and the method is <code>getColor()</code>. Remember, method references are shorthand for lambdas that just turn around and call another method.</em></strong></p>
</div>
<h4 class="h4" id="ch9lev2sec16"><span id="page_586" epub:type="pagebreak"></span>Methods to Search and Sort Streams</h4>
<p class="noindent">The searching and sorting methods on streams are straightforward; the main thing is to get the types correct! <a href="ch9.xhtml#ch9tab5">Table 9-5</a> details these methods.</p>
<p class="tabcap" id="ch9tab5"><span class="table"><strong>TABLE 9-5</strong></span> Searching and Sorting on Streams</p>
<p class="imaget"><img src="images/tab09-05-1.jpg" alt="Images" /></p>
<p class="imaget"><span id="page_587" epub:type="pagebreak"></span><img src="images/tab09-05-2.jpg" alt="Images" /></p>
<h4 class="h4" id="ch9lev2sec17"><span id="page_588" epub:type="pagebreak"></span>Don’t Modify the Source of a Stream</h4>
<p class="noindent">You might have heard that when you’re using Java streams, you are programming in a “functional” style. Aside from being a more declarative way of writing code (thus the stream pipeline versus several statements to specify operations), the key tenet of functional programming is to avoid <em>side effects</em>—that is, changing state stored in variables and fields—during computation. Instead, you process data using operations that produce new values (rather than changing old ones). Functional programming style makes it easier to prove the correctness of your program and to replicate results, and avoiding state changes makes it easier to implement optimizations in the compiled code. Although Java is far from being a functional programming language, streams are a step toward a functional style of programming that encourages this idea of avoiding state changes on the original data structure being processed via a stream.</p>
<p class="indent">At this point in the chapter, we’re going to share something really important about streams. That is, you should never, ever try to modify the source of a stream from within the stream pipeline.</p>
<p class="indent">You might be tempted at times, but don’t. It just isn’t done. Java won’t give you a compile-time error if you try and may not even give you a runtime error, although your results will not be guaranteed. But just don’t do it. Ever.</p>
<p class="indent">One reason you might be tempted, say, is if you’re looking for elements that pass a test and you want to modify that element in the source, or perhaps even delete that element from the source. For example, you might want to remove all dogs who weigh less than 50 pounds from the list of dogs:</p>
<p class="imageip"><img src="images/un588-01.jpg" alt="images" /></p>
<p class="indent">You might <em>think</em> that you’ll see a list of the dogs whose weights are greater than or equal to 50, and you might <em>think</em> the <code>dog</code>s list will now contain only dogs whose weights are greater than or equal to 50, but what you’ll probably get instead is something like this:</p>
<p class="imageip"><img src="images/un588-02.jpg" alt="images" /></p>
<p class="indent">So what do you do if you want to get a list of all dogs whose weight is greater than or equal to 50 after you’ve done the stream computation?</p>
<p class="indent"><span id="page_589" epub:type="pagebreak"></span>The best way to do this is to collect the dogs at the end of the stream pipeline into a new collection. And, of course, Java provides an easy way for you to do just that with the <code>Stream.collect()</code> method.</p>
<p class="indent">Let’s collect all dogs who weigh 50 pounds or more. Remember, here are our dogs:</p>
<p class="imageip"><img src="images/un589-01.jpg" alt="images" /></p>
<p class="noindent">Looking at that list, we’d expect to end up with two dogs: Aiko who weighs 50 pounds and Charis who weighs 120 pounds (that’s a big dog!).</p>
<p class="indent">Here’s how we can use a stream pipeline to filter all dogs who weigh 50 pounds or more and collect them into a new <code>List</code>, <code>heavyDogs</code>:</p>
<p class="imageip"><img src="images/un589-02.jpg" alt="images" /></p>
<p class="noindent">We can then print this list:</p>
<p class="imageip"><img src="images/un589-03.jpg" alt="images" /></p>
<p class="noindent">And see the output:</p>
<p class="imageip"><img src="images/un589-04.jpg" alt="images" /></p>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch9lev1sec8"><strong>Collecting Values from Streams (OCP Objectives 3.8, 5.6, and 9.3)</strong></h3>
<p class="noindent"><em>3.8   Use method references with Streams.</em></p>
<p class="noindent"><em>5.6   ave results to a collection using the collect method and group/partition data using the Collectors class.</em></p>
<p class="noindent"><em>9.3   Use Stream API with NIO.2.</em></p>
<p class="indentt">The <code>collect()</code> method is a reduction operation: it reduces a stream into a collection of objects or a value. The <code>Collector</code> you pass to the method specifies <span id="page_590" epub:type="pagebreak"></span>how to reduce the stream, say, into a <code>List</code> or a <code>Set</code>. The <code>Collectors</code> class provides implementations of <code>Collector</code> that each determine how you collect, everything from methods to make a simple list, like <code>toList()</code>, to methods that allow you to group items in your <code>Collection</code>, resulting in a map so values are organized by a key value.</p>
<p class="indent">As you collect, you can</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Group values together based on a <code>Function</code> (returns a <code>Map</code>)</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Partition values into true/false partitions based on a <code>Predicate</code> (returns a <code>Map</code>)</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Map values into other values using a <code>Function</code> (returns a <code>Collector</code>)</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Join values into a <code>String</code></p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   Count values as you collect</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>Note that <code>Collectors</code> (with an s) is a helper class that contains implementations of the <code>Collector</code> interface. Don’t get the two mixed up! This is similar to <code>Collections/Collection</code>.</em></strong></p>
</div>
<p class="indent">Let’s make a <code>Person</code> class and a nice collection of people with names and ages, so we have some data to work with. Then we’ll stream the <code>Collection</code> of people and use the various <code>Collector</code>s to process the data in a few different ways.</p>
<p class="indent">Here’s the <code>Person</code> class:</p>
<p class="imageip"><img src="images/un590-01.jpg" alt="images" /></p>
<p class="noindent">Now, we’ll make a bunch of <code>Person</code>s and add them to a <code>List</code>:</p>
<p class="imageip"><img src="images/un590-02.jpg" alt="images" /></p>
<p class="imageip"><span id="page_591" epub:type="pagebreak"></span><img src="images/un591-01.jpg" alt="images" /></p>
<p class="indent">Now that we have a great collection of people with names and ages, we can stream people and use <code>Collector</code>s to organize and process our collection. Let’s begin with the simplest way to collect people: we’ll collect everyone whose age is 34 into a <code>List</code>:</p>
<p class="imageip"><img src="images/un591-02.jpg" alt="images" /></p>
<p class="noindent">Here, we’re streaming the <code>List</code> of <code>Person</code>s, using <code>filter()</code> with a <code>Predicate</code> to test to see whether the <code>Person</code>’s age is 34, and collecting those <code>Person</code>s who pass that test into a new <code>List</code>.</p>
<p class="indent">When we print that <code>List</code>, we see</p>
<p class="imageip"><img src="images/un591-03.jpg" alt="images" /></p>
<p class="indent">There’s no guarantee what kind of <code>List</code> you get using <code>Collectors.toList()</code>. If you specifically want an <code>ArrayList</code>, you can use the <code>toCollection()</code> method instead, like this:</p>
<p class="imageip"><img src="images/un591-04.jpg" alt="images" /></p>
<p class="noindent">And get the same output.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><span id="page_592" epub:type="pagebreak"></span><strong><em>Notice here that we’re passing a method reference to the <code>Collectors. toCollection()</code> method. Looking at the documentation for <code>Collectors.toCollection()</code>, we see that this method takes a <code>Supplier</code> whose functional method must return a new empty <code>Collection</code> of the “appropriate type.” We could write the code like this:</em></strong></p>
<p class="noindent1"><img src="images/un592-01.jpg" alt="images" /></p>
<p class="noindent"><strong><em>providing the <code>Supplier () -&gt; new ArrayList&lt;Dog&gt;()</code> as the argument to <code>Collectors.toCollection()</code>. Recall that a method reference is shorthand for a lambda expression that just turns around and calls another method. So by writing <code>ArrayList::new</code> instead of the lambda, we are saying the same thing as the lambda expression above: that is, just call the constructor (with new) of an <code>ArrayList&lt;Dog&gt;</code> to create a new <code>ArrayList</code>. This is a slightly different kind of method reference than you saw earlier in this chapter, when we used instance method references to refer to instance methods, like a <code>Duck</code>’s <code>getColor()</code> method with <code>Duck::getColor</code>. This form of method reference is the</em> constructor method reference, <em>and it’s just a shorthand for a lambda that creates a new instance of a class.</em></strong></p>
</div>
<h4 class="h4" id="ch9lev2sec18">Using collect() with Files.lines()</h4>
<p class="noindent">Think back to how we handled getting DVDs from a file using <code>Files.lines()</code> earlier (in the section “Create a Stream from a File“). In that example, we streamed <code>String</code> data about DVDs from the file and added DVDs one at a time to a <code>List</code> in a <code>forEach()</code> consumer:</p>
<p class="imageip"><img src="images/un592-02.jpg" alt="images" /></p>
<p class="indent">Now that you know how to use <code>collect()</code>, you can probably think of a better way to do this, right? While the solution above works, it’s not the recommended way to collect items from a stream into a <code>List</code> because you are modifying an object <span id="page_593" epub:type="pagebreak"></span>that’s defined outside the stream pipeline—in other words, your stream pipeline has a <em>side effect</em>. Using <code>collect()</code> is the preferred way to do this, and, as you’ll see, along with avoiding an unnecessary side effect, it also makes your code clearer.</p>
<p class="indent">Here’s another quick example of using <code>Files.lines()</code> to stream data from a file, and this time we’ll add that data to a <code>List</code> using <code>collect()</code>. Imagine we have a file, “names.txt,” with the following names in it:</p>
<p class="imageip"><img src="images/un593-01.jpg" alt="images" /></p>
<p class="noindent">Using <code>collect()</code>, we can easily add these names to a <code>List</code>, like this:</p>
<p class="imageip"><img src="images/un593-02.jpg" alt="images" /></p>
<p class="head-h" id="ch9exe1"><span class="white1">EXERCISE 9-1</span></p>
<p class="border"></p>
<h4 class="h4"><strong>Collecting Items in a List</strong></h4>
<p class="noindent">Try rewriting the earlier DVDs example to use <code>collect()</code> instead of adding DVDs manually to the <code>dvds List</code> in the <code>forEach()</code> loop. Just as with the simple names example, you can use <code>Collectors.toList()</code> to add DVDs to the <code>dvds List</code>. Here’s a hint: you’ll need to map the lines (<code>String</code>s) you’re streaming from the “dvdinfo.txt” file to <code>DVDInfo</code> objects before you collect them.</p>
<p class="indentb">Using <code>collect()</code> is a much better, and preferred way, to collect streamed items into a <code>List</code>.</p>
<p class="hr"></p>
<h4 class="h4" id="ch9lev2sec19">Grouping and Partitioning</h4>
<p class="noindent">Now what if we want to group people by age? We can use the <code>Collectors.groupingBy()</code> method. We specify <em>how</em> to group <code>Person</code> objects by passing a <code>Function</code> to the <code>groupingBy()</code> method, which returns a <code>Collector</code> that will <span id="page_594" epub:type="pagebreak"></span>collect data elements from the stream and group them in a <code>Map</code> by a key, according to that <code>Function</code>.</p>
<p class="indent">You can think of the <code>Function</code> as a “classification function.” If we want to group people by age, then we need to pass a <code>Function</code> to <code>groupingBy()</code> that maps a <code>Person</code> to their age:</p>
<p class="imageip"><img src="images/un594-01.jpg" alt="images" /></p>
<p class="noindent">When we print the resulting <code>Map</code>, we see</p>
<p class="imageip"><img src="images/un594-02.jpg" alt="images" /></p>
<p class="indent">Notice that the <code>Map</code> you get back uses an age (<code>Integer</code>) as a key and the value is a <code>List</code> of the same type of object in the stream; in this case, that’s <code>Person</code>. Also notice that the way <code>System.out.println()</code> shows us a <code>Person</code> in the output is by using the <code>toString()</code> method, but the values in the <code>List</code> associated with each are not <code>String</code>s; they are <code>Person</code>s (you can see from the type parameter on <code>List&lt;Person&gt;</code> that that is the case).</p>
<p class="indent">So now we have a map with <code>Integer</code>s (ages) for keys and <code>List&lt;Person&gt;</code>s for values, and we can see that, for instance, Bert is 32 and Wendi and Bill are 34, and so on.</p>
<p class="indent">The <code>groupingBy()</code> method is heavily overloaded with a variety of options for grouping values in a <code>Collection</code>. For instance, you can use a version of <code>groupingBy()</code> that takes a classification <code>Function</code> as a first argument and a <code>Collector</code> as a second argument. That <code>Collector</code> argument allows you to reduce the values of the <code>Map</code> you get as the result of the <code>groupingBy()</code> method, thus reducing each value <code>List</code> into another value. Yeah, we know, that’s tricky to understand, so let’s look at an example.</p>
<p class="indent">Here, we’re going to group people by age, but rather than create a <code>List</code> of the people associated with a certain age in a <code>Map</code>, as we did above, now we’re going to count the number of people in the <code>List</code> associated with a given age and use that value in the resulting <code>Map</code> instead. So we have two reductions going on here: we have a <code>groupingBy()</code> reduction to group people by age and then we have <span id="page_595" epub:type="pagebreak"></span>a <code>counting()</code> reduction to count the people in the <code>List</code> associated with a particular age:</p>
<p class="imageip"><img src="images/un595-01.jpg" alt="images" /></p>
<p class="noindent">The result of this code is</p>
<p class="imageip"><img src="images/un595-02.jpg" alt="images" /></p>
<p class="indent">So now we can see we have 2 people who are 30, 2 people who are 34, 2 people who are 31, and 1 of each other age. To count the people in each list, we use the <code>Collectors.counting()</code> method, which returns a <code>Collector</code> that simply counts the number of input elements. The result of calling <code>collect()</code> on this <code>Collector</code> is a <code>Map</code> from ages to the number of people of a given age.</p>
<p class="indent">What if we want to group people by age, but list only their name rather than the entire <code>Person</code> object in the <code>Map</code>? That is, we want a map of ages and names (<code>Map&lt;Integer, List&lt;String&gt;&gt;)</code> rather than a map of ages and <code>Person</code> objects (<code>Map&lt;Integer, List&lt;Person&gt;&gt;</code>)?</p>
<p class="indent">We can do that by passing a <code>Collectors.mapping() Collector</code> as that second argument to <code>groupingBy()</code>:</p>
<p class="imageip"><img src="images/un595-03.jpg" alt="images" /></p>
<p class="indent">Here, we’re streaming the people and calling the <code>collect()</code> method on the stream, passing in the <code>groupingBy</code> collector. This <code>groupingBy()</code> collector takes two arguments, the <code>Function</code> that determines how we’re going to group (by <code>age</code>) and another <code>Collector</code> that tells us how to reduce the values in the <code>Map</code> associated with each age. Remember that for the simplest version <span id="page_596" epub:type="pagebreak"></span>of <code>groupingBy()</code>, each value is just a <code>List</code> of <code>Person</code>s who are that age. But now we’re using the <code>mapping()</code> collector to further reduce or modify that <code>List</code> of <code>Persons</code>.</p>
<p class="indent">The <code>mapping()</code> method maps each <code>Person</code> to another value. What we’d like to do is map a <code>Person</code> to their name. Taking a look at the <code>mapping()</code> method, we see that its first argument is a <code>Function</code> whose functional method takes an object of the type we’re mapping from (a <code>Person</code>) and returns another object, in this case, the <code>Person</code>’s name, a <code>String</code>. The second argument to <code>mapping()</code> is a collector that tells us what to do with the potentially multiple values we’re mapping. Remember that we can have multiple people of the same age, so we’re mapping a <code>List</code> of <code>Person</code>s to a <code>List</code> of their names. That second argument specifies how we’d like to collect those names. We’ll use <code>toList()</code> to keep it easy, but you could also choose <code>toCollection()</code> to create an <code>ArrayList</code> or some other collection for the names.</p>
<p class="indent">The output we see is</p>
<p class="imageip"><img src="images/un596-01.jpg" alt="images" /></p>
<p class="noindent">So now our <code>Map</code> maps age keys to <code>List</code>s of <code>String</code> names.</p>
<p class="indent">Partitioning as you collect is essentially a more specialized kind of <code>groupingBy()</code>. The <code>partioningBy()</code> method organizes the results into a <code>Map</code> like <code>groupingBy()</code> does, but <code>partioningBy()</code> takes a <code>Predicate</code> rather than a <code>Function</code>, so the results are split into two groups (partitions) based on whether the items in the stream pass the test in the <code>Predicate</code>. Let’s partition our results by the test: is the person older than 34?</p>
<p class="imageip"><img src="images/un596-02.jpg" alt="images" /></p>
<p class="indent">As you might expect, the result is a <code>Map</code> that maps <code>boolean</code>s to <code>Person</code>s, so all people 34 or younger will be mapped to the key <code>false</code>, and all people older than 34 will be mapped to the key <code>true</code>:</p>
<p class="imageip"><img src="images/un596-03.jpg" alt="images" /></p>
<p class="indent">Perhaps you can see how powerful streams and collectors are together? Although this code may not feel intuitive to you, it certainly is more concise than writing the equivalent code without using streams to create these <code>Map</code>s, and you avoid having to create some intermediate data structures yourself. The whole idea is that Java <span id="page_597" epub:type="pagebreak"></span>can optimize the code used to create the resulting <code>Map</code>s behind the scenes so these types of operations become a lot more efficient.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>We slipped another example of an instance method reference by you in this section: <code>Person::getAge</code>. We did this to group people by age. <code>groupingBy()</code> takes a <code>Function</code> that maps a Person object to another value to use that value as the mapping key—in this case, telling <code>groupingBy()</code> to map people by age.</em></strong></p>
<p class="indent"><strong><em>The method reference <code>Person::getAge</code> is an instance method reference that refers to a nonstatic method of an instance of a <code>Person</code>. If we wrote that method reference out as a lambda expression, it would look like this:</em></strong></p>
<p class="noindent1"><img src="images/un597-01.jpg" alt="images" /></p>
<p class="noindent"><strong><em>So this lambda is a <code>Function</code> whose functional method takes an object of type <code>Person</code> and returns an object of type <code>Integer</code>, mapping a Person to their age.</em></strong></p>
</div>
<h4 class="h4" id="ch9lev2sec20">Summing and Averaging</h4>
<p class="noindent">A couple of other useful collectors are <code>summingInt()</code> and <code>averagingInt()</code> (and their long and double counterparts). As you might guess, these need to work on numbers, so both take a <code>ToIntFunction</code> (that is a <code>Function</code> that maps an object to an <code>int</code>). To experiment with these, we’ll need to add a few more people to our list of people. We’re going to add people with the same names so we can group by name and then find the sum of ages and the average of ages. You’ll see what we mean in just a moment. Let’s first add three more people to our list:</p>
<p class="imageip"><img src="images/un597-02.jpg" alt="images" /></p>
<p class="indent">Now we have two people named “Bert” in our list; the first Bert (from way back) is age 32, and the second Bert (bert2) is age 38. Likewise, for “Beth” and “Bill,” we now have two people with the name “Beth” and two people with the name “Bill,” each of different ages.</p>
<p class="indent">First, we want to sum the ages of the two Berts, the two Beths, and the two Bills, and group by name. Perhaps we’re computing person-years of life experience of all people whose names begin with “B.” (This scenario is completely contrived, of course, but if you were counting occurrences of Scrabble words, then this would make a lot more sense.)</p>
<p class="indent"><span id="page_598" epub:type="pagebreak"></span>Here’s how we get the sum of the ages of people whose names begin with “B” and group by name:</p>
<p class="imageip"><img src="images/un598-01.jpg" alt="images" /></p>
<p class="noindent">The output of this code is</p>
<p class="imageip"><img src="images/un598-02.jpg" alt="images" /></p>
<p class="indent">The code took the ages of the two Bills and added them together. It does the same thing with the two Beths and the two Berts, and groups the results by name in a <code>Map</code>. So the total age of all the Bills is 74, all the Beths is 75, and all the Berts is 70.</p>
<p class="indent">What about the average age of the people whose names begin with “B”? Yep, that’s what <code>averagingInt()</code> is for:</p>
<p class="imageip"><img src="images/un598-03.jpg" alt="images" /></p>
<p class="noindent">This code produces the output:</p>
<p class="imageip"><img src="images/un598-04.jpg" alt="images" /></p>
<p class="indent">Now, we’ve computed the average age of all the Bills, the average age of all the Beths, and the average age of all the Berts, grouped them by name, and collected the results in a <code>Map</code>.</p>
<p class="indent">It’s important to note here that the <code>averagingInt() Collector</code> reduces the ages to a <code>Double</code>, so the type signature on this <code>Map</code> is <code>Map&lt;String, Double&gt;</code> <span id="page_599" epub:type="pagebreak"></span>(compare with the type signature on the result of the <code>summingInt() Collector</code> example, which is <code>Map&lt;String, Integer&gt;</code>).</p>
<p class="indent">In both these examples, we are first collecting <code>Person</code> objects, grouping people by name, and then doing a second reduction on the <code>Person</code> objects that are the values of the first (implicit) <code>Map</code> created by the grouping. In the case of <code>summingInt()</code>, we are reducing with a <code>Collector</code> that sums the ages of all the <code>Person</code> objects associated with a given name; in the case of <code>averagingInt()</code>, we are reducing with a <code>Collector</code> that averages the ages of all the <code>Person</code> objects associated with a given name. Sometimes these second reductions on the value portions of the first reduction are called “downstream processing” because they work on the results of the first reduction on a stream.</p>
<h4 class="h4" id="ch9lev2sec21">Counting, joining, maxBy, and minBy</h4>
<p class="noindent">So far we’ve looked at collectors that, when used with the <code>collect()</code> method, reduce a stream to a <code>Collection</code> type, like a <code>List</code> or a <code>Map</code>. There are a few other collectors that work with <code>collect()</code> to reduce a stream to a single value, such as a <code>String</code>, instead.</p>
<p class="indent">We used the <code>Collectors.counting()</code> method above to create a <code>Collector</code> that counts elements being collected. A simple example of using <code>counting()</code> is</p>
<p class="imageip"><img src="images/un599-01.jpg" alt="images" /></p>
<p class="indent">This simply counts the items in the people stream. You already know how to do this with the <code>Stream</code> method <code>count()</code>, and there’s no reason to create a <code>Collector</code> here to count elements in a stream, so we provide this example just to show how it works at the most basic level. More typically, you’ll find <code>Collectors.counting()</code> used like we did above, as part of a <code>groupingBy()</code> operation.</p>
<p class="indent">The <code>Collectors.joining()</code> method returns a <code>Collector</code> that takes stream elements and concatenates them into a <code>String</code> by order in which they are encountered (which may or may not be the order of the original <code>Collection</code> you’re streaming!).</p>
<p class="indent">For instance, we can get the name of every <code>Person</code> who’s older than 34 and join those names together into one <code>String</code> like this:</p>
<p class="imageip"><img src="images/un599-02.jpg" alt="images" /></p>
<p class="indent"><span id="page_600" epub:type="pagebreak"></span>Here, we’re streaming the people <code>List</code> (the original list, without the duplicate names), filtering to get only people older than 34, mapping those people to their names (so at that point in the pipeline, we have a stream of <code>String</code> names), and then collecting those names into one <code>String</code>, with each name separated by a comma:</p>
<p class="imageip"><img src="images/un600-01.jpg" alt="images" /></p>
<p class="indent">The <code>joining()</code> method requires as input an object that implements the <code>CharSequence</code> interface and includes <code>String</code>, which is what we’re using here.</p>
<p class="indent">The methods <code>maxBy()</code> and <code>minBy()</code> do what you expect: they collect (reduce) to the max and min of the input elements, respectively. Let’s use <code>maxBy()</code> to find the oldest person in the <code>people</code> stream:</p>
<p class="imageip"><img src="images/un600-02.jpg" alt="images" /></p>
<p class="indent">The <code>maxBy()</code> method takes a <code>Comparator</code> (as does <code>minBy()</code>) to compare the elements from the stream as they are being collected and returns a <code>Collector</code> that, when used with the <code>Stream.collect()</code> method, will reduce the stream to the “max” of the elements in the stream as measured by that <code>Comparator</code>.</p>
<p class="indent">Notice that <code>maxBy()</code> returns an <code>Optional&lt;Person&gt;</code>, not a <code>Person</code>, because when finding the max as you are collecting a stream, if that stream is empty, there will be no value. So we use the <code>ifPresent()</code> method of the <code>Optional</code> to make sure there is a value there before we try to print it out.</p>
<p class="indent">The advantage to finding the max of our <code>Person</code> stream using <code>collect()</code> with the <code>maxBy()</code> collector, rather than just using the <code>max()</code> terminal operation on the stream, like this:</p>
<p class="imageip"><img src="images/un600-03.jpg" alt="images" /></p>
<p class="noindent">is that our result is a <code>Person</code> object. Remember, <code>IntStream.max()</code> works only on numbers, so we when we mapped our <code>Person</code> stream to a stream of <code>Integer</code>s in order to use <code>max()</code> to find the oldest person, we got a number back. By using <code>maxBy()</code> with <code>collect()</code>, we can find the <code>Person</code> object who has the highest age and get the whole <code>Person</code> back, not just their age. (We could also use the <code>Stream.max()</code> method and provide a comparator to do essentially the same thing.)</p>
<h4 class="h4" id="ch9lev2sec22">Stream Methods to Collect and Their Collectors</h4>
<p class="noindent">Using streams with collectors can get fairly complex, especially when you have multiple downstream operations. On the exam, you’ll likely see only one or two levels of nesting when using collectors (e.g., a <code>groupingBy()</code> used with a <span id="page_601" epub:type="pagebreak"></span><code>mapping()</code>) but be sure to get lots of practice using the <code>Stream collect()</code> method with collectors of various kinds.</p>
<p class="tabcap" id="ch9tab6"><span class="table"><strong>TABLE 9-6</strong></span> Using Streams with Collectors</p>
<p class="imaget"><img src="images/tab09-06.jpg" alt="Images" /></p>
<p class="indent"><a href="ch9.xhtml#ch9tab6">Table 9-6</a> shows the variations on the <code>collect()</code> method. In this section we used only the first variation—the simplest method that takes a <code>Collector</code> created with one of the <code>Collectors</code> methods [e.g., <code>toList()</code>]—but be aware of the other variation where you need to supply supplier, accumulator, and combiner arguments to specify how the <code>collect()</code> method reduces elements in case it shows up on the exam. Most of the time, you’ll typically use a <code>Collectors</code> method to create a <code>Collector</code> (which you can think of as an abstraction hiding the details <span id="page_602" epub:type="pagebreak"></span>of a supplier, accumulator, and combiner that actually determine how the collect reduction is done) and use that with <code>collect()</code>, as we did in this section.</p>
<p class="indent"><a href="ch9.xhtml#ch9tab7">Table 9-7</a> shows some of the <code>Collectors</code> methods you can use to create <code>Collector</code>s to collect elements; for more options and variations (which will likely not be on the exam), check out the <code>Collectors</code> class in the documentation. Remember that all the methods in the <code>Collectors</code> class are static methods that each produce a <code>Collector</code>—and don’t get those two types mixed up!</p>
<p class="tabcap" id="ch9tab7"><span class="table"><strong>TABLE 9-7</strong></span> Collectors Methods</p>
<p class="imaget"><img src="images/tab09-07-1.jpg" alt="Images" /></p>
<p class="imaget"><span id="page_603" epub:type="pagebreak"></span><img src="images/tab09-07-2.jpg" alt="Images" /></p>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch9lev1sec9"><strong>Streams of Streams (OCP Objective 5.7)</strong></h3>
<p class="noindent"><em>5.7   Use flatMap() methods in the Stream API.</em></p>
<p class="indentt">Imagine you have a file containing space-separated words in multiple lines. Something like this:</p>
<p class="imageip"><img src="images/un603-01.jpg" alt="images" /></p>
<p class="noindent"><span id="page_604" epub:type="pagebreak"></span>You want to read the file and determine how many times the word “Java” appears in the file.</p>
<p class="indent">You already know you can create a stream from a file, so you do that to get started:</p>
<p class="imageip"><img src="images/un604-01.jpg" alt="images" /></p>
<p class="noindent">So far so good.</p>
<p class="indent">Now, you know the input stream is going to stream one line at a time from the file “java.txt,” and so to get words, rather than lines, you can split each line, like this:</p>
<p class="imageip"><img src="images/un604-02.jpg" alt="images" /></p>
<p class="indent">What does this produce? You know the <code>split()</code> method on <code>String</code> creates an array of <code>String</code>s, and you know <code>map()</code> produces a stream, so what this line of code does is take the stream of lines coming from the file, splits each line into a <code>String[]</code>, and generates a <code>Stream</code> of <code>String</code> arrays, which we write as <code>Stream&lt;String[]&gt;</code>:</p>
<p class="imageip"><img src="images/un604-03.jpg" alt="images" /></p>
<p class="indent">So what do we do with a stream of <code>String</code> arrays? What we want is the individual strings in each array, so we can filter the words that are equal to “Java” and count them to see how many times “Java” appears in the file. So how do we turn the <code>Stream&lt;String[]&gt;</code> into a stream of <code>String</code>s?</p>
<p class="indent">What if we stream each of the arrays in the stream? We know we can create a stream from an array with <code>Arrays.stream()</code> and that <code>inputStream</code> is a stream of <code>String</code> arrays. What about mapping each array to a stream, so each array becomes a stream of strings, and then process that? Let’s try:</p>
<p class="imageip"><img src="images/un604-04.jpg" alt="images" /></p>
<p class="noindent">This is what you’ll see:</p>
<p class="imageip"><img src="images/un604-05.jpg" alt="images" /></p>
<p class="noindent">Hmm, something’s not quite right… We expected each word from the file to print, but instead we see what looks like streams. Why?</p>
<p class="indent">Well, what we’re creating with</p>
<p class="imageip"><img src="images/un604-06.jpg" alt="images" /></p>
<p class="noindent"><span id="page_605" epub:type="pagebreak"></span>is actually a stream of streams:</p>
<p class="imageip"><img src="images/un605-01.jpg" alt="images" /></p>
<p class="noindent">So when we try to print this out:</p>
<p class="imageip"><img src="images/un605-02.jpg" alt="images" /></p>
<p class="noindent">each item we see displayed is a <code>Stream&lt;String&gt;</code>, rather than a <code>String</code>. When we streamed each array of <code>String</code>s created by the split, each of those streams becomes an element in the main stream that is streaming the arrays. Thus, a stream of streams.</p>
<p class="indent">What can we do with a stream of streams? Well, it turns out there’s a method just for this situation in the Stream API: <code>flatMap()</code>.</p>
<p class="indent">The <code>flatMap()</code> method is similar to <code>map()</code> in that it maps a stream of one type into a stream of another type, but it does something extra; <code>flatMap()</code> “flattens” out the streams, essentially concatenating them into one stream. It replaces each stream with its contents, creating one stream from many.</p>
<p class="indent">So instead of mapping each array to a stream, we’re going to <em>flat map</em> each array to a stream. The stream that results from the <code>flatMap()</code> is one big flat stream, rather than a stream of streams. That’s really hard to see without an example, so let’s give this a try:</p>
<p class="imageip"><img src="images/un605-03.jpg" alt="images" /></p>
<p class="indent">Think of taking a two-dimensional array and flattening it to a one-dimensional array, like this:</p>
<p class="imageip"><img src="images/un605-04.jpg" alt="images" /></p>
<p class="noindent">That’s what <code>flatMap()</code> does with streams. The result of using <code>flatMap()</code> on the stream of arrays is a flat stream of all the contents of each array, which is the words in the file.</p>
<p class="indent">If you run that code, you’ll see all the words in the file:</p>
<p class="imageip"><img src="images/un605-05.jpg" alt="images" /></p>
<p class="indent"><span id="page_606" epub:type="pagebreak"></span>Great! We’ve made progress. Our goal is count the number of words equal to “Java.” Hopefully that task is easier now; you just need to <code>filter()</code> and <code>count()</code>.</p>
<p class="indent">Here’s the whole code so you can run it yourself:</p>
<p class="imageip"><img src="images/un606-01.jpg" alt="images" /></p>
<p class="noindent">Run that and you should see that “Java” appears in the file eight times.</p>
<p class="indent">The <code>Stream</code> interface also includes <code>flatMapToDouble()</code>, <code>flatMapToInt()</code>, and <code>flatMapToLong()</code>, to flat map to a <code>DoubleStream</code>, an <code>IntStream</code>, and a <code>LongStream</code>, respectively, in case you need that. Each of the primitive stream types just mentioned also include their own <code>flatMap()</code> methods that take a <code>DoubleFunction</code>, an <code>IntFunction</code>, and a <code>LongFunction</code>, respectively.</p>
<p class="indent">What do you think? The final code is actually pretty concise, and it’s fairly easy to process the data in the file. It’s certainly a different way of thinking about processing data. Do you find the code easier or more difficult to read? It definitely takes some getting used to.</p>
<p class="indent">Keeping track of your streams—e.g., What is the type of your stream? Is it a stream of <code>String</code>s or a stream of streams?—can get a bit tricky at times. Paying attention to exactly what each method produces so you know what type you’re dealing with is important in all aspects of working with streams, as we hope you’ve discovered in this chapter.</p>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch9lev1sec10"><strong>Generating Streams (OCP Objective 3.4)</strong></h3>
<p class="noindent"><em>3.4   Collections, Streams, and Filters.</em></p>
<p class="indentt">What do you think will happen if you run the following code:</p>
<p class="imageip"><img src="images/un606-02.jpg" alt="images" /></p>
<p class="noindent"><span id="page_607" epub:type="pagebreak"></span>Looking at the documentation for <code>Stream.iterate()</code>, it says <code>iterate()</code> returns an “infinite sequential order Stream.” Oh my, did you get yourself an infinite loop here?</p>
<p class="indent">Actually no, you didn’t. Remember that streams are lazy. <code>Stream.iterate()</code> returns a stream, and you know that nothing starts to happen until you tack a terminal operation, like <code>count()</code> or <code>forEach()</code> or <code>collect()</code>, onto the stream pipeline.</p>
<p class="indent">The <code>iterate()</code> operation creates an infinite sequential <code>Stream</code>, starting with the first argument (known as the “seed“) followed by elements created by the <code>UnaryOperator</code> that you supply as the second argument. In our example above, the stream will generate whole numbers starting at 0, adding 1 to the seed first and then each subsequent number, forever.</p>
<p class="indent">Okay, so here’s code you probably shouldn’t try (okay, <em>definitely</em> shouldn’t try):</p>
<p class="imageip"><img src="images/un607-01.jpg" alt="images" /></p>
<p class="indent">Here, the <code>forEach()</code> terminal operation will never end because the stream is infinite. Because <code>iterate()</code> creates an infinite stream, we need some way to limit how much we get from the stream so we don’t get ourselves in trouble. We can do that with the <code>limit()</code> operation:</p>
<p class="imageip"><img src="images/un607-02.jpg" alt="images" /></p>
<p class="indent">Now it’s safe to run this code, because we are limiting the stream to 4 numbers, starting with 0, so we see the output:</p>
<p class="imageip"><img src="images/un607-03.jpg" alt="images" /></p>
<p class="indent">To work safely with infinite streams, you need a short-circuiting operation. That could be <code>limit()</code>, like we used above, or it can also be an operation like <code>findFirst()</code>, <code>findAny()</code>, or <code>anyMatch()</code>.</p>
<p class="indent">Let’s say you’ve got a sensor that generates an infinite stream of data. We won’t actually build one of those, but we’ll simulate one, like this:</p>
<p class="imageip"><img src="images/un607-04.jpg" alt="images" /></p>
<p class="imageip"><span id="page_608" epub:type="pagebreak"></span><img src="images/un608-01.jpg" alt="images" /></p>
<p class="indent">This sensor has a <code>next()</code> method that returns the status of the sensor. We return “up” values for the status until <code>i</code> is 10 and return “down” when <code>i</code> &gt; 10. The value <code>i</code> is incremented each time we call <code>next()</code>, so the first 10 results will be “up” and all subsequent results will be “down.” In a real sensor, we’d get data from the sensor and keep returning the latest status (use your imagination).</p>
<p class="indent">Now let’s use this sensor with an infinite stream. For this example, we’ll use the <code>Stream</code> method <code>generate()</code>, which takes a <code>Supplier</code>. The <code>generate()</code> method generates an infinite stream from elements supplied by the <code>Supplier</code>. Our <code>Supplier</code> is going to get values from the sensor to stream:</p>
<p class="imageip"><img src="images/un608-02.jpg" alt="images" /></p>
<p class="noindent">So <code>sensorStream</code> is an infinite stream of values we get by calling the sensor’s <code>next()</code> method. That infinite stream contains 10 “up” elements and a potentially infinite number of “down” elements.</p>
<p class="indent">Now we can write code to look for the first “down” value in the infinite stream, like this:</p>
<p class="imageip"><img src="images/un608-03.jpg" alt="images" /></p>
<p class="indent">The <code>findFirst()</code> method is a short-circuiting method, so as soon as we find a “down” value in the stream, everything stops. Whew! We averted another infinity problem. Of course, that assumes there is a “down” value somewhere in the stream; if there’s not, then the stream will keep generating values and <code>findFirst()</code> will never complete.</p>
<p class="indent">Infinite streams are handy when you’re dealing with a source of potentially infinite data, like a sensor. In practice, because we’d actually like to do something with the data we get from a sensor, we need to process the data into chunks, defined perhaps by a timestamp or by the number of results so far or by a particular value that indicates a change. Use caution when dealing with infinite streams because you need a way to specify a stopping point with a short-circuiting operation in order to perform the reduction and get a result.</p>
<p class="indent"><span id="page_609" epub:type="pagebreak"></span>Although <code>Stream.iterate()</code> is a good way to generate numbers up to a certain point, another way you can generate numbers is with <code>range()</code>. In practice, this might actually be more useful. This is a method on the primitive streams <code>IntStream</code> and <code>LongStream</code>:</p>
<p class="imageip"><img src="images/un609-01.jpg" alt="images" /></p>
<p class="noindent">This produces the output:</p>
<p class="imageip"><img src="images/un609-02.jpg" alt="images" /></p>
<p class="indent">If you want a stream of numbers inclusive of the second argument, use <code>rangeClosed()</code>:</p>
<p class="imageip"><img src="images/un609-03.jpg" alt="images" /></p>
<p class="noindent">You’ll get the output:</p>
<p class="imageip"><img src="images/un609-04.jpg" alt="images" /></p>
<p class="indent">As you saw, the <code>limit()</code> method allows you to limit the number of elements in a stream, so you can, for instance, limit a stream to the first five even numbers in a stream:</p>
<p class="imageip"><img src="images/un609-05.jpg" alt="images" /></p>
<p class="noindent">And get the output:</p>
<p class="imageip"><img src="images/un609-06.jpg" alt="images" /></p>
<p class="indent"><span id="page_610" epub:type="pagebreak"></span>What if you want to skip the first five items instead and print only the even numbers between 10 and 20? You can use <code>skip()</code>:</p>
<p class="imageip"><img src="images/un610-01.jpg" alt="images" /></p>
<p class="noindent">And you see</p>
<p class="imageip"><img src="images/un610-02.jpg" alt="images" /></p>
<h4 class="h4" id="ch9lev2sec23">Methods to Generate Streams</h4>
<p class="noindent">All the methods in <a href="ch9.xhtml#ch9tab8">Table 9-8</a> are static stream methods to generate streams, except <code>limit()</code> and <code>skip()</code>, which you’ll use to control how many items and which items go into the stream. Be extra careful with <code>iterate()</code> and <code>generate()</code>; both methods create infinite streams so you need to use these with <code>limit()</code> or one of the short-circuiting methods discussed earlier.</p>
<p class="tabcap" id="ch9tab8"><span class="table"><strong>TABLE 9-8</strong></span> Stream Methods to Generate Streams</p>
<p class="imaget"><img src="images/tab09-08.jpg" alt="Images" /></p>
<h4 class="h4" id="ch9lev2sec24">Caveat Time Again</h4>
<p class="noindent">Streams are fun to play with, and they are cool because they are still kind of new. But just because it’s new doesn’t mean it’s always better. We sold you pretty hard on streams being concise and potentially more efficient for data processing, but there are times when you may not want to use streams. For example, just doing a simple iteration over a <code>List</code> might be <em>slower</em> using a stream than a <code>for</code> loop. It’s worth testing to find out for your particular use case. In addition, functional code with streams and lambdas isn’t always easy to read, particularly if you’re used to reading code written in a more imperative style. So our caveat is this: just because you <em>can</em> use streams doesn’t mean they are always appropriate. Keep this in mind as you go beyond the exam and into the real world again.</p>
<p class="indent">Where streams can really shine is when you can parallelize them. We’re going to briefly talk about parallel streams now and then talk about them more later in the book when we talk about concurrency in depth.<span id="page_611" epub:type="pagebreak"></span></p>
<p class="title-o"><span id="page_612" epub:type="pagebreak"></span><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch9lev1sec11"><strong>A Taste of Parallel Streams</strong></h3>
<p class="noindent"><em>10.6   Use parallel Streams including reduction, decomposition, merging processes, pipelines and performance.</em></p>
<p class="indentt">We’ve mentioned a couple of times in this chapter that it’s possible to process streams in parallel. So far, all the streams we’ve worked with have been serial streams: streams that process one data element at a time. <em>Parallel streams</em> can process elements in a stream concurrently. The way Java does this is to split a stream into substreams and then execute the operations defined in the stream pipeline on each of these substreams concurrently, meaning each substream is processed in a thread. If you have multiple cores, then Java will use multiple threads to process the stream and you might get some performance benefits. (We say “might” here because whether you get those benefits depends on your system as well as the data you’re processing and how you’re processing it. We won’t go into an in-depth discussion on the performance tradeoffs of parallel streams, but if you’re interested, it’s well worth a deep dive into the literature about what makes for good use cases for parallel streams).</p>
<p class="indent">You’re going to learn a whole lot more about threads and parallel streams in the upcoming chapter on threads, so for now, we’re just going to give you a taste.</p>
<p class="indent">Let’s say you have some numbers and you want to sum them.</p>
<p class="imageip"><img src="images/un612-01.jpg" alt="images" /></p>
<p class="noindent">This stream is a serial stream, so each number is added to the sum one at a time.</p>
<p class="indent">To make this a parallel stream, we simply call the method <code>parallel()</code> on the stream before we sum:</p>
<p class="imageip"><img src="images/un612-02.jpg" alt="images" /></p>
<p class="indent"><span id="page_613" epub:type="pagebreak"></span>Now, the stream is processed concurrently, meaning the stream is split into substreams, and (if you have enough cores) each substream is processed on a separate thread. Let’s visualize how that works with some diagrams.</p>
<p class="indent">For a serial stream, we have one thread handling the entire sum operation:</p>
<p class="imageip"><img src="images/un613-01.jpg" alt="images" /></p>
<p class="indent">For a parallel stream, we have multiple threads handling the sum operation concurrently:</p>
<p class="imageip"><img src="images/un613-02.jpg" alt="images" /></p>
<p class="indent">Because each thread can compute the sum simultaneously with the other threads, the whole operation should take less time to compute than if you’re using a serial stream.</p>
<p class="indent">One thing to be careful of with parallel streams is performing an operation that relies on a specific ordering. If you use a parallel stream, you may get unexpected results. Let’s compare using <code>forEach()</code> to display the items in a stream when the stream is serial and when the stream is parallel.</p>
<p class="indent"><span id="page_614" epub:type="pagebreak"></span>Here’s the code using a serial stream:</p>
<p class="imageip"><img src="images/un614-01.jpg" alt="images" /></p>
<p class="noindent">The output you see is</p>
<p class="imageip"><img src="images/un614-02.jpg" alt="images" /></p>
<p class="noindent">In other words, you see the data in the same order as it appears in the source of the stream, the original <code>List</code> of names. That is because, by default, the stream is serial, and the elements in the stream are processed in order.</p>
<p class="indent">If you run the same code with a parallel stream instead:</p>
<p class="imageip"><img src="images/un614-03.jpg" alt="images" /></p>
<p class="noindent">You’ll potentially get a different ordering in the output every time you run the code. For instance, when we ran this code, we saw</p>
<p class="imageip"><img src="images/un614-04.jpg" alt="images" /></p>
<p class="noindent">And if we run it again, we’ll likely see a different ordering again. That’s because the final result depends on the order in which the threads complete, not the order of the original collection. The ordering of the stream didn’t matter when we were summing numbers (the sum is the same, independent of order), but the order matters a lot if you are expecting to see the content of the stream in the same order as the content in the original <code>Collection</code>.</p>
<p class="indent">That is just a small taste of parallel streams, and you’ll learn a lot more about them a bit later on in <a href="ch11.xhtml#ch11">Chapter 11</a>, where we cover concurrency.</p>
<h3 class="h3b" id="ch9lev1sec12"><span id="page_615" epub:type="pagebreak"></span>CERTIFICATION SUMMARY</h3>
<hr/>
<p class="noindent">A stream is a fairly abstract concept: it is a sequence of elements supporting operations. Knowing the difference between a stream and a data structure is key to understanding streams, and the analogies we used in this chapter—real-life streams and assembly lines—are meant to remind you that streams are for specifying a sequence of operations—the stream pipeline—to perform on a source. Streams never actually hold data like a data structure does. Once you wrap your head around that, then you’ll have a much easier time getting the hang of the pipeline operations, of which there are many that you can perform on a stream.</p>
<p class="indent">You create a stream from a source, like a <code>List</code> or a <code>File</code>; specify the sequence of intermediate operations to perform; and finally, provide the terminal operation that terminates the stream and perhaps reduces the stream into a single value or displays the values from the stream in the console. But streams are lazy, so none of the intermediate operations in the pipeline actually do anything until that terminal operation is executed.</p>
<p class="indent">The main way you operate on streams is with mapping functions, filter functions, and reduction functions. Mapping functions map values to other values, perhaps changing the type along the way. Filter functions filter out some of the values (or none or all, depending on the filter), so you can eliminate values that don’t pass a test. Finally, reduction functions provide the terminal operations on streams to reduce a stream to a single value or to a collection. This map-filter-reduce perspective on stream operations is a handy way to organize the many operations you’ll encounter as you work with streams.</p>
<p class="indent">Streams can be sorted and searched, like data structures can—but remember you can’t modify the source of a stream. When you, say, sort a stream, you need to collect the sorted values into a new data structure if you want to keep them around. Searching produces a value, but because a stream might be empty, you need a way to represent the concept of a value that may or may not be there. This is when you first encountered the optionals: values that are wrapped in the <code>Optional</code> type so you can work with empty streams without creating any problems. Of course, there are a variety of ways to get values back out of the <code>Optional</code> wrapper so you can work with the result as you normally do.</p>
<p class="indent">If you want to keep multiple values from a stream rather than reducing the stream to a single value, then you need a way to collect those values into a new data structure. This is what the <code>collect()</code> reduction method does. This method takes a <code>Collector</code>, which is an operation that accumulates the elements into a data structure like a <code>List</code> or a <code>Map</code>. As you’re collecting elements, you can group them, partition them, count them, map them, reduce them, and more. Collectors are versatile, providing many different ways of collecting values from the stream <span id="page_616" epub:type="pagebreak"></span>into a result. We touched on some of the collection strategies in this chapter for the operations you’ll apply on the exam, but you can take this topic a lot further if you want to explore on your own.</p>
<p class="indent">Generating streams is a way of pushing a (potentially) infinite number of values through the stream pipeline. However, in practice, you can’t actually work with an infinite stream (at least not on today’s computers!), so you need to limit it in some way, either by limiting how many items to use or by short-circuiting the stream pipeline with a searching method like <code>findAny()</code>.</p>
<p class="indent">At the end of the chapter, we took a sneak peek at parallel streams, which are streams that can be operated on concurrently. Parallel streams are where you are likely to see the main performance benefits of using streams in your code, and parallel streams are certainly one of the easiest ways to take advantage of concurrency in your code, as you’ll see when we get to <a href="ch11.xhtml#ch11">Chapter 11</a> (although, as with all things related to concurrency, there are some potential landmines you’ll need to watch out for when you get there).</p>
<h3 class="h3b" id="ch9lev1sec13"><span id="page_617" epub:type="pagebreak"></span><img src="images/tick1.jpg" alt="Images" /> TWO-MINUTE DRILL</h3>
<p class="noindent">Here are some of the key points from this chapter.</p>
<h4 class="h4">What Is a Stream? (OCP Objective 3.4)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A stream is a sequence of elements that can be processed with operations.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A stream is not a data structure; it does not store any data.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A stream pipeline consists of a source, an optional sequence of intermediate operations, and a terminal operation.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The source of a stream can be a collection, an array, a file, or one or more values.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can create a stream of objects or a stream of primitive values.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The type of a stream of objects is <code>Stream&lt;T&gt;</code>, and the primitive stream types are <code>DoubleStream</code>, <code>IntStream</code>, and <code>LongStream</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Pay close attention to the difference between <code>Stream&lt;Double&gt;</code> and <code>DoubleStream</code> and the operations allowed on each (and the same with other primitive type streams).</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Intermediate operations operate on a stream and return a stream.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Terminal operations terminate the stream, returning a value other than a stream or void.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>filter()</code> is an example of an intermediate operation. Pass <code>filter()</code> a <code>Predicate</code> and use <code>filter()</code> to filter values out of the stream that don’t pass the <code>Predicate</code> test. For example, you can filter out elements that are less than 5 from a stream like this:</p>
<p class="bull-image1"><img src="images/un617-01.jpg" alt="images" /></p>
<p class="bull-image1">The stream returned by this filter operation is a stream of numbers: 5, 8, 13.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>forEach()</code> is a terminal operation on a stream. <code>forEach()</code> takes a <code>Consumer</code> and consumes each element of the stream on which it’s called. We often use <code>forEach()</code> to display the values in the stream at the end of the stream pipeline, like this:</p>
<p class="bull-image1"><img src="images/un617-02.jpg" alt="images" /></p>
<p class="bull-image"><span id="page_618" epub:type="pagebreak"></span><img class="inline" src="images/box1.jpg" alt="Images" />  <code>count()</code> is a terminal operation on a stream that counts the elements in the stream.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Streams can only be used once. Streams are lightweight objects, so you can easily create another stream.</p>
<h4 class="h4">How to Create a Stream (OCP Objectives 3.5 and 9.3)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Create a stream from a collection, like a <code>List</code>, using the <code>stream()</code> method.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Create a stream from one or more values using <code>Stream.of()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Create an empty stream using <code>Stream.empty()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Create a stream from an array using <code>Arrays.stream()</code> or <code>Stream.of()</code> (and <code>IntStream.of()</code>, <code>LongStream.of()</code>, and <code>DoubleStream.of()</code>).</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Create a stream (<code>Stream&lt;String&gt;</code>) from a <code>File</code> using <code>Files.lines()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Streams have several benefits: you can define multiple intermediate operations on streams. The JDK can optimize the operations, so you may see a performance enhancement, especially when you can parallelize the stream.</p>
<h4 class="h4">The Stream Pipeline (OCP Objectives 3.6)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A stream pipeline consists of a source, a sequence of intermediate operations, and a terminal operation.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A common analogy to use for the stream pipeline is the assembly line. Each assembly-line station is analogous to an intermediate operation, so that a stream element visits each operation, where it is (usually) modified and passed on until it reaches the terminal operation or is discarded (via a filter).</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Streams are lazy, meaning until you define and execute a terminal operation on the stream, no processing happens.</p>
<h4 class="h4">Operating on Streams (OCP Objectives 3.7 and 5.1)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Map-filter-reduce is a general abstraction to describe functions that operate on a sequence of elements.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Stream operations <code>map()</code>, <code>filter()</code>, and <code>reduce()</code> implement mapping operations, filtering operations, and reduction operations (terminal operations), respectively.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Mapping operations typically modify elements from the stream, transforming an element from one value to another or from one type to another.</p>
<p class="bull-image"><span id="page_619" epub:type="pagebreak"></span><img class="inline" src="images/box1.jpg" alt="Images" />  Filter operations typically winnow elements from the stream so that any element that doesn’t pass a test is discarded from the stream.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Reduction operations reduce the stream to a single value, or a collection.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>map()</code> and <code>filter()</code>, and their variations, are intermediate operations.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>reduce()</code> and its variations are terminal operations.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>map()</code> takes a <code>Function</code>, which takes an input value and produces an output value.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>filter()</code> takes a <code>Predicate</code>, which tests the input value and passes the stream element on to the next intermediate operation if the result of the test is true.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The methods <code>average()</code>, <code>count()</code>, <code>sum()</code>, <code>max()</code>, and <code>min()</code> are predefined reductions on streams.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>sum()</code> and <code>average()</code> are defined only on the primitive stream types.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>max()</code> and <code>min()</code> are defined on all streams. On <code>Stream&lt;T&gt;</code>, <code>max()</code> and <code>min()</code> take a <code>Comparator</code> to determine which stream element is the maximum or minimum, respectively.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>reduce()</code>takes an (optional) identity value and a <code>BinaryOperator</code> to reduce the stream to one value. If the identity value is provided, this is used as the result if the stream is empty; otherwise, the identity is used as the basis for the <code>BinaryOperator</code> accumulator. If no identity value is provided, <code>reduce()</code> returns an <code>Optional</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>peek()</code> method is a way to “peek” into the values currently in the stream. The method makes no changes to the values in the stream and is often used with a <code>Consumer</code> that displays the values to the console for debugging purposes. <code>peek()</code> should not be used in production code.</p>
<h4 class="h4">Map-Filter-Reduce with average() and Optionals (OCP Objectives 5.3 and 5.4)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Some stream methods produce <code>Optional</code> values.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>Optional</code> is a wrapper around a value that may or may not be there.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>average()</code> is an example of a reduction operation that produces an optional value, an <code>OptionalDouble</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>reduce()</code> method used without an identity argument produces an optional because there may be no value if the stream is empty.</p>
<p class="bull-image"><span id="page_620" epub:type="pagebreak"></span><img class="inline" src="images/box1.jpg" alt="Images" />  If you supply an identity argument to <code>reduce()</code>, the method will produce a value (not an optional), and use the identity value if the stream is empty.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>sum()</code> method does not produce an optional because, by default, it uses 0 as the identity value.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>average()</code> method cannot be replaced with your own implementation using <code>reduce()</code> because average is not an associative operation. All <code>reduce()</code> operations must be associative operations, meaning you can accumulate the elements for the reduction in any order and get the same result. Sum is an example of an associative operation, so you could implement <code>sum()</code> yourself using <code>reduce()</code>.</p>
<h4 class="h4">Optionals (OCP Objective 5.3)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  An optional is a container, or wrapper, that may or may not contain a value.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Operations that produce no value if a stream is empty produce optionals. For example, <code>findFirst()</code>, <code>findAny()</code>, <code>max()</code>, <code>min()</code>, and <code>average()</code> all produce optionals.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Before getting a value from an optional, first test to see if the optional contains a value with <code>isPresent()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The types of optionals are <code>Optional&lt;T&gt;</code> (for objects) and primitive optionals, <code>OptionalDouble</code>, <code>OptionalInt</code>, and <code>OptionalLong</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  To get a value from a nonempty optional, use <code>get()</code>, <code>getAsDouble()</code>, <code>getAsInt()</code>, or <code>getAsLong()</code> for the different types of optionals.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>ifPresent()</code> method tests to see whether an optional is present and then passes the unwrapped value to the <code>Consumer</code> argument to <code>ifPresent()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Most of the time optionals are created by stream operations; however, you can create your own optional using <code>Optional.of()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>ofNullable()</code> method creates an <code>Optional</code> value from an object, first testing to see whether the object is <code>null</code>. If the object is <code>null</code>, then an empty <code>Optional</code> is created.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can create your own empty <code>Optional</code> with <code>Optional.empty()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Use the <code>orElse()</code> method to get a value from an <code>Optional</code> and provide a default value to use if the <code>Optional</code> is empty.</p>
<h4 class="h4"><span id="page_621" epub:type="pagebreak"></span>Searching and Sorting with Streams (OCP Objectives 5.2 and 5.5)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Searching operations on streams are short-circuiting, meaning the stream processing stops once the <code>Predicate</code> test passed to the search method is passed.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The search methods on streams include <code>allMatch()</code>, <code>anyMatch()</code>, <code>noneMatch()</code>, <code>findFirst()</code>, and <code>findAny()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The methods <code>allMatch()</code>, <code>anyMatch()</code>, and <code>noneMatch()</code> are terminal operations on a stream that return a boolean indicating if a match was found (or not).</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The methods <code>findFirst()</code>and <code>findAny()</code>are terminal operations that return an <code>Optional</code> value whose parameterized type depends on the type of the stream. In case no item is found, the value returned is an empty <code>Optional</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can sort elements of a stream using the <code>sorted()</code> method. By default, the <code>sorted()</code> method uses natural ordering. If the objects in the source of the stream are <code>Comparable</code>, the sort will use that order. If the elements of a stream are primitive, the natural order for sorting is used for <code>double</code>, <code>int</code>, and <code>long</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can pass a <code>Comparator</code> to the <code>sorted()</code> method to override the natural sort order and define your own sort order.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>Comparator</code> is a functional interface with one functional method, <code>compare()</code>, so you can use a lambda expression to pass a <code>Comparator</code> to the <code>sorted()</code> method.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can use the <code>Comparator.comparing()</code> method with a <code>Function</code> to create a <code>Comparator</code> to use with <code>sorted()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Use <code>thenComparing()</code> to combine comparators for sorting by one value then another.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Instance method references refer to methods of an instance. Use the <code>::</code> syntax to create a method reference as a shorthand for a lambda that simply calls another method. For example, you can replace a lambda expression that calls the <code>getColor()</code> method of a <code>Duck</code> instance:</p>
<p class="bull-image1"><img src="images/un621-01.jpg" alt="images" /></p>
<p class="bull-image1">with an instance method reference:</p>
<p class="bull-image1"><img src="images/un621-02.jpg" alt="images" /></p>
<p class="bull-image"><span id="page_622" epub:type="pagebreak"></span><img class="inline" src="images/box1.jpg" alt="Images" />  Streams are a functional style of programming in which you must be careful to avoid side effects. Stream patterns encourage you to avoid modifying the source of the stream in any stream pipeline operations, and in fact, modifying the source of a stream can lead to unexpected results.</p>
<h4 class="h4">Collecting Values from Streams (OCP Objectives 3.8 and 5.6)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The source of a stream is often a <code>Collection</code>. Many reduction methods on streams, such as <code>sum()</code> and <code>average()</code>, turn stream elements into a single value. You can collect the elements in a stream into a new <code>Collection</code> using the stream method <code>collect()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>collect()</code>stream method is a reduction (terminal) operation.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A <code>Collector</code> is an operation that accumulates elements into a result. You can specify a <code>Collector</code> with four functions: a supplier, an accumulator, a combiner, and a finisher (optional). Or, you can use one of the methods in the <code>Collectors</code> class to create a <code>Collector</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>Collectors</code> class has ready-made <code>Collector</code>s, such as a <code>Collector</code> to accumulate elements into a <code>List</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Use the <code>Collectors.toList()</code> method to create a <code>Collector</code> that accumulates stream elements into a <code>List</code>. <code>Collectors.toMap()</code> and <code>Collectors.toSet()</code> accumulate stream elements into a <code>Map</code> and <code>Set</code>, respectively.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  If you want a more specific <code>Collection</code> type, use the <code>Collectors.toCollection()</code> method, passing a <code>Supplier</code> that provides a new instance of the <code>Collection</code> type you want (such as <code>ArrayList</code>).</p>
<p class="bull-image-1"><img class="inline" src="images/box1.jpg" alt="Images" />  The method reference <code>ArrayList::new</code> is a constructor method reference that is shorthand for a lambda expression <code>() -&gt; new ArrayList&lt;T&gt;()</code> (where <code>T</code> is a valid type parameter, such as <code>String</code>, and depends on the type of the elements in the stream).</p>
<p class="bull-image-1"><img class="inline" src="images/box1.jpg" alt="Images" />  You can use constructor method references as <code>Supplier</code>s for the <code>Collectors.toCollection()</code> method.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Use the <code>Collectors.groupingBy()</code> method to group elements as you collect them. The <code>Collectors.groupingBy()</code> method returns a <code>Collector</code> that produces a <code>Map</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Use the <code>Collectors.partitioningBy()</code> method to group elements into two partitions as you collect them. The <code>Collectors.partitioningBy()</code> method returns a <code>Collector</code> that produces a <code>Map</code> with two keys, <code>true</code> and <code>false</code>.</p>
<p class="bull-image"><span id="page_623" epub:type="pagebreak"></span><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>Collectors.groupingBy()</code> method can accept downstream collectors to further reduce results. For instance, instead of creating a <code>Map</code> that maps age keys to a <code>List</code> of <code>Person</code> objects that have that age, you can use the <code>Collectors.counting()</code> method to reduce the <code>List</code> of <code>Person</code> objects to their count, resulting in a <code>Map</code> from age keys to number of <code>Person</code>s with that age values.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>Collectors.counting()</code> returns a <code>Collector</code> that counts the number of input elements and returns a <code>Long</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can use <code>Collectors.mapping()</code> as a downstream <code>Collector</code> that maps values from one type to another before they are accumulated. For instance, we used <code>Collectors.mapping()</code> to create a <code>Collector</code> that maps <code>Person</code> objects to names and to collect them in a <code>List</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>Collectors.summingInt()</code> and <code>Collectors.averagingInt()</code>, and their <code>Double</code> and <code>Long</code> counterparts, produce <code>Collector</code>s that sum values and average values, respectively. These can be used as downstream collectors.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>Collectors.joining()</code> produces a <code>Collector</code> that concatenates <code>String</code> elements (and any <code>CharSequence</code>-based types) to one <code>String</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>Collectors.counting()</code> produces a <code>Collector</code> that counts elements and returns a <code>Long</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>Collectors.maxBy()</code> and <code>Collectors.minBy()</code> produce a <code>Collector</code> that finds the maximum or minimum element in a stream when supplied with a <code>Comparator</code>.</p>
<h4 class="h4">Streams of Streams (OCP Objective 5.7)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Sometimes the type of <code>Stream</code> in a pipeline is a <code>Stream</code> of <code>Stream</code>s. For instance: <code>Stream&lt;Stream&lt;String&gt;&gt;</code> is a stream of string streams.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can use the <code>Stream</code> method <code>flatMap()</code> to flatten streams, essentially concatenating the values from each stream within the stream. For instance, to flatten a <code>Stream&lt;Stream&lt;String&gt;&gt; sss</code> that you created with code like this:</p>
<p class="bull-image1"><img src="images/un623-01.jpg" alt="images" /></p>
<p class="bull-image1">you could write:</p>
<p class="bull-image1"><img src="images/un623-02.jpg" alt="images" /></p>
<h4 class="h4"><span id="page_624" epub:type="pagebreak"></span>Generating Streams (OCP Objective 3.4)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can create infinite streams with the <code>Stream</code> methods <code>iterate()</code> and <code>generate()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>Stream</code> method <code>iterate()</code> method takes a seed (e.g., 0) and a <code>UnaryOperator</code> to generate a sequential ordered stream of values. The primitive streams have corresponding <code>iterate()</code> methods that generate streams of primitive values.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>Stream</code> method <code>generate()</code> method takes a <code>Supplier</code> that generates values for a <code>Stream</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Be careful when working with infinite streams. To do something useful with them, you need to limit the size of the stream with <code>limit()</code> or by using a short-circuiting method like <code>anyMatch()</code> or <code>findAny()</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can generate <code>IntStream</code>s and <code>LongStream</code>s streams using the <code>range()</code> and <code>rangeClosed()</code> methods, which produce a sequence of numbers from a start value to an end value.</p>
<h4 class="h4">A Taste of Parallel Streams (OCP Objective 10.6)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  By default, streams are sequential, meaning the operations in the stream pipeline are processed sequentially on the source data.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can parallelize a stream using the <code>parallel()</code> method. But be careful how you use this method; not all stream pipelines can be parallelized!</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  We’ll take a more in-depth look at parallel streams in <a href="ch11.xhtml#ch11">Chapter 11</a>, which covers concurrency.</p>
<h3 class="h3b" id="ch9lev1sec14"><span id="page_625" epub:type="pagebreak"></span><img src="images/qs.jpg" alt="Images" /> SELF TEST</h3>
<p class="noindent">The following questions will help you practice using stream operations, and build and measure your understanding of the material in this chapter.</p>
<p class="que"><strong><a id="ch9ans1" href="ch9.xhtml#r_ch9ans1">1</a>.</strong>   Given the code fragment:</p>
<p class="num-pre"><img src="images/un625-01.jpg" alt="images" /></p>
<p class="alpha-no">Which code fragment inserted at line <code>// L1</code> will compile correctly and sum the numbers in the array <code>nums</code> and store the value in the variable sum?</p>
<p class="alpha"><img src="images/un625-02.jpg" alt="images" /></p>
<p class="que"><strong><a id="ch9ans2" href="ch9.xhtml#r_ch9ans2">2</a>.</strong>   Given the following code fragment:</p>
<p class="num-pre"><img src="images/un625-03.jpg" alt="images" /></p>
<p class="alpha-no">and a file, “names.txt,” with one name per line, which of the following code fragments inserted at line <code>// L1</code> will produce a sorted <code>List</code> of names in the variable <code>names</code>?</p>
<p class="alpha"><img src="images/un625-04.jpg" alt="images" /></p>
<p class="que"><span id="page_626" epub:type="pagebreak"></span><strong><a id="ch9ans3" href="ch9.xhtml#r_ch9ans3">3</a>.</strong>   What are the correct types for variables <code>s1</code> and <code>s2</code> in the code fragment below?</p>
<p class="num-pre"><img src="images/un626-01.jpg" alt="images" /></p>
<p class="alpha"><img src="images/un626-02.jpg" alt="images" /></p>
<p class="que"><strong><a id="ch9ans4" href="ch9.xhtml#r_ch9ans4">4</a>.</strong>   Given the code fragments:</p>
<p class="num-pre"><img src="images/un626-03.jpg" alt="images" /></p>
<p class="alpha-no">Which code fragment could you use for CODE in the call to <code>map()</code> in the following code fragment:</p>
<p class="num-pre"><img src="images/un626-04.jpg" alt="images" /></p>
<p class="alpha-no">to correctly print the string (choose all that apply):</p>
<p class="num-pre"><img src="images/un626-05.jpg" alt="images" /></p>
<p class="alpha"><span id="page_627" epub:type="pagebreak"></span><img src="images/un627-01.jpg" alt="images" /></p>
<p class="que"><strong><a id="ch9ans5" href="ch9.xhtml#r_ch9ans5">5</a>.</strong>   Given the <code>Duck</code> class and <code>ducks List</code>:</p>
<p class="num-pre"><img src="images/un627-02.jpg" alt="images" /></p>
<p class="alpha-no">What output does the following code fragment produce?</p>
<p class="num-pre"><img src="images/un627-03.jpg" alt="images" /></p>
<p class="alpha">A. <code>Kramer Huey</code></p>
<p class="alpha">B. <code>Jerry George Kramer Elaine Huey Louie Dewey</code></p>
<p class="alpha">C. No output, the code does not compile</p>
<p class="alpha">D. <code>Kramer is mottled and is 6 years old. Huey is mottled and is 2 years old.</code></p>
<p class="que"><span id="page_628" epub:type="pagebreak"></span><strong><a id="ch9ans6" href="ch9.xhtml#r_ch9ans6">6</a>.</strong>   Given the <code>Duck</code> class and <code>ducks List</code>:</p>
<p class="num-pre"><img src="images/un628-01.jpg" alt="images" /></p>
<p class="alpha-no">Which code fragment would you use to compute the average age of the ducks as a whole number?</p>
<p class="alpha"><img src="images/un628-02.jpg" alt="images" /></p>
<p class="que"><span id="page_629" epub:type="pagebreak"></span><strong><a id="ch9ans7" href="ch9.xhtml#r_ch9ans7">7</a>.</strong>   Given the <code>Duck</code> class and <code>ducks List</code>:</p>
<p class="num-pre"><img src="images/un629-01.jpg" alt="images" /></p>
<p class="alpha-no">Which code fragment would you use to count how many mottled ducks there are?</p>
<p class="alpha"><img src="images/un629-02.jpg" alt="images" /></p>
<p class="que"><span id="page_630" epub:type="pagebreak"></span><strong><a id="ch9ans8" href="ch9.xhtml#r_ch9ans8">8</a>.</strong>   Given the <code>Duck</code> class and <code>ducks List</code>:</p>
<p class="num-pre"><img src="images/un630-01.jpg" alt="images" /></p>
<p class="alpha-no">And the following code fragment:</p>
<p class="num-pre"><img src="images/un630-02.jpg" alt="images" /></p>
<p class="alpha-no">What is the result?</p>
<p class="alpha">A. Compilation fails</p>
<p class="alpha">B. An exception is thrown at runtime</p>
<p class="alpha"><span id="page_631" epub:type="pagebreak"></span><img src="images/un631-01.jpg" alt="images" /></p>
<p class="que"><strong><a id="ch9ans9" href="ch9.xhtml#r_ch9ans9">9</a>.</strong>   Given the <code>Duck</code> class and <code>ducks List</code>:</p>
<p class="num-pre"><img src="images/un631-02.jpg" alt="images" /></p>
<p class="alpha-no">and the following code fragment:</p>
<p class="num-pre"><img src="images/un631-03.jpg" alt="images" /></p>
<p class="alpha-no"><span id="page_632" epub:type="pagebreak"></span>What is the correct type for <code>duckMap</code> in <code>TYPE</code>?</p>
<p class="alpha"><img src="images/un632-01.jpg" alt="images" /></p>
<p class="que1"><strong><a id="ch9ans10" href="ch9.xhtml#r_ch9ans10">10</a>.</strong>   Given the code fragment:</p>
<p class="num-pre"><img src="images/un632-02.jpg" alt="images" /></p>
<p class="alpha-no">What is the correct <code>TYPE</code> for <code>minInteger</code>?</p>
<p class="alpha"><img src="images/un632-03.jpg" alt="images" /></p>
<p class="que1"><strong><a id="ch9ans11" href="ch9.xhtml#r_ch9ans11">11</a>.</strong>   Given the following code:</p>
<p class="num-pre"><img src="images/un632-04.jpg" alt="images" /></p>
<p class="alpha-no">and the following code fragment:</p>
<p class="num-pre"><img src="images/un632-05.jpg" alt="images" /></p>
<p class="alpha-no"><span id="page_633" epub:type="pagebreak"></span>What is the correct <code>TYPE</code> for <code>max</code>?</p>
<p class="alpha"><img src="images/un633-01.jpg" alt="images" /></p>
<p class="que1"><strong><a id="ch9ans12" href="ch9.xhtml#r_ch9ans12">12</a>.</strong>   Given the <code>Temperature</code> class and <code>julyAvgs List</code>:</p>
<p class="num-pre"><img src="images/un633-02.jpg" alt="images" /></p>
<p class="alpha-no">and the following code fragment:</p>
<p class="num-pre"><img src="images/un633-03.jpg" alt="images" /></p>
<p class="alpha-no">What is the correct <code>TYPE</code> for <code>maxT</code>?</p>
<p class="alpha"><img src="images/un633-04.jpg" alt="images" /></p>
<p class="que1"><span id="page_634" epub:type="pagebreak"></span><strong><a id="ch9ans13" href="ch9.xhtml#r_ch9ans13">13</a>.</strong>   Given the <code>Temperature</code> class and <code>julyAvgs List</code>:</p>
<p class="num-pre"><img src="images/un634-01.jpg" alt="images" /></p>
<p class="alpha-no">and the following code fragment:</p>
<p class="num-pre"><img src="images/un634-02.jpg" alt="images" /></p>
<p class="alpha-no">Will the minimum temperature, <code>min</code>, be the same as <code>coolerSpot</code>?</p>
<p class="alpha">A. Yes</p>
<p class="alpha">B. No</p>
<p class="alpha">C. Maybe</p>
<p class="que1"><strong><a id="ch9ans14" href="ch9.xhtml#r_ch9ans14">14</a>.</strong>   Given the <code>Temperature</code> class and <code>julyAvgs List</code>:</p>
<p class="num-pre"><img src="images/un634-03.jpg" alt="images" /></p>
<p class="num-pre"><span id="page_635" epub:type="pagebreak"></span><img src="images/un635-01.jpg" alt="images" /></p>
<p class="alpha-no">and the following code fragment:</p>
<p class="num-pre"><img src="images/un635-02.jpg" alt="images" /></p>
<p class="alpha-no">Which fragment(s), inserted independently at <code>// L1</code>, cause the code to print the <code>Temperature</code>s from high temp to low temp?</p>
<p class="alpha"><img src="images/un635-03.jpg" alt="images" /></p>
<p class="que1"><strong><a id="ch9ans15" href="ch9.xhtml#r_ch9ans15">15</a>.</strong>   Given the <code>Temperature</code> class and <code>julyAvgs List</code>:</p>
<p class="num-pre"><img src="images/un635-04.jpg" alt="images" /></p>
<p class="num-pre"><span id="page_636" epub:type="pagebreak"></span><img src="images/un636-01.jpg" alt="images" /></p>
<p class="alpha-no">and the following code fragment:</p>
<p class="num-pre"><img src="images/un636-02.jpg" alt="images" /></p>
<p class="alpha-no">What does this code display?</p>
<p class="alpha"><img src="images/un636-03.jpg" alt="images" /></p>
<p class="que1"><strong><a id="ch9ans16" href="ch9.xhtml#r_ch9ans16">16</a>.</strong>   Given the <code>Temperature</code> class and <code>julyAvgs List</code>:</p>
<p class="num-pre"><img src="images/un636-04.jpg" alt="images" /></p>
<p class="alpha-no"><span id="page_637" epub:type="pagebreak"></span>What does the following code fragment display?</p>
<p class="num-pre"><img src="images/un637-01.jpg" alt="images" /></p>
<p class="alpha"><img src="images/un637-02.jpg" alt="images" /></p>
<p class="que1"><strong><a id="ch9ans17" href="ch9.xhtml#r_ch9ans17">17</a>.</strong>   Given the <code>Temperature</code> class and <code>julyAvgs List</code>:</p>
<p class="num-pre"><img src="images/un637-03.jpg" alt="images" /></p>
<p class="alpha-no"><span id="page_638" epub:type="pagebreak"></span>Which of the following fragments will print <code>Temperature</code> objects sorted by location?</p>
<p class="alpha"><img src="images/un638-01.jpg" alt="images" /></p>
<h3 class="h3b" id="ch9lev2sec25"><span id="page_639" epub:type="pagebreak"></span><img src="images/aself.jpg" alt="Images" /> SELF TEST ANSWERS</h3>
<p class="que-q"><strong><a href="ch9.xhtml#ch9ans1" id="r_ch9ans1">1</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>B</strong> is correct. We provide an identity for <code>reduce()</code> so we get back an <code>int</code>, rather than an optional.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A</strong> is incorrect because <code>reduce()</code> needs an identity or it creates an <code>Optional</code>. <strong>C</strong> and<strong> D</strong> are incorrect syntax for <code>reduce()</code>, and both result in compile errors. (OCP Objective 3.4)</p>
<p class="que-q"><strong><a href="ch9.xhtml#ch9ans2" id="r_ch9ans2">2</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>D</strong> is correct. We call <code>sorted()</code> to sort the stream and <code>collect()</code> to collect the results in a <code>List</code>.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B,</strong> and<strong> C</strong> are incorrect. For <strong>A,</strong> <code>toList()</code> is a method of <code>Collectors</code>, not <code>Stream</code>. For <strong>B,</strong> <code>comparing()</code> is a method of <code>Comparator</code>, not <code>Stream</code> [you pass a <code>Comparator</code> to <code>sorted()</code>]. For <strong>C,</strong> <code>sorted()</code> is an intermediate stream operation that should be called before the <code>collect()</code> reduction, a terminal operation. (OCP Objectives 3.4, 3.6, 5.5, 5.6, and 9.3)</p>
<p class="que-q"><strong><a href="ch9.xhtml#ch9ans3" id="r_ch9ans3">3</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>D</strong> is correct. The <code>int</code>s in the call to <code>Stream.of()</code> get autoboxed to <code>Integer</code>s. (If we’d used <code>IntStream.of()</code> instead, then we could use <code>IntStream</code> as the type for <code>s1</code>.) Given that <code>s1</code> is a <code>Stream&lt;Integer&gt;</code>, when we call <code>mapToInt()</code> on elements of the stream (which maps objects to <code>int</code>s), we are converting the <code>Integer</code> objects to <code>int</code>s, so the type of <code>s2</code> must be <code>IntStream</code>.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B, C,</strong> and<strong> E</strong> are incorrect based on the above information. (OCP Objectives 3.4 and 5.1)</p>
<p class="que-q"><strong><a href="ch9.xhtml#ch9ans4" id="r_ch9ans4">4</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>A</strong> and<strong> C</strong> are correct. <strong>A</strong> is a method reference shorthand for <strong>C.</strong></p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>B</strong> and<strong> D</strong> are incorrect. <strong>B</strong> has incorrect syntax for a lambda expression and method reference. <strong>D</strong> is not a lambda expression and should be. (OCP Objective 4.4)</p>
<p class="que-q"><strong><a href="ch9.xhtml#ch9ans5" id="r_ch9ans5">5</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>A</strong> is correct. Filter all ducks who have “mottled” color and map ducks to their name.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>B, C,</strong> and<strong> D</strong> are incorrect. <strong>B</strong> shows all the ducks instead of just “mottled” ducks. <strong>D</strong> shows the result if you print the full <code>Duck</code> [via <code>toString()</code>] but you are mapping a duck to its name before printing. (OCP Objectives 3.4, 3.5, 3.7, and 5.1)</p>
<p class="que-q"><strong><a href="ch9.xhtml#ch9ans6" id="r_ch9ans6">6</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>B</strong> is correct. We stream the ducks and map each duck to its age (an <code>int</code>) and then reduce to the average of the ages. Note that we are using <code>mapToInt()</code> to map a duck to its age. <code>average()</code> returns an optional.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, C, D,</strong> and<strong> E</strong> are incorrect. <strong>A, C,</strong> and <strong>D</strong> don’t compile. <code>average()</code> returns an <code>OptionalDouble</code>. In <strong>D,</strong> we have an additional problem with <code>map()</code> because the lambda maps a duck to its age (a primitive), but <code>map()</code> is used to map an object to an object. (OCP Objectives 3.4, 5.1, 5.3, and 5.4)</p>
<p class="que-q"><span id="page_640" epub:type="pagebreak"></span><strong><a href="ch9.xhtml#ch9ans7" id="r_ch9ans7">7</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>A</strong> is correct. We stream the ducks and filter for ducks whose color is “mottled.” We call <code>count()</code> to reduce to the number of mottled ducks.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>B, C,</strong> and<strong> D</strong> are incorrect. <strong>B</strong> doesn’t compile [<code>count()</code> returns a <code>long</code>]. In <strong>C,</strong> <code>d</code> in filter is a <code>Duck</code>, not a <code>String</code>, so it will not equal “mottled” and the <code>count</code> will be 0. <strong>D</strong> doesn’t compile because of invalid syntax for the expected <code>Predicate</code> in <code>filter()</code>. (OCP Objectives 3.4, 3.7, and 5.4)</p>
<p class="que-q"><strong><a href="ch9.xhtml#ch9ans8" id="r_ch9ans8">8</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>D</strong> is correct. We stream the ducks and group them by their color, creating a <code>Map</code>. We then use <code>forEach()</code> to take each map entry (ducks by their color) and display the <code>Map</code> key—the color—and the <code>Map</code> value, which is a list of <code>Duck</code>s. We further iterate through each list of ducks to display just the names.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B,</strong> and<strong> C</strong> are incorrect. <strong>A</strong> and <strong>B</strong> are incorrect based on the above information. <strong>C</strong> is incorrect because it shows the <code>Duck</code> name printed as a <code>List</code> rather than as <code>String</code>s and shows the word “color” rather than the <code>color</code> value of each duck (the <code>Map</code> key for the <code>Map</code> produced by <code>Collectors.groupingBy()</code>). (OCP Objectives 5.1 and 5.6)</p>
<p class="que-q"><strong><a href="ch9.xhtml#ch9ans9" id="r_ch9ans9">9</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>C</strong> is correct. <code>Collectors.groupingBy()</code> creates a <code>Map</code> with <code>color String</code>s as keys and <code>List</code>s of <code>Duck</code>s as values.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B,</strong> and<strong> D</strong> are incorrect based on the above information. (OCP Objectives 3.4 and 5.6)</p>
<p class="que-q1"><strong><a href="ch9.xhtml#ch9ans10" id="r_ch9ans10">10</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>C</strong> is correct. <code>min()</code> is a reduction method that produces an optional type. We start with a <code>Stream&lt;Integer&gt;</code>; <code>mapToInt()</code> creates an <code>IntStream</code>, so <code>min()</code> produces an <code>OptionalInt</code>.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B,</strong> and<strong> D</strong> are incorrect based on the above information. (OCP Objectives 3.4, 5.1, and 5.4)</p>
<p class="que-q1"><strong><a href="ch9.xhtml#ch9ans11" id="r_ch9ans11">11</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>B</strong> is correct. <code>max()</code> takes a <code>Comparator</code>, which takes two <code>Temperature</code> objects and compares them using the <code>temp</code> field, producing the maximum <code>Temperature</code> object in the <code>List</code>.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, C, D, E,</strong> and<strong> F</strong> are incorrect based on the above information. (OCP Objectives 3.4, 5.3, and 5.4)</p>
<p class="que-q1"><strong><a href="ch9.xhtml#ch9ans12" id="r_ch9ans12">12</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>C</strong> is correct. We map each <code>Temperature</code> object to its (unboxed) <code>double temp</code> and take the <code>max()</code> of the stream of <code>double</code>s, producing an <code>OptionalDouble</code>.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B, D, E,</strong> and<strong> F</strong> are incorrect. (OCP Objectives 3.4, 5.1, 5.3, and 5.4)</p>
<p class="que-q1"><strong><a href="ch9.xhtml#ch9ans13" id="r_ch9ans13">13</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>C</strong> is correct. The minimum is 80.5 in Reno, Nevada. <code>findAny()</code> finds any <code>Temperature</code> from the filtered stream of <code>Temperature</code>s &lt; 100; for a nonparallel stream, it’s usually the first one, 85.3 in Salt Lake City, but there is no guarantee that <code>findAny()</code> will return the first <code>Temperature</code> in the filtered stream.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A</strong> and<strong> B</strong> are incorrect based on the above information. (OCP Objectives 3.4, 3.7, 5.1, 5.2, 5.3, and 5.4)</p>
<p class="que-q1"><span id="page_641" epub:type="pagebreak"></span><strong><a href="ch9.xhtml#ch9ans14" id="r_ch9ans14">14</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>D</strong> is correct. We stream the <code>Temperature</code>s using the <code>tCompare Comparator</code>, which sorts the <code>Temperature</code>s from low to high based on the <code>temp</code> value, so we then reverse that ordering with <code>reversed()</code>. Then we collect the results in a <code>List</code>.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B,</strong> and<strong> C</strong> are incorrect. <strong>A</strong> has two problems: <code>Temperature</code> isn’t <code>Comparable</code>, and <code>reversed()</code> is a method on <code>Comparator</code>s, so this code will not compile. <strong>B</strong> and <strong>C</strong> work but print the temperatures from low to high instead of high to low. (OCP Objectives 3.4, 5.5, and 5.6)</p>
<p class="que-q1"><strong><a href="ch9.xhtml#ch9ans15" id="r_ch9ans15">15</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>C</strong> is correct. We stream the <code>Temperature</code>s and map each temperature to a long value by rounding the <code>Temperature</code>’s <code>temp</code> value. We then remove any duplicates by calling <code>distinct()</code> (eliminating the repeated 81 value) and then print them out.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B,</strong> and<strong> D</strong> are incorrect. For <strong>A,</strong> notice in the code fragment that we are using <code>Math.round()</code> to cut off the decimal points (so we process <code>long</code>s, not <code>double</code>s). We are using <code>distinct()</code> to eliminate duplicates, so we shouldn’t see 81 twice as we do in <strong>B</strong>. <strong>D</strong> is sorted in the wrong order; natural order is ascending for <code>long</code> values. (OCP Objectives 3.4, 3.5, 3.6, 5.1, and 5.5)</p>
<p class="que-q1"><strong><a href="ch9.xhtml#ch9ans16" id="r_ch9ans16">16</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>B</strong> is correct. We are creating a partition, so we will get (and display) a <code>Map</code> with two keys, <code>true</code> and <code>false</code>, partitioned by whether the <code>temp</code> value of a <code>Temperature</code> is &gt;= 100.0. Each <code>Temperature</code> is mapped (downstream) to its <code>location</code> and the locations for each partition are collected into a <code>List</code>. The locations are <code>String</code>s, so we see a <code>List</code> of <code>String</code> locations for each partition.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, C,</strong> and<strong> D</strong> are incorrect based on the above information. (OCP Objectives 3.4 and 5.6)</p>
<p class="que-q1"><strong><a href="ch9.xhtml#ch9ans17" id="r_ch9ans17">17</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>C</strong> is correct. We sort the <code>Temperature</code> objects by location and print. <code>sorted()</code> takes a <code>Comparator</code>.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B,</strong> and<strong> D</strong> are incorrect. <strong>A</strong> and <strong>D</strong> display only locations, not the whole <code>Temperature</code> object. <strong>B</strong> produces a compile error because <code>sorted()</code> requires a <code>Comparator</code>, and we’ve provided a <code>Function</code>. (OCP Objectives 3.4, 3.8, 5.1, and 5.5)</p>
<h3 class="h3" id="ch9lev2sec26">EXERCISE ANSWER</h3>
<h5 class="h5">Exercise 9-1: Collecting Items in a List</h5>
<p class="noindent">Using <code>collect()</code> to collect DVDs into a <code>List</code> of <code>DVDInfo</code> objects as we read the dvds from a file, we can rewrite our <code>loadDVDs()</code> method as shown on the next page.</p>
<p class="imageip"><span id="page_642" epub:type="pagebreak"></span><img src="images/un642-01.jpg" alt="images" /></p>
<p class="noindent">This solution has the benefit of being more clear and avoids the side effect of modifying an object that’s defined outside the stream pipeline.</p>
</section>
</div>
</body>
</html>