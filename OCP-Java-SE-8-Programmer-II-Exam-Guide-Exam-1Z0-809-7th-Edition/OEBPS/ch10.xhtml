<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
<head>
  <meta charset="UTF-8" />
  <title>10 Threads</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  <link type="text/css" rel="stylesheet" media="all" href="core.css" />
</head>
<body>
  <div id="sbo-rt-content"><section epub:type="chapter">
<p class="image"><img src="images/common-01.jpg" alt="Images" /></p>
<h2 class="h2p" id="ch10"><span id="page_643" epub:type="pagebreak"></span>10</h2>
<h2 class="h2p1">Threads</h2>
<p class="title-o"><span class="white">CERTIFICATION OBJECTIVES</span></p>
<p class="toc-l">•       Create Worker Threads Using Runnable, Callable, and Use an ExecutorService to Concurrently Execute Tasks</p>
<p class="toc-l">•       Identify Potential Threading Problems among Deadlock, Starvation, Livelock, and Race Conditions</p>
<p class="toc-l">•       Use Synchronized keyword and java.util.concurrent.atomic Package to Control the Order of Thread Execution</p>
<p class="toc-lq"><img src="images/tick.jpg" alt="Images" />     Two-Minute Drill</p>
<p class="toc-q"><strong>Q&amp;A</strong>   Self Test</p>
<p class="title-o"><span id="page_644" epub:type="pagebreak"></span><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch10lev1sec1"><strong>Defining, Instantiating, and Starting Threads (OCP Objective 10.1)</strong></h3>
<p class="noindent"><em>10.1   Create worker threads using Runnable, Callable, and use an ExecutorService to concurrently execute tasks.</em></p>
<p class="indentt">Imagine a stockbroker application with a lot of complex capabilities. One of its functions is “download last stock option prices,” another is “check prices for warnings,” and a third time-consuming operation is “analyze historical data for company XYZ.”</p>
<p class="indent">In a single-threaded runtime environment, these actions execute one after another. The next action can happen <em>only</em> when the previous one is finished. If a historical analysis takes half an hour, and the user selects to perform a download and check afterward, the warning may come too late to, say, buy or sell stock as a result.</p>
<p class="indent">We just imagined the sort of application that cries out for multithreading. Ideally, the download should happen in the background (that is, in another thread). That way, other processes could happen at the same time so that, for example, a warning could be communicated instantly. All the while, the user is interacting with other parts of the application. The analysis, too, could happen in a separate thread so the user can work in the rest of the application while the results are being calculated.</p>
<p class="indent">So what exactly is a thread? In Java, “thread” means two different things:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   An instance of class <code>java.lang.Thread</code></p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   A thread of execution</p>
<p class="indent">An instance of <code>Thread</code> is just…an object. Like any other object in Java, it has variables and methods, and it lives and dies on the heap. But a <em>thread of execution </em>is an individual process (a “lightweight” process) that has its own call stack. In Java, there is <em>one thread per call stack</em>—or, to think of it in reverse, <em>one call stack per thread.</em> Even if you don’t create any new threads in your program, threads are back there running.</p>
<p class="indent">The <code>main()</code> method, which starts the whole ball rolling, runs in one thread, called (surprisingly) the <em>main</em> thread. If you looked at the main call stack (and you <span id="page_645" epub:type="pagebreak"></span>can any time you get a stack trace from something that happens after main begins, but not within another thread), you’d see that <code>main()</code> is the first method on the stack—the method at the bottom. But as soon as you create a <em>new</em> thread, a new stack materializes and methods called from <em>that</em> thread run in a call stack that’s separate from the <code>main()</code> call stack. That second new call stack is said to run concurrently with the main thread, but we’ll refine that notion as we go through this chapter.</p>
<p class="indent">You might find it confusing that we’re talking about code running <em>concurrently</em>—what gives? The JVM, which gets its turn at the CPU by whatever scheduling mechanism the underlying OS uses, operates like a mini-OS and schedules <em>its</em> own threads, regardless of the underlying operating system. In some JVMs, the Java threads are actually mapped to native OS threads, but we won’t discuss that here; native threads are not on the exam. Nor is it required to understand how threads behave in different JVM environments. In fact, the most important concept to understand from this entire chapter is this:</p>
<p class="indent1">When it comes to threads, very little is guaranteed.</p>
<p class="indent">So be very cautious about interpreting the behavior you see on <em>one</em> machine as “the way threads work.” The exam expects you to know what is and is not guaranteed behavior so that you can design your program in such a way that it will work, regardless of the underlying JVM. <em>That’s part of the whole point of Java.</em></p>
<p class="text-icon"><img src="images/onjob.jpg" alt="Images" /></p>
<p class="noindent"><strong><em>Don’t make the mistake of designing your program to be dependent on a particular implementation of the JVM. As you’ll learn a little later, different JVMs can run threads in profoundly different ways. For example, one JVM might be sure that all threads get their turn, with a fairly even amount of time allocated for each thread in a nice, happy, round-robin fashion. But in other JVMs, a thread might start running and then just hog the whole show, never stepping out so others can have a turn. If you test your application on the “nice turn-taking” JVM and you don’t know what is and is not guaranteed in Java, then you might be in for a big shock when you run it under a JVM with a different thread-scheduling mechanism.</em></strong></p>
<p class="indentt">The thread questions are among the most difficult questions on the exam. In fact, for most people, they <em>are</em> the toughest questions on the exam, and with three objectives for threads, you’ll be answering a <em>lot</em> of thread questions. If you’re not already familiar with threads, you’ll probably need to spend some time experimenting. Also, one final disclaimer: <em>This chapter makes almost no attempt to <span id="page_646" epub:type="pagebreak"></span>teach you how to design a good, safe multithreaded application. We only scratch the surface of that huge topic in this chapter!</em> You’re here to learn the basics of threading and what you need to get through the thread questions on the exam. Before you can write decent multithreaded code, however, you really need to study more of the complexities and subtleties of multithreaded code.</p>
<p class="indent">Note: The topic of daemon threads is NOT on the exam. All of the threads discussed in this chapter are “user” threads. You and the operating system can create a second kind of thread called a daemon thread. The difference between these two types of threads (user and daemon) is that the JVM exits an application only when all user threads are complete—the JVM doesn’t care about letting daemon threads complete, so once all user threads are complete, the JVM will shut down, regardless of the state of any daemon threads. Once again, this topic is NOT on the exam.</p>
<h4 class="h4" id="ch10lev2sec1">Making a Thread</h4>
<p class="noindent">A thread in Java begins as an instance of <code>java.lang.Thread</code>. You’ll find methods in the <code>Thread</code> class for managing threads, including creating, starting, and pausing them. For the exam, you’ll need to know, at a minimum, the following methods:</p>
<p class="imageip"><img src="images/un646-01.jpg" alt="images" /></p>
<p class="indent">The action happens in the <code>run()</code> method. Think of the code you want to execute in a separate thread as <em>the job to do.</em> In other words, you have some work that needs to be done—say, downloading stock prices in the background while other things are happening in the program—so what you really want is that <em>job</em> to be executed in its own thread. So, if the <em>work</em> you want done is the <em>job,</em> the one <em>doing</em> the work (actually executing the job code) is the <em>thread</em>. And the<em> job always starts from a </em><code>run()</code> <em>method,</em> as follows:</p>
<p class="imageip"><img src="images/un646-02.jpg" alt="images" /></p>
<p class="indent">You always write the code that needs to be run in a separate thread in a <code>run()</code> method. The <code>run()</code> method will call other methods, of course, but the thread of execution—the new call stack—always begins by invoking <code>run()</code>. So where does the <code>run()</code> method go? In one of the two classes you can use to define your thread job.</p>
<p class="indent"><span id="page_647" epub:type="pagebreak"></span>You can define and instantiate a thread in one of two ways:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Extend the <code>java.lang.Thread</code> class.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   Implement the <code>Runnable</code> interface.</p>
<p class="indent">You need to know about both for the exam, although in the real world, you’re much more likely to implement <code>Runnable</code> than extend <code>Thread</code>. Extending the <code>Thread</code> class is the easiest, but it’s usually not good OO practice. Why? Because subclassing should be reserved for specialized versions of more general superclasses. So the only time it really makes sense (from an OO perspective) to extend <code>Thread</code> is when you have a more specialized version of a <code>Thread</code> class. In other words, because <em>you have more specialized thread-specific behavior.</em> Chances are, though, that the thread work you want is really just a job to be done <em>by</em> a thread. In that case, you should design a class that implements the <code>Runnable</code> interface, which also leaves your class free to extend some <em>other</em> class.</p>
<h4 class="h4" id="ch10lev2sec2">Defining a Thread</h4>
<p class="noindent">To define a thread, you need a place to put your <code>run()</code> method, and as we just discussed, you can do that by extending the <code>Thread</code> class or by implementing the <code>Runnable</code> interface. We’ll look at both in this section.</p>
<h5 class="h5">Extending java.lang.Thread</h5>
<p class="noindent">The simplest way to define code to run in a separate thread is to</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Extend the <code>java.lang.Thread</code> class.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   Override the <code>run()</code> method.</p>
<p class="indent">It looks like this:</p>
<p class="imageip"><img src="images/un647-01.jpg" alt="images" /></p>
<p class="indent">The limitation with this approach (besides being a poor design choice in most cases) is that if you extend <code>Thread</code>, <em>you can’t extend anything else.</em> And it’s not as if you really need that inherited <code>Thread</code> class behavior; because in order to use a thread, you’ll need to instantiate one anyway.</p>
<p class="indent"><span id="page_648" epub:type="pagebreak"></span>Keep in mind that you’re free to overload the <code>run()</code> method in your <code>Thread</code> subclass:</p>
<p class="imageip"><img src="images/un648-01.jpg" alt="images" /></p>
<p class="indent">But know this: The overloaded <code>run(String s)</code> method will be ignored by the <code>Thread</code> class unless you call it yourself. The <code>Thread</code> class expects a <code>run()</code> method with no arguments, and it will execute this method for you in a separate call stack after the thread has been started. With a <code>run(String s)</code> method, the <code>Thread</code> class won’t call the method for you, and even if you call the method directly yourself, execution won’t happen in a new thread of execution with a separate call stack. It will just happen in the same call stack as the code that you made the call from, just like any other normal method call.</p>
<h5 class="h5">Implementing java.lang.Runnable</h5>
<p class="noindent">Implementing the <code>Runnable</code> interface gives you a way to extend any class you like but still define behavior that will be run by a separate thread. It looks like this:</p>
<p class="imageip"><img src="images/un648-02.jpg" alt="images" /></p>
<p class="indent">Notice that the <code>Runnable</code> interface is a functional interface, that is, an interface with one abstract method, <code>run()</code>. That means we can also write a <code>Runnable</code> like this:</p>
<p class="imageip"><img src="images/un648-03.jpg" alt="images" /></p>
<p class="indent">Regardless of which mechanism you choose, you’ve now got yourself some code that can be run by a thread of execution. Let’s take a look at <em>instantiating</em> your thread-capable class, and then we’ll figure out how to actually get the thing <em>running</em>.</p>
<h4 class="h4" id="ch10lev2sec3"><span id="page_649" epub:type="pagebreak"></span>Instantiating a Thread</h4>
<p class="noindent">Remember, every thread of execution begins as an instance of class <code>Thread</code>. Regardless of whether your <code>run()</code> method is in a <code>Thread</code> subclass or a <code>Runnable</code> implementation class, you still need a <code>Thread</code> object to do the work.</p>
<p class="indent">If you extended the <code>Thread</code> class, instantiation is dead simple (we’ll look at some additional overloaded constructors in a moment):</p>
<p class="imageip"><img src="images/un649-01.jpg" alt="images" /></p>
<p class="indent">If you implement <code>Runnable</code>, instantiation is only slightly less simple. To have code run by a separate thread, <em>you still need a Thread instance. </em>But rather than combining both the <em>thread</em> and the <em>job</em> (the code in the <code>run()</code>method) into one class, you’ve split it into two classes—the <code>Thread</code> class for the <em>thread-specific </em>code and your <code>Runnable</code> implementation class for your<em> job-that-should-be-run-by-a-thread </em>code. (Another common way to think about this is that the <code>Thread</code> is the “worker,” and the <code>Runnable</code> is the “job” to be done.)</p>
<p class="indent">First, you instantiate your <code>Runnable</code> class:</p>
<p class="imageip"><img src="images/un649-02.jpg" alt="images" /></p>
<p class="indent">Next, you get yourself an instance of <code>java.lang.Thread</code> (<em>somebody </em>has to run your job…), and you <em>give it your job!</em></p>
<p class="imageip"><img src="images/un649-03.jpg" alt="images" /></p>
<p class="indent">Or, if you want to use a lambda expression, you can eliminate <code>MyRunnable</code> and write:</p>
<p class="imageip"><img src="images/un649-04.jpg" alt="images" /></p>
<p class="indent">If you create a thread using the no-arg constructor, the thread will call its own <code>run()</code> method when it’s time to start working. That’s exactly what you want when you extend <code>Thread</code>, but when you use <code>Runnable</code>, you need to tell the new thread to use <em>your</em> <code>run()</code> method rather than its own. The <code>Runnable</code> you pass to the <code>Thread</code> constructor is called the <em>target </em>or the <em>target </em><code>Runnable</code>.</p>
<p class="indent">You can pass a single <code>Runnable</code> instance to multiple <code>Thread</code> objects so that the same <code>Runnable</code> becomes the target of multiple threads, as follows:</p>
<p class="imageip"><img src="images/un649-05.jpg" alt="images" /></p>
<p class="imageip"><span id="page_650" epub:type="pagebreak"></span><img src="images/un650-01.jpg" alt="images" /></p>
<p class="indent">Giving the same target to multiple threads means that several threads of execution will be running the very same job (and that the same job will be done multiple times).</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>The Thread class itself implements <code>Runnable</code>. (After all, it has a <code>run()</code> method that we were overriding.) This means that you could pass a <code>Thread</code> to another Thread’s constructor:</em></strong></p>
<p class="noindent1"><img src="images/un650-02.jpg" alt="images" /></p>
<p class="noindent"><strong><em>This is a bit silly, but it’s legal. In this case, you really just need a <code>Runnnable</code>, and creating a whole other <code>Thread</code> is overkill.</em></strong></p>
</div>
<p class="indent">Besides the no-arg constructor and the constructor that takes a <code>Runnable</code> (the target, i.e., the instance with the job to do), there are other overloaded constructors in class <code>Thread</code>. The constructors we care about are</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   <code>Thread()</code></p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <code>Thread(Runnable target)</code></p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <code>Thread(Runnable target, String name)</code></p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   <code>Thread(String name)</code></p>
<p class="indent">You need to recognize all of them for the exam! A little later, we’ll discuss some of the other constructors in the preceding list.</p>
<p class="indent">So now you’ve made yourself a <code>Thread</code> instance, and it knows which <code>run()</code> method to call. <em>But nothing is happening yet.</em> At this point, all we’ve got is a plain-old Java object of type <code>Thread</code>. <em>It is not yet a thread of execution</em>. To get an actual thread—a new call stack—we still have to <em>start</em> the thread.</p>
<p class="indent">When a thread has been instantiated but not started (in other words, the <code>start()</code> method has not been invoked on the <code>Thread</code> instance), the thread is said to be in the <em>new</em> state. At this stage, the thread is not yet considered <em>alive.</em> Once the <span id="page_651" epub:type="pagebreak"></span><code>start()</code> method is called, the thread is considered <em>alive</em> (even though the <code>run()</code> method may not have actually started executing yet). A thread is considered <em>dead</em> (no longer <em>alive</em>) after the <code>run()</code> method completes. The <code>isAlive()</code> method is the best way to determine if a thread has been started but has not yet completed its <code>run()</code> method. (Note: The <code>getState()</code> method is very useful for debugging, but you don’t have to know it for the exam.)</p>
<h4 class="h4" id="ch10lev2sec4">Starting a Thread</h4>
<p class="noindent">You’ve created a <code>Thread</code> object and it knows its target (either the passed-in <code>Runnable</code> or itself, if you extended class <code>Thread</code>). Now it’s time to get the whole thread thing happening—to launch a new call stack. It’s so simple; it hardly deserves its own subheading:</p>
<p class="imageip"><img src="images/un651-01.jpg" alt="images" /></p>
<p class="indent">Prior to calling <code>start()</code> on a <code>Thread</code> instance, the thread (when we use lowercase <code>t</code>, we’re referring to the <em>thread of execution </em>rather than the <code>Thread</code> class) is said to be in the <em>new </em>state, as we said. The new state means you have a <code>Thread</code> <em>object</em> but you don’t yet have a <em>true thread</em>. So what happens after you call <code>start()</code>? The good stuff:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   A new thread of execution starts (with a new call stack).</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   The thread moves from the <em>new </em>state to the <em>runnable </em>state.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   When the thread gets a chance to execute, its target <code>run()</code> method will run.</p>
<p class="indent">Be <em>sure </em>you remember the following: You start a <em>Thread,</em> not a <em>Runnable.</em> You call <code>start()</code> on a <code>Thread</code> instance, not on a <code>Runnable</code> instance. The following example demonstrates what we’ve covered so far—defining, instantiating, and starting a thread:</p>
<p class="imageip"><img src="images/un651-02.jpg" alt="images" /></p>
<p class="indent"><span id="page_652" epub:type="pagebreak"></span>Running the preceding code prints out exactly what you’d expect:</p>
<p class="imageip"><img src="images/un652-01.jpg" alt="images" /></p>
<p class="indent">(If this isn’t what you expected, go back and reread everything in this objective.)</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>There’s nothing special about the <code>run()</code> method as far as Java is concerned. Like <code>main()</code>, it just happens to be the name (and signature) of the method that the new thread knows to invoke. So if you see code that calls the <code>run()</code> method on a Runnable (or even on a <code>Thread</code> instance), that’s perfectly legal. But it doesn’t mean the <code>run()</code> method will run in a separate thread! Calling a <code>run()</code> method directly just means you’re invoking a method from whatever thread is currently executing, and the <code>run()</code> method goes onto the current call stack rather than at the beginning of a new call stack. The following code does not start a new thread of execution:</em></strong></p>
<p class="noindent1"><img src="images/un652-02.jpg" alt="images" /></p>
</div>
<p class="indent">So what happens if we start multiple threads? We’ll run a simple example in a moment, but first we need to know how to print out which thread is executing. We can use the <code>getName()</code> method of class <code>Thread</code> and have each <code>Runnable</code> print out the name of the thread executing that <code>Runnable</code> object’s <code>run()</code> method. The following example instantiates a thread and gives it a name, and then the name is printed out from the <code>run()</code> method:</p>
<p class="imageip"><img src="images/un652-03.jpg" alt="images" /></p>
<p class="imageip"><span id="page_653" epub:type="pagebreak"></span><img src="images/un653-01.jpg" alt="images" /></p>
<p class="indent">Running this code produces the following extra-special output:</p>
<p class="imageip"><img src="images/un653-02.jpg" alt="images" /></p>
<p class="indent">To get the name of a thread, you call—who would have guessed—<code>getName()</code> on the <code>Thread</code> instance. But the target <code>Runnable</code> instance doesn’t even<em> have</em> a reference to the <code>Thread</code> instance, so we first invoked the <code>static Thread.currentThread()</code> method, which returns a reference to the currently executing thread, and then we invoked <code>getName()</code> on that returned reference.</p>
<p class="indent">Even if you don’t explicitly name a thread, it still has a name. Let’s look at the previous code, commenting out the statement that sets the thread’s name:</p>
<p class="imageip"><img src="images/un653-03.jpg" alt="images" /></p>
<p class="indent">Running the preceding code now gives us</p>
<p class="imageip"><img src="images/un653-04.jpg" alt="images" /></p>
<p class="indent">And since we’re getting the current thread by using the static <code>Thread.</code><em>currentThread</em><code>()</code> method, we can even get the name of the thread running our main code:</p>
<p class="imageip"><img src="images/un653-05.jpg" alt="images" /></p>
<p class="noindent">which prints out</p>
<p class="imageip"><img src="images/un653-06.jpg" alt="images" /></p>
<p class="indent">That’s right, the main thread already has a name—<em>main</em>. (Once again, what are the odds?) <a href="ch10.xhtml#ch10fig1">Figure 10-1</a> shows the process of starting a thread.</p>
<p class="figcap" id="ch10fig1"><span id="page_654" epub:type="pagebreak"></span><span class="figure"><strong>FIGURE 10-1</strong></span></p>
<p class="figcap1">Starting a thread</p>
<p class="imagef"><img src="images/fig10-01.jpg" alt="Images" /></p>
<h5 class="h5">Starting and Running Multiple Threads</h5>
<p class="noindent">Enough playing around here; let’s actually get multiple threads going (more than two, that is). We already had two threads, because the <code>main()</code> method starts in a thread of its own, and then <code>t.start()</code> started a <em>second</em> thread. Now we’ll do more. The following code creates a single <code>Runnable</code> instance and three <code>Thread</code> instances. All three <code>Thread</code> instances get the same <code>Runnable</code> instance, and each thread is given a unique name. Finally, all three threads are started by invoking <code>start()</code> on the <code>Thread</code> instances. And just to hammer in one more time how you can use a lambda expression in place of an explicit <code>Runnable</code> class, we’ll eliminate <code>NameRunnable</code>, and replace it with a lambda.</p>
<p class="imageip"><img src="images/un654-01.jpg" alt="images" /></p>
<p class="imageip"><span id="page_655" epub:type="pagebreak"></span><img src="images/un655-01.jpg" alt="images" /></p>
<p class="indent">Running this code <strong>might</strong> produce the following:</p>
<p class="imageip"><img src="images/un655-02.jpg" alt="images" /></p>
<p class="indent">Well, at least that’s what it printed when we ran it—this time, on our machine. But the behavior you see here is not guaranteed. This is so crucial that you need to stop right now, take a deep breath, and repeat after me, “The behavior is not guaranteed.” You need to know, for your future as a Java programmer as well as for the exam, that there is nothing in the Java specification that says threads will start running in the order in which they were started (in other words, the order in which <code>start()</code> was invoked on each thread). And there is no guarantee that once a thread starts executing, it will keep executing until it’s done. Or that a loop will complete before another thread begins. No siree, Bob.</p>
<p class="indent"><strong>Nothing is guaranteed in the preceding code except this:</strong></p>
<p class="indent1"><strong>Each thread will start, and each thread will run to completion.</strong></p>
<p class="indent">Within each thread, things will happen in a predictable order. But the actions of different threads can mix in unpredictable ways. If you run the program multiple <span id="page_656" epub:type="pagebreak"></span>times or on multiple machines, you may see different output. Even if you don’t see different output, you need to realize that the behavior you see is not guaranteed. Sometimes a little change in the way the program is run will cause a difference to emerge. Just for fun we bumped up the loop code so that each <code>run()</code> method ran the <code>for</code> loop 400 times rather than 3, and eventually we did start to see some wobbling:</p>
<p class="imageip"><img src="images/un656-01.jpg" alt="images" /></p>
<p class="indent">Running the preceding code, with each thread executing its run loop 400 times, started out fine but then became nonlinear. Here’s just a snippet from the command-line output of running that code. To make it easier to distinguish each thread, we put Fred’s output in italics and Lucy’s in bold and left Ricky’s alone:</p>
<p class="imageip"><img src="images/un656-02.jpg" alt="images" /></p>
<p class="noindent">…it continues on…</p>
<p class="indent">Notice that there’s not really any clear pattern here. If we look at only the output from Fred, we see the numbers increasing one at a time, as expected:</p>
<p class="imageip"><img src="images/un656-03.jpg" alt="images" /></p>
<p class="indent">And similarly, if we look only at the output from Lucy or Ricky—each one individually is behaving in a nice, orderly manner. But together—chaos! In the previous fragment we see Fred, then Lucy, then Ricky (in the same order we originally started the threads), but then Lucy butts in when it was Fred’s turn. What nerve! And then Ricky and Lucy trade back and forth for a while until finally Fred gets another chance. They jump around like this for a while after this. Eventually (after the part shown earlier), Fred finishes, then Ricky, and finally Lucy finishes with a long sequence of output. So even though Ricky was started third, he actually completed second. And if we run it again, we’ll get a different result. Why? Because <span id="page_657" epub:type="pagebreak"></span>it’s up to the scheduler, and we don’t control the scheduler! Which brings up another key point to remember: Just because a series of threads are started in a particular order doesn’t mean they’ll run in that order. For any group of started threads, order is not guaranteed by the scheduler. And duration is not guaranteed. You don’t know, for example, if one thread will run to completion before the others have a chance to get in, or whether they’ll all take turns nicely, or whether they’ll do a combination of both. There is a way, however, to start a thread but tell it not to run until some other thread has finished. You can do this with the <code>join()</code> method, which we’ll look at a little later.</p>
<p class="indent1"><strong><em>A thread is done being a thread when its target <code>run()</code> method completes.</em></strong></p>
<p class="indent">When a thread completes its <code>run()</code> method, the thread ceases to be a thread of execution. The stack for that thread dissolves, and the thread is considered dead. (Technically, the API calls a dead thread “terminated,” but we’ll use “dead” in this chapter.) Not dead and gone, however—just dead. It’s still a <code>Thread</code> <em>object,</em> just not a <em>thread of execution.</em> So if you’ve got a reference to a <code>Thread</code> instance, then even when that <code>Thread</code> instance is no longer a thread of execution, you can still call methods on the <code>Thread</code> instance, just like any other Java object. What you can’t do, though, is call <code>start()</code> again.</p>
<p class="indent1"><strong><em>Once a thread has been started, it can never be started again.</em></strong></p>
<p class="indent">If you have a reference to a <code>Thread</code> and you call <code>start()</code>, it’s started. If you call <code>start()</code> a second time, it will cause an exception (an <code>IllegalThreadStateException</code>, which is a kind of <code>RuntimeException</code>, but you don’t need to worry about the exact type). This happens whether or not the <code>run()</code> method has completed from the first <code>start()</code> call. Only a new thread can be started, and then only once. A runnable thread or a dead thread cannot be restarted.</p>
<p class="indent">So far, we’ve seen three thread states: <em>new,</em> <em>runnable, </em>and <em>dead</em>. We’ll look at more thread states before we’re done with this chapter.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>In addition to using <code>setName()</code> and <code>getName</code> to identify threads, you might see <code>getId()</code>. The <code>getId()</code> method returns a positive, unique <code>long</code> number, and that number will be that thread’s only ID number for the thread’s entire life.</em></strong></p>
</div>
<h5 class="h5"><span id="page_658" epub:type="pagebreak"></span>The Thread Scheduler</h5>
<p class="noindent">The thread scheduler is the part of the JVM (although most JVMs map Java threads directly to native threads on the underlying OS) that decides which thread should run at any given moment and also takes threads <em>out</em> of the run state. Assuming a single processor machine, only one thread can actually <em>run</em> at a time. Only one stack can ever be executing at one time. And it’s the thread scheduler that decides <em>which</em> thread—of all that are eligible—will actually <em>run</em>. When we say <em>eligible,</em> we really mean <em>in the runnable state</em>.</p>
<p class="indent">Any thread in the <em>runnable</em> state can be chosen by the scheduler to be the one and only running thread. If a thread is not in a runnable state, then it cannot be chosen to be the <em>currently running </em>thread. And just so we’re clear about how little is guaranteed here:</p>
<p class="indent1"><strong><em>The order in which runnable threads are chosen to run is not guaranteed.</em></strong></p>
<p class="indent">Although <em>queue</em> behavior is typical, it isn’t guaranteed. Queue behavior means that when a thread has finished with its “turn,” it moves to the end of the line of the runnable pool and waits until it eventually gets to the front of the line, where it can be chosen again. In fact, we call it a runnable <em>pool,</em> rather than a runnable <em>queue,</em> to help reinforce the fact that threads aren’t all lined up in some guaranteed order.</p>
<p class="indent">Although we don’t <em>control</em> the thread scheduler (we can’t, for example, tell a specific thread to run), we can sometimes influence it. The following methods give us some tools for <em>influencing</em> the scheduler. Just don’t ever mistake influence for control.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>Expect to see exam questions that look for your understanding of what is and is not guaranteed! You must be able to look at thread code and determine whether the output is guaranteed to run in a particular way or is unpredictable.</em></strong></p>
</div>
<p class="noindentt"><strong>Methods from the java.lang.Thread Class</strong>  Some of the methods that can help us influence thread scheduling are as follows:</p>
<p class="imageip"><img src="images/un658-01.jpg" alt="images" /></p>
<p class="indent">Note that both <code>sleep()</code> and <code>join()</code> have overloaded versions not shown here.</p>
<p class="noindentt"><span id="page_659" epub:type="pagebreak"></span><strong>Methods from the java.lang.Object Class</strong>  Every class in Java inherits the following three thread-related methods:</p>
<p class="imageip"><img src="images/un659-01.jpg" alt="images" /></p>
<p class="noindent">The <code>wait()</code> method has three overloaded versions (including the one listed here).</p>
<p class="indent">We’ll look at the behavior of each of these methods in this chapter. First, though, we’re going to look at the different states a thread can be in.</p>
<h3 class="h3-a" id="ch10lev1sec2"><strong>Thread States and Transitions</strong></h3>
<p class="noindent">We’ve already seen three thread states—<em>new, runnable,</em> and<em> dead</em>—but wait! There’s more! The thread scheduler’s job is to move threads in and out of the <em>running</em> state. While the thread scheduler can move a thread from the running state back to runnable, other factors can cause a thread to move out of running, but <em>not</em> back to runnable. One of these is when the thread’s <code>run()</code>method completes, in which case, the thread moves from the running state directly to the dead state. Next, we’ll look at some of the other ways in which a thread can leave the running state and where the thread goes.</p>
<h4 class="h4" id="ch10lev2sec5">Thread States</h4>
<p class="noindent">A thread can be only in one of five states (see <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>):</p>
<p class="figcap" id="ch10fig2"><span class="figure"><strong>FIGURE 10-2</strong></span></p>
<p class="figcap1">Transitioning between thread states</p>
<p class="imagef"><img src="images/fig10-02.jpg" alt="Images" /></p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>New</strong>   This is the state the thread is in after the <code>Thread</code> instance has been created but the <code>start()</code> method has not been invoked on the thread. It is a live <code>Thread</code> object, but not yet a thread of execution. At this point, the thread is considered <em>not alive</em>.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>Runnable</strong>   This is the state a thread is in when it’s eligible to run but the scheduler has not selected it to be the running thread. A thread first enters the runnable state when the <code>start()</code> method is invoked, but a thread can also return to the runnable state after either running or coming back from a blocked, waiting, or sleeping state. When the thread is in the runnable state, it is considered <em>alive</em>.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>Running</strong>   This is it. The “big time.” Where the action is. This is the state a thread is in when the thread scheduler selects it from the runnable pool to <span id="page_660" epub:type="pagebreak"></span>be the currently executing process. A thread can transition out of a running state for several reasons, including because “the thread scheduler felt like it.” We’ll look at those other reasons shortly. Note that in <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>, there are several ways to get to the runnable state, but only <em>one</em> way to get to the running state: the scheduler chooses a thread from the runnable pool.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>Waiting/blocked/sleeping</strong>   This is the state a thread is in when it’s not eligible to run. Okay, so this is really three states combined into one, but they all have one thing in common: the thread is still alive but is currently not eligible to run. In other words, it is not <em>runnable,</em> but it might <em>return</em> to a runnable state later if a particular event occurs. A thread may be <em>blocked</em> because it’s waiting for a resource (like I/O or an object’s lock), in which case the event that sends it back to runnable is the availability of the resource—for example, if data comes in through the input stream the thread code is reading from or if the object’s lock suddenly becomes available. A thread may be <em>sleeping</em> because the thread’s run code <em>tells</em> it to sleep for some period of time, in which case, the event that sends it back to runnable causes it to wake up because its sleep time has expired. Or the thread may be <em>waiting</em> because the thread’s run code <em>causes</em> it to wait. In that case, an event occurs, causing another thread to be sent a notifcation that it may no longer be necessary to wait. Then the waiting thread will become runnable again. The important point is that one thread does not <em>tell</em> another thread to block. Some methods may <em>look</em> like they tell another thread to block, but they don’t. If you have a reference <code>t</code> to another thread, you can write something like this:</p>
<p class="bull-h"><img src="images/un660-01.jpg" alt="images" /></p>
<p class="bull-h">But those are actually static methods of the <code>Thread</code> class—<em>they don’t affect the instance</em> <code>t</code>; instead, they are defined to always affect the thread that’s currently executing. (This is a good example of why it’s a bad idea to use an instance variable to access a <code>static</code> method—it’s misleading. There <em>is</em> a method, <code>suspend()</code>, in the <code>Thread</code> class that lets one thread tell another to suspend, but the <code>suspend()</code> method has been deprecated and won’t be on the exam [nor will its counterpart <code>resume()</code>].) There is also a <code>stop()</code> method, but it, too, has been deprecated and we won’t even go there. Both <code>suspend()</code> and <code>stop()</code> turned out to be very dangerous, so you shouldn’t use them, and again, because they’re deprecated, they won’t appear on the exam. Don’t study ‘em; don’t use ‘em. Note also that a thread in a blocked state is still considered <em>alive</em>.<span id="page_661" epub:type="pagebreak"></span></p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>Dead</strong> A thread is considered dead when its <code>run()</code> method completes. It may still be a viable <code>Thread</code> object, but it is no longer a separate thread of execution. Once a thread is dead, it can never be brought back to life! (The whole “I see dead threads” thing.) If you invoke <code>start()</code> on a dead <code>Thread</code> instance, you’ll get an exception at runtime. And it probably doesn’t take a rocket scientist to tell you that if a thread is dead, it is no longer considered <em>alive</em>.</p>
<h4 class="h4" id="ch10lev2sec6">Preventing Thread Execution</h4>
<p class="noindent">A thread that’s been stopped usually means a thread that’s moved to the dead state. But you also need to be able to recognize when a thread will get kicked out of running but <em>not</em> be sent back to either runnable or dead.</p>
<p class="indent">For the purpose of the exam, we aren’t concerned with a thread blocking on I/O (say, waiting for something to arrive from an input stream from the server). We <em>are</em> concerned with the following:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Sleeping</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Waiting</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Blocked because it needs an object’s lock</p>
<h4 class="h4" id="ch10lev2sec7">Sleeping</h4>
<p class="noindent">The <code>sleep()</code> method is a <code>static</code> method of class <code>Thread</code>. You use it in your code to “slow a thread down” by forcing it to go into a sleep mode before coming back to runnable (where it still has to beg to be the currently running thread). When a thread sleeps, it drifts off somewhere and doesn’t return to runnable until it wakes up.</p>
<p class="indent"><span id="page_662" epub:type="pagebreak"></span>So why would you want a thread to sleep? Well, you might think the thread is moving too quickly through its code. Or you might need to force your threads to take turns, since reasonable turn-taking isn’t guaranteed in the Java specification. Or imagine a thread that runs in a loop, downloading the latest stock prices and analyzing them. Downloading prices one after another would be a waste of time, as most would be quite similar—and even more important, it would be an incredible waste of precious bandwidth. The simplest way to solve this is to cause a thread to pause (sleep) for five minutes after each download.</p>
<p class="indent">You do this by invoking the static <code>Thread.sleep()</code> method, giving it a time in milliseconds as follows:</p>
<p class="imageip"><img src="images/un662-01.jpg" alt="images" /></p>
<p class="indent">Notice that the <code>sleep()</code> method can throw a checked <code>InterruptedException</code> (you’ll usually know if that is a possibility because another thread has to explicitly do the interrupting), so you must acknowledge the exception with a handle or declare. Typically, you wrap calls to <code>sleep()</code> in a <code>try/catch</code>, as in the preceding code.</p>
<p class="indent">Let’s modify our Fred, Lucy, Ricky code by using <code>sleep()</code> to <em>try</em> to force the threads to alternate rather than letting one thread dominate for any period of time. Where do you think the call to the <code>sleep()</code> method should go?</p>
<p class="imageip"><img src="images/un662-02.jpg" alt="images" /></p>
<p class="imageip"><span id="page_663" epub:type="pagebreak"></span><img src="images/un663-01.jpg" alt="images" /></p>
<p class="indent">Running this code shows Fred, Lucy, and Ricky alternating nicely:</p>
<p class="imageip"><img src="images/un663-02.jpg" alt="images" /></p>
<p class="indent">Just keep in mind that the behavior in the preceding output is still not guaranteed. You can’t be certain how long a thread will actually run <em>before</em> it gets put to sleep, so you can’t know with certainty that only one of the three threads will be in the runnable state when the running thread goes to sleep. In other words, if two threads are awake and in the runnable pool, you can’t know with certainty that the least recently used thread will be the one selected to run. <em>Still, using</em> <em>sleep()</em> <em>is the best way to help all threads get a chance to run! </em>Or at least to guarantee that one thread doesn’t get in and stay until it’s done. When a thread encounters a sleep call, it <em>must</em> go to sleep for <em>at least</em> the specified number of milliseconds (unless it is interrupted before its wake-up time, in which case, it immediately throws the <code>InterruptedException</code>).</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>Just because a thread’s <code>sleep()</code> expires and it wakes up does not mean it will return to running! Remember, when a thread wakes up, it simply goes back to the runnable state. So the time specified in <code>sleep()</code> is the minimum duration in which the thread won’t run, but it is not the exact duration in which the thread won’t run. So you can’t, for example, rely on the <code>sleep()</code> method to give you a perfectly accurate timer. Although in many applications using <code>sleep()</code> as a timer is certainly good enough, you must know that a <code>sleep()</code> time is not a guarantee that the thread will start running again as soon as the time expires and the thread wakes.</em></strong></p>
</div>
<p class="indent"><span id="page_664" epub:type="pagebreak"></span>Remember that <code>sleep()</code> is a static method, so don’t be fooled into thinking that one thread can put another thread to sleep. You can put <code>sleep()</code> code anywhere since <em>all</em> code is being run by <em>some</em> thread. When the executing code (meaning the currently running thread’s code) hits a <code>sleep()</code> call, it puts the currently running thread to sleep.</p>
<p class="head-h" id="ch10exe1"><span class="white1">EXERCISE 10-1</span></p>
<p class="border"></p>
<h4 class="h4"><strong>Creating a Thread and Putting It to Sleep</strong></h4>
<p class="noindent">In this exercise, we will create a simple counting thread. It will count to 100, pausing one second between each number. Also, in keeping with the counting theme, it will output a string every ten numbers.</p>
<p class="numlist">1.   Create a class and extend the <code>Thread</code> class. As an option, you can implement the <code>Runnable</code> interface.</p>
<p class="numlist">2.   Override the <code>run()</code> method of <code>Thread</code>. This is where the code will go that will output the numbers.</p>
<p class="numlist">3.   Create a <code>for</code> loop that will loop 100 times. Use the modulus operation to check whether there are any remainder numbers when divided by 10.</p>
<p class="numlist">4.   Use the static method <code>Thread.sleep()</code> to pause. (Remember, the one-arg version of <code>sleep()</code> specifies the amount of time of sleep in milliseconds.)</p>
<p class="hr"></p>
<h4 class="h4" id="ch10lev2sec8">Thread Priorities and yield( )</h4>
<p class="noindent">To understand <code>yield()</code>, you must understand the concept of thread <em>priorities.</em> Threads always run with some priority, usually represented as a number between 1 and 10 (although in some cases, the range is less than 10). The scheduler in most JVMs uses preemptive, priority-based scheduling (which implies some sort of time slicing). <em>This does not mean that all JVMs use time slicing.</em> The JVM specification does not require a VM to implement a time-slicing scheduler, where each thread is allocated a fair amount of time and then sent back to runnable to give another thread a chance. Although many JVMs do use time slicing, some may use a scheduler that lets one thread stay running until the thread completes its <code>run()</code> method.</p>
<p class="indent"><span id="page_665" epub:type="pagebreak"></span>In most JVMs, however, the scheduler does use thread priorities in one important way: If a thread enters the runnable state and it has a higher priority than any of the threads in the pool and a higher priority than the currently running thread, <em>the lower-priority running thread usually will be bumped back to runnable and the highest-priority thread will be chosen to run.</em> In other words, at any given time, the currently running thread usually will not have a priority that is lower than any of the threads in the pool. <em>In most cases, the running thread will be of equal or greater priority than the highest-priority threads in the pool.</em> This is as close to a guarantee about scheduling as you’ll get from the JVM specification, so you must never rely on thread priorities to guarantee the correct behavior of your program.</p>
<p class="text-icon"><img src="images/onjob.jpg" alt="Images" /></p>
<p class="noindent"><strong><em>Don’t rely on thread priorities when designing your multithreaded application. Because thread-scheduling priority behavior is not guaranteed, it’s better to avoid modifying thread priorities. Usually, default priority will be fine.</em></strong></p>
<p class="indentt">What is also <em>not</em> guaranteed is the behavior when threads in the pool are of equal priority or when the currently running thread has the same priority as threads in the pool. All priorities being equal, a JVM implementation of the scheduler is free to do just about anything it likes. That means a scheduler might do one of the following (among other things):</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Pick a thread to run, and run it there until it blocks or completes.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   Time-slice the threads in the pool to give everyone an equal opportunity to run.</p>
<h5 class="h5">Setting a Thread’s Priority</h5>
<p class="noindent">A thread gets a default priority that is <em>the priority of the thread of execution that creates it. </em>For example, in the code</p>
<p class="imageip"><img src="images/un665-01.jpg" alt="images" /></p>
<p class="noindent">the thread referenced by <code>t</code> will have the same priority as the <em>main</em> thread because the main thread is executing the code that creates the <code>MyThread</code> instance.</p>
<p class="indent"><span id="page_666" epub:type="pagebreak"></span>You can also set a thread’s priority directly by calling the <code>setPriority()</code> method on a <code>Thread</code> instance, as follows:</p>
<p class="imageip"><img src="images/un666-01.jpg" alt="images" /></p>
<p class="indent">Priorities are set using a positive integer, usually between 1 and 10, and the JVM will never change a thread’s priority. However, values 1 through 10 are not guaranteed. Some JVMs might not recognize 10 distinct values. Such a JVM might merge values from 1 to 10 down to maybe values from 1 to 5, so if you have, say, 10 threads, each with a different priority, and the current application is running in a JVM that allocates a range of only 5 priorities, then 2 or more threads might be mapped to one priority.</p>
<p class="indent">Although <em>the default priority is 5</em>, the <code>Thread</code> class has the three following constants (<code>static final</code> variables) that define the range of thread priorities:</p>
<p class="imageip"><img src="images/un666-02.jpg" alt="images" /></p>
<h5 class="h5">The yield( ) Method</h5>
<p class="noindent">So what does the <code>static Thread.yield()</code> have to do with all this? Not that much, in practice. What <code>yield()</code> is <em>supposed</em> to do is make the currently running thread head back to runnable to allow other threads of the same priority to get their turn. So the intention is to use <code>yield()</code> to promote graceful turn-taking among equal-priority threads. In reality, though, the <code>yield()</code> method isn’t guaranteed to do what it claims, and even if <code>yield()</code> does cause a thread to step out of running and back to runnable, <em>there’s no guarantee the yielding thread won’t just be chosen again over all the others!</em> So while <code>yield()</code> might—and often does—make a running thread give up its slot to another runnable thread of the same priority, there’s no guarantee.</p>
<p class="indent">A <code>yield()</code> won’t ever cause a thread to go to the waiting/sleeping/blocking state. At most, a <code>yield()</code> will cause a thread to go from running to runnable, but again, it might have no effect at all.</p>
<h5 class="h5">The join( ) Method</h5>
<p class="noindent">The non-<code>static join()</code> method of class <code>Thread</code> lets one thread “join onto the end” of another thread. If you have a thread B that can’t do its work until another thread A has completed <em>its</em> work, then you want thread B to “join” thread A. <span id="page_667" epub:type="pagebreak"></span>This means that thread B will not become runnable until A has finished (and entered the dead state).</p>
<p class="imageip"><img src="images/un667-01.jpg" alt="images" /></p>
<p class="indent">The preceding code takes the currently running thread (if this were in the <code>main()</code> method, then that would be the main thread) and <em>joins</em> it to the end of the thread referenced by <code>t</code>. This blocks the current thread from becoming runnable until after the thread referenced by <code>t</code> is no longer alive. In other words, the code <code>t.join()</code> means “Join me (the current thread) to the end of <code>t</code>, so that <code>t</code> must finish before I (the current thread) can run again.” You can also call one of the overloaded versions of <code>join()</code> that takes a timeout duration so that you’re saying, “Wait until thread <code>t</code> is done, but if it takes longer than 5,000 milliseconds, then stop waiting and become runnable anyway.” <a href="ch10.xhtml#ch10fig3">Figure 10-3</a> shows the effect of the <code>join()</code> method.</p>
<p class="figcap" id="ch10fig3"><span class="figure"><strong>FIGURE 10-3</strong></span></p>
<p class="figcap1">The <code>join()</code> method</p>
<p class="imagef"><img src="images/fig10-03.jpg" alt="Images" /></p>
<p class="indent"><span id="page_668" epub:type="pagebreak"></span>So far, we’ve looked at three ways a running thread could leave the running state:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>A call to <code>sleep()</code></strong>   Guaranteed to cause the current thread to stop executing for at least the specified sleep duration (although it might be <em>interrupted</em> before its specified time).</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>A call to <code>yield()</code></strong>   Not guaranteed to do much of anything, although typically, it will cause the currently running thread to move back to runnable so that a thread of the same priority can have a chance.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>A call to <code>join()</code></strong>   Guaranteed to cause the current thread to stop executing until the thread it joins with (in other words, the thread it calls <code>join()</code> on) completes, or if the thread it’s trying to join with is not alive, the current thread won’t need to back out.</p>
<p class="indent">Besides those three, we also have the following scenarios in which a thread might leave the running state:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   The thread’s <code>run()</code> method completes. Duh.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   A call to <code>wait()</code> on an object (we don’t call <code>wait()</code> on a <em>thread,</em> as we’ll see in a moment).</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   A thread can’t acquire the <em>lock</em> on the object whose method code it’s attempting to run.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   The thread scheduler can decide to move the current thread from running to runnable in order to give another thread a chance to run. No reason is needed—the thread scheduler can trade threads in and out whenever it likes.</p>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch10lev1sec3"><strong>Synchronizing Code, Thread Problems (OCP Objectives 10.2 and 10.3)</strong></h3>
<p class="noindent"><em>10.2   Identify potential threading problems among deadlock, starvation, livelock, and race conditions.</em></p>
<p class="noindent"><em>10.3   Use synchronized keyword and java.util.concurrent.atomic package to control the order of thread execution.</em></p>
<p class="indentt">Can you imagine the havoc that can occur when two different threads have access to a single instance of a class, and both threads invoke methods on that <span id="page_669" epub:type="pagebreak"></span>object…and those methods modify the state of the object? In other words, what might happen if <em>two</em> different threads call, say, a setter method on a <em>single</em> object? A scenario like that might corrupt an object’s state by changing its instance variable values in an inconsistent way, and if that object’s state is data shared by other parts of the program, well, it’s too scary to even visualize.</p>
<p class="indent">But just because we enjoy horror, let’s look at an example of what might happen. The following code demonstrates what happens when two different threads are accessing the same account data. Imagine that two people each have a checkbook for a single checking account (or two people each have ATM cards, but both cards are linked to only one account).</p>
<p class="indent">In this example, we have a class called Account that represents a bank account. To keep the code short, this account starts with a balance of 50 and can be used only for withdrawals. The withdrawal will be accepted even if there isn’t enough money in the account to cover it. The account simply reduces the balance by the amount you want to withdraw:</p>
<p class="imageip"><img src="images/un669-01.jpg" alt="images" /></p>
<p class="indent">Now here’s where it starts to get fun. Imagine a couple, Fred and Lucy, who both have access to the account and want to make withdrawals. But they don’t want the account to ever be overdrawn, so just before one of them makes a withdrawal, he or she will first check the balance to be certain there’s enough to 670cover the withdrawal. Also, withdrawals are always limited to an amount of 10, so there must be at least 10 in the account balance in order to make a withdrawal. Sounds reasonable. But that’s a two-step process:</p>
<p class="numlistt">1.   Check the balance.</p>
<p class="numlistb">2.   If there’s enough in the account (in this example, at least 10), make the withdrawal.</p>
<p class="indent">What happens if something separates step 1 from step 2? For example, imagine what would happen if Lucy checks the balance and sees there’s just exactly enough in the account, 10. <em>But before she makes the withdrawal, Fred checks the balance and also sees that there’s enough for his withdrawal.</em> Since Lucy has verified the balance but not yet made her withdrawal, Fred is seeing “bad data.” He is seeing the account balance <em>before</em> Lucy actually debits the account, but at this point, that debit <span id="page_670" epub:type="pagebreak"></span>is certain to occur. Now both Lucy and Fred believe there’s enough to make their withdrawals. Now imagine that Lucy makes <em>her</em> withdrawal, so there isn’t enough in the account for Fred’s withdrawal, but he thinks there is because when he checked, there was enough! Yikes. In a minute, we’ll see the actual banking code, with Fred and Lucy, represented by two threads, each acting on the same <code>Runnable</code>, and that <code>Runnable</code> holds a reference to the one and only account instance—so, two threads, one account.</p>
<p class="indent">The logic in our code example is as follows:</p>
<p class="numlistt">1.   The <code>Runnable</code> object holds a reference to a single account.</p>
<p class="numlist">2.   Two threads are started, representing Lucy and Fred, and each thread is given a reference to the same <code>Runnable</code> (which holds a reference to the actual account).</p>
<p class="numlist">3.   The initial balance on the account is 50, and each withdrawal is exactly 10.</p>
<p class="numlist">4.   In the <code>run()</code> method, we loop five times, and in each loop we</p>
<p class="num-bull"><img class="inline" src="images/box.jpg" alt="Images" />   Make a withdrawal (if there’s enough in the account).</p>
<p class="num-bull"><img class="inline" src="images/box.jpg" alt="Images" />   Print a statement <em>if the account is overdrawn</em> (which it should never be since we check the balance <em>before</em> making a withdrawal).</p>
<p class="numlist">5.   The <code>makeWithdrawal()</code> method in the test class (representing the behavior of Fred or Lucy) will do the following:</p>
<p class="num-bull"><img class="inline" src="images/box.jpg" alt="Images" />   Check the balance to see if there’s enough for the withdrawal.</p>
<p class="num-bull"><img class="inline" src="images/box.jpg" alt="Images" />   If there is enough, print out the name of the one making the withdrawal.</p>
<p class="num-bull"><img class="inline" src="images/box.jpg" alt="Images" />   Go to sleep for 500 milliseconds—just long enough to give the other partner a chance to get in before you actually <em>make</em> the withdrawal.</p>
<p class="num-bull"><img class="inline" src="images/box.jpg" alt="Images" />   Upon waking up, complete the withdrawal and print that fact.</p>
<p class="num-bull"><img class="inline" src="images/box.jpg" alt="Images" />   If there wasn’t enough in the first place, print a statement showing who you are and the fact that there wasn’t enough.</p>
<p class="indentt">So what we’re really trying to discover is if the following is possible: for one partner to check the account and see that there’s enough, but before making the actual withdrawal, the other partner checks the account and <em>also</em> sees that there’s enough. When the account balance gets to 10, if both partners check it before making the withdrawal, both will think it’s okay to withdraw, and the account will be overdrawn by 10!</p>
<p class="indent"><span id="page_671" epub:type="pagebreak"></span>Here’s the code:</p>
<p class="imageip"><img src="images/un671-01.jpg" alt="images" /></p>
<p class="indent">(Note: You might have to tweak this code a bit on your machine to the “account overdrawn” behavior. You might try much shorter sleep times; you might try adding a <code>sleep</code> to the <code>run()</code> method... In any case, experimenting will help you lock in the concepts.) So what happened? Is it possible that, say, Lucy checked the balance, fell asleep, Fred checked the balance, Lucy woke up and completed <em>her</em> withdrawal, then Fred completes <em>his</em> withdrawal, and in the end, they overdraw the account? Look at the (numbered) output:</p>
<p class="imageip"><img src="images/un671-02.jpg" alt="images" /></p>
<p class="imageip"><span id="page_672" epub:type="pagebreak"></span><img src="images/un672-01.jpg" alt="images" /></p>
<p class="indent">Although each time you run this code the output might be a little different, let’s walk through this particular example using the numbered lines of output. For the first four attempts, everything is fine. Fred checks the balance on line 1 and finds it’s okay. At line 2, Lucy checks the balance and finds it okay. At line 3, Fred makes his withdrawal. At this point, the balance Lucy checked for (and believes is still accurate) has actually changed since she last checked. And now Fred checks the balance <em>again,</em> before Lucy even completes her first withdrawal. By this point, even Fred is seeing a potentially inaccurate balance because we know Lucy is going to complete her withdrawal. It is possible, of course, that Fred will complete his before Lucy does, but that’s not what happens here.</p>
<p class="indent">On line 5, Lucy completes her withdrawal and then, before Fred completes his, Lucy does another check on the account on line 6. And so it continues until we get to line 8, where Fred checks the balance and sees that it’s 20. On line 9, Lucy completes a withdrawal that she had checked for earlier, and this takes the balance to 10. On line 10, Lucy checks again, sees that the balance is 10, so she knows she can do a withdrawal. <em>But she didn’t know that Fred, too, has already checked the balance on line 8 so he thinks it’s safe to do the withdrawal! </em>On line 11, Fred completes the withdrawal he approved on line 8. This takes the balance to 0. But Lucy still has a pending withdrawal that she got approval for on line 10! You know what’s coming.</p>
<p class="indent">On lines 12 and 13, Fred checks the balance and finds that there’s not enough in the account. But on line 14, Lucy completes her withdrawal and BOOM! The account is now overdrawn by 10—<em>something we thought we were preventing by doing a balance check prior to a withdrawal.</em></p>
<p class="indent"><a href="ch10.xhtml#ch10fig4">Figure 10-4</a> shows the timeline of what can happen when two threads concurrently access the same object.</p>
<p class="figcap" id="ch10fig4"><span class="figure"><strong>FIGURE 10-4</strong></span></p>
<p class="figcap1">Problems with concurrent access</p>
<p class="imagef"><img src="images/fig10-04.jpg" alt="Images" /></p>
<p class="indent">This problem is known as a “race condition,” where multiple threads can access the same resource (typically an object’s instance variables) and can produce <span id="page_673" epub:type="pagebreak"></span>corrupted data if one thread “races in” too quickly before an operation that should be “atomic” has completed.</p>
<h4 class="h4" id="ch10lev2sec9">Preventing the Account Overdraw</h4>
<p class="noindent">So what can be done? The solution is actually quite simple. We must guarantee that the two steps of the withdrawal—<em>checking</em> the balance and <em>making</em> the withdrawal—are never split apart. We need them to always be performed as one operation, even when the thread falls asleep in between step 1 and step 2! We call this an “atomic operation” (although the physics is a little outdated—in this case, “atomic” means “indivisible“) because the operation, regardless of the number of actual statements (or underlying bytecode instructions), is completed <em>before</em> any other thread code that acts on the same data.</p>
<p class="indent">You can’t guarantee that a single thread will stay running throughout the entire atomic operation. But you can guarantee that even if the thread running the atomic operation moves in and out of the running state, no other running thread will be able to act on the same data. In other words, if Lucy falls asleep after checking the balance, we can stop Fred from checking the balance until after Lucy wakes up and completes her withdrawal.</p>
<p class="indent">So how do you protect the data? You must do two things:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Mark the variables <code>private</code>.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   Synchronize the code that modifies the variables.</p>
<p class="indent">Remember, you protect the variables in the normal way—using an access control modifier. It’s the method code that you must protect so only one thread at a time can be executing that code. You do this with the <code>synchronized</code> keyword.</p>
<p class="indent"><span id="page_674" epub:type="pagebreak"></span>We can solve all of Fred and Lucy’s problems by adding one word to the code. We mark the <code>makeWithdrawal()</code> method <code>synchronized</code> as follows:</p>
<p class="imageip"><img src="images/un674-01.jpg" alt="images" /></p>
<p class="indent">Now we’ve guaranteed that once a thread (Lucy or Fred) starts the withdrawal process by invoking <code>makeWithdrawal()</code>, the other thread cannot enter that method until the first one completes the process by exiting the method. The new output shows the benefit of synchronizing the <code>makeWithdrawal()</code> method:</p>
<p class="imageip"><img src="images/un674-02.jpg" alt="images" /></p>
<p class="indent">Notice that now both threads, Lucy and Fred, always check the account balance <em>and</em> complete the withdrawal before the other thread can check the balance.</p>
<h4 class="h4" id="ch10lev2sec10">Synchronization and Locks</h4>
<p class="noindent">How does synchronization work? With locks. Every object in Java has a built-in lock that only comes into play when the object has synchronized method code. When we enter a synchronized non-<code>static</code> method, we automatically acquire the lock <span id="page_675" epub:type="pagebreak"></span>associated with the current instance of the class whose code we’re executing (the <code>this</code> instance). Acquiring a lock for an object is also known as getting the lock, or locking the object, locking <em>on</em> the object, or synchronizing on the object. We may also use the term <em>monitor</em> to refer to the object whose lock we’re acquiring. Technically, the lock and the monitor are two different things, but most people talk about the two interchangeably, and we will too.</p>
<p class="indent">Since there is only one lock per object, if one thread has picked up the lock, no other thread can pick up the lock until the first thread releases (or returns) the lock. This means no other thread can enter the synchronized code (which means it can’t enter any <code>synchronized</code> method of that object) until the lock has been released. Typically, releasing a lock means the thread holding the lock (in other words, the thread currently in the <code>synchronized</code> method) exits the <code>synchronized</code> method. At that point, the lock is free until some other thread enters a <code>synchronized</code> method on that object. Remember the following key points about locking and synchronization:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Only methods (or blocks) can be <code>synchronized</code>, not variables or classes.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Each object has just one lock.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Not all methods in a class need to be <code>synchronized</code>. A class can have both <code>synchronized</code> and non-<code>synchronized</code> methods.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   If two threads are about to execute a <code>synchronized</code> method in a class and both threads are using the same instance of the class to invoke the method, only one thread at a time will be able to execute the method. The other thread will need to wait until the first one finishes its method call. In other words, once a thread acquires the lock on an object, no other thread can enter any of the <code>synchronized</code> methods in that class (for that object).</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   If a class has both <code>synchronized</code> and non-<code>synchronized</code> methods, multiple threads can still access the class’s non-<code>synchronized</code> methods! If you have methods that don’t access the data you’re trying to protect, then you don’t need to synchronize them. Synchronization can cause a hit in some cases (or even deadlock if used incorrectly), so you should be careful not to overuse it.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   If a thread goes to sleep, it holds any locks it has—it doesn’t release them.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   A thread can acquire more than one lock. For example, a thread can enter a <code>synchronized</code> method, thus acquiring a lock, and then immediately invoke a <code>synchronized</code> method on a different object, thus acquiring that lock as well. As the stack unwinds, locks are released again. Also, if a thread acquires a lock and then attempts to call a <code>synchronized</code> method on <span id="page_676" epub:type="pagebreak"></span>that same object, no problem. The JVM knows that this thread already has the lock for this object, so the thread is free to call other <code>synchronized</code> methods on the same object, using the lock the thread already has.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   You can synchronize a block of code rather than a method.</p>
<p class="indent">Because synchronization does hurt concurrency, you don’t want to synchronize any more code than is necessary to protect your data. So if the scope of a method is more than needed, you can reduce the scope of the synchronized part to something less than a full method—to just a block. We call this, strangely, a <em>synchronized block,</em> and it looks like this:</p>
<p class="imageip"><img src="images/un676-01.jpg" alt="images" /></p>
<p class="indent">When a thread is executing code from within a <code>synchronized</code> block, including any method code invoked from that <code>synchronized</code> block, the code is said to be executing in a synchronized context. The real question is, synchronized on what? Or, synchronized on which object’s lock?</p>
<p class="indent">When you synchronize a method, the object used to invoke the method is the object whose lock must be acquired. But when you synchronize a block of code, you specify which object’s lock you want to use as the lock, so you could, for 677example, use some third-party object as the lock for this piece of code. That gives you the ability to have more than one lock for code synchronization within a single object.</p>
<p class="indent">Or you can synchronize on the current instance (<code>this</code>) as in the previous code. Since that’s the same instance that <code>synchronized</code> methods lock on, it means you could always replace a <code>synchronized</code> method with a non-<code>synchronized</code> method containing a <code>synchronized</code> block. In other words, this:</p>
<p class="imageip"><img src="images/un676-02.jpg" alt="images" /></p>
<p class="noindent">is equivalent to this:</p>
<p class="imageip"><img src="images/un676-03.jpg" alt="images" /></p>
<p class="indent"><span id="page_677" epub:type="pagebreak"></span>These methods both have the exact same effect—in practical terms. The compiled bytecodes may not be exactly the same for the two methods, but they <em>could</em> be—and any differences are not really important. The first form is shorter and more familiar to most people, but the second can be more flexible.</p>
<h5 class="h5">Can Static Methods Be Synchronized?</h5>
<p class="noindent"><code>static</code> methods can be <code>synchronized</code>. There is only one copy of the static data you’re trying to protect, so you only need one lock per class to synchronize <code>static</code> methods—a lock for the whole class. There is such a lock; every class loaded in Java has a corresponding instance of <code>java.lang.Class</code> representing that class. It’s that <code>java.lang.Class</code> instance whose lock is used to protect any synchronized <code>static</code> methods of the class. There’s nothing special you have to do to synchronize a <code>static</code> method:</p>
<p class="imageip"><img src="images/un677-01.jpg" alt="images" /></p>
<p class="indent">Again, this could be replaced with code that uses a <code>synchronized</code> block. If the method is defined in a class called <code>MyClass</code>, the equivalent code is as follows:</p>
<p class="imageip"><img src="images/un677-02.jpg" alt="images" /></p>
<p class="indent">Wait—what’s that <code>MyClass.class</code> thing? That’s called a <em>class literal.</em> It’s a special feature in the Java language that tells the compiler (who tells the JVM): Go and find me the instance of <code>Class</code> that represents the class called <code>MyClass</code>. You can also do this with the following code:</p>
<p class="imageip"><img src="images/un677-03.jpg" alt="images" /></p>
<p class="indent">However, that’s longer, ickier, and most importantly, <em>not on the OCP exam</em>. But it’s quick and easy to use a class literal—just write the name of the class and add <code>.class</code> at the end. No quotation marks needed. Now you’ve got an expression for the <code>Class</code> object you need to synchronize on.</p>
<p class="head-h" id="ch10exe2"><span id="page_678" epub:type="pagebreak"></span><span class="white1">EXERCISE 10-2</span></p>
<p class="border"></p>
<h4 class="h4"><strong>Synchronizing a Block of Code</strong></h4>
<p class="noindent">In this exercise, we will attempt to synchronize a block of code. Within that block of code, we will get the lock on an object so that other threads cannot modify it while the block of code is executing. We will be creating three threads that will all attempt to manipulate the same object. Each thread will output a single letter 100 times and then increment that letter by one. The object we will be using is <code>StringBuffer</code>.</p>
<p class="indent">We could synchronize on a <code>String</code> object, but strings cannot be modified once they are created, so we would not be able to increment the letter without generating a new <code>String</code> object. The final output should have 100 <em>A</em>s, 100 <em>B</em>s, and 100 <em>C</em>s, all in unbroken lines.</p>
<p class="numlist">1.   Create a class and extend the <code>Thread</code> class.</p>
<p class="numlist">2.   Override the <code>run()</code> method of <code>Thread</code>. This is where the <code>synchronized</code> block of code will go.</p>
<p class="numlist">3.   For our three thread objects to share the same object, we will need to create a constructor that accepts a <code>StringBuffer</code> object in the argument.</p>
<p class="numlist">4.   The <code>synchronized</code> block of code will obtain a lock on the <code>StringBuffer</code> object from step 3.</p>
<p class="numlist">5.   Within the block, output the <code>StringBuffer</code> 100 times and then increment the letter in the <code>StringBuffer</code>.</p>
<p class="numlist">6.   Finally, in the <code>main()</code> method, create a single <code>StringBuffer</code> object using the letter <em>A,</em> then create three instances of our class and start all three of them.</p>
<hr/>
<h5 class="h5">What Happens If a Thread Can’t Get the Lock?</h5>
<p class="noindent">If a thread tries to enter a <code>synchronized</code> method and the lock is already taken, the thread is said to be blocked on the object’s lock. Essentially, the thread goes into a kind of pool for that particular object and has to sit there until the lock is released and the thread can again become runnable/running. Just because a lock is released doesn’t mean any particular thread will get it. There might be three threads waiting for a single lock, for example, and there’s no guarantee that the thread that has waited the longest will get the lock first.</p>
<p class="indent"><span id="page_679" epub:type="pagebreak"></span>When thinking about blocking, it’s important to pay attention to which objects are being used for locking:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Threads calling non-<code>static synchronized</code> methods in the same class will only block each other if they’re invoked using the same instance. That’s because they each lock on <code>this</code> instance, and if they’re called using two different instances, they get two locks, which do not interfere with each other.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Threads calling <code>static synchronized</code> methods in the same class will always block each other—they all lock on the same <code>Class</code> instance.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   A <code>static synchronized</code> method and a non-<code>static synchronized</code> method will not block each other, ever. The <code>static</code> method locks on a <code>Class</code> instance, while the non-<code>static</code> method locks on the <code>this</code> instance—these actions do not interfere with each other at all.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   For <code>synchronized</code> blocks, you have to look at exactly what object has been used for locking. (What’s inside the parentheses after the word <code>synchronized</code>?) Threads that synchronize on the same object will block each other. Threads that synchronize on different objects will not.</p>
<p class="indent"><a href="ch10.xhtml#ch10tab1">Table 10-1</a> lists the thread-related methods and whether the thread gives up its lock as a result of the call.</p>
<h5 class="h5">So When Do I Need to Synchronize?</h5>
<p class="tabcap" id="ch10tab1"><span class="table"><strong>TABLE 10-1</strong></span></p>
<p class="tabcap1">Methods and Lock Status</p>
<p class="imaget"><img src="images/tab10-01.jpg" alt="Images" /></p>
<p class="noindent">Synchronization can get pretty complicated, and you may be wondering why you would want to do this at all if you can help it. But remember the earlier “race conditions” example with Lucy and Fred making withdrawals from their account. <span id="page_680" epub:type="pagebreak"></span>When we use threads, we usually need to use some synchronization somewhere to make sure our methods don’t interrupt each other at the wrong time and mess up our data. Generally, any time more than one thread is accessing mutable (changeable) data, you synchronize to protect that data to make sure two threads aren’t changing it at the same time (or that one isn’t changing it at the same time the other is reading it, which is also confusing). You don’t need to worry about local variables—each thread gets its own copy of a local variable. Two threads executing the same method at the same time will use different copies of the local variables, and they won’t bother each other. However, you do need to worry about <code>static</code> and non-<code>static</code> fields if they contain data that can be changed.</p>
<p class="indent">For changeable data in a non-<code>static</code> field, you usually use a non-<code>static</code> method to access it. By synchronizing that method, you will ensure that any threads trying to run that method <em>using the same instance</em> will be prevented from simultaneous access. But a thread working with a <em>different</em> instance will not be affected because it’s acquiring a lock on the other instance. That’s what we want—threads working with the same data need to go one at a time, but threads working with different data can just ignore each other and run whenever they want to; it doesn’t matter.</p>
<p class="indent">For changeable data in a <code>static</code> field, you usually use a <code>static</code> method to access it. And again, by synchronizing the method, you ensure that any two threads trying to access the data will be prevented from simultaneous access, because both threads will have to acquire locks on the <code>Class</code> object for the class the <code>static</code> method’s defined in. Again, that’s what we want.</p>
<p class="indent">However—what if you have a non-<code>static</code> method that accesses a <code>static</code> field? Or a <code>static</code> method that accesses a non-<code>static</code> field (using an instance)? In these cases, things start to get messy quickly, and there’s a very good chance that things will not work the way you want. If you’ve got a <code>static</code> method accessing a non-<code>static</code> field and you synchronize the method, you acquire a lock on the Class object. But what if there’s another method that also accesses the non-<code>static</code> field, this time using a non-<code>static</code> method? It probably synchronizes on the current instance (<code>this</code>) instead. Remember that a <code>static synchronized</code> method and a non-<code>static synchronized</code> method will not block each other—they can run at the same time. Similarly, if you access a <code>static</code> field using a non-<code>static</code> method, two threads might invoke that method using two different <code>this</code> instances. Which means they won’t block each other because they use different locks. Which means two threads are simultaneously accessing the same <code>static</code> field—exactly the sort of thing we’re trying to prevent.</p>
<p class="indent"><span id="page_681" epub:type="pagebreak"></span>It gets very confusing trying to imagine all the weird things that can happen here. To keep things simple, in order to make a class thread-safe, methods that access changeable fields need to be <code>synchronized</code>.</p>
<p class="indent">Access to <code>static</code> fields should be done using <code>static synchronized</code> methods. Access to non-<code>static</code> fields should be done using non-<code>static synchronized</code> methods, for example:</p>
<p class="imageip"><img src="images/un681-01.jpg" alt="images" /></p>
<p class="indent">What if you need to access both <code>static</code> and <code>non-static</code> fields in a method? Well, there are ways to do that, but it’s beyond what you need for the exam. You will live a longer, happier life if you JUST DON’T DO IT. Really. Would we lie?</p>
<h5 class="h5">Thread-Safe Classes</h5>
<p class="noindent">When a class has been carefully synchronized to protect its data (using the rules just given or using more complicated alternatives), we say the class is “thread-safe.” Many classes in the Java APIs already use synchronization internally in order to make the class “thread-safe.” For example, <code>StringBuffer</code> and <code>StringBuilder</code> are nearly identical classes, except that all the methods in <code>StringBuffer</code> are <code>synchronized</code> when necessary, whereas those in <code>StringBuilder</code> are not. Generally, this makes <code>StringBuffer</code> safe to use in a multithreaded environment, whereas <code>StringBuilder</code> is not. (In return, <code>StringBuilder</code> is a little bit faster because it doesn’t bother synchronizing.) However, even when a class is “thread-safe,” it is often dangerous to rely on these classes to provide the thread protection you need. (C’mon, the repeated quotes used around “thread-safe” had to be a clue, right?) <span id="page_682" epub:type="pagebreak"></span>You still need to think carefully about how you use these classes. As an example, consider the following class:</p>
<p class="imageip"><img src="images/un682-01.jpg" alt="images" /></p>
<p class="indent">The method <code>Collections.synchronizedList()</code> returns a <code>List</code> whose methods are all <code>synchronized</code> and “thread-safe” according to the documentation (like a Vector—but since this is the 21st century, we’re not going to use a Vector here). The question is, can the <code>NameList</code> class be used safely from multiple threads? It’s tempting to think that yes, because the data in names is in a synchronized collection, the <code>NameList</code> class is “safe” too. However, that’s not the case—the <code>removeFirst()</code> may sometimes throw an <code>IndexOutOfBoundsException</code>. What’s the problem? Doesn’t it correctly check the <code>size()</code> of <code>names</code> before removing anything to make sure there’s something there? How could this code fail? Let’s try to use <code>NameList</code> like this:</p>
<p class="imageip"><img src="images/un682-02.jpg" alt="images" /></p>
<p class="indent">What might happen here is that one of the threads will remove the one name and print it, and then the other will try to remove a name and get <code>null</code>. If we think <span id="page_683" epub:type="pagebreak"></span>just about the calls to <code>names.size()</code> and <code>names.remove(0)</code>, they occur in this order:</p>
<p class="bq">Thread <code>t1</code> executes <code>names.size()</code>, which returns <code>1</code>.<br/>Thread <code>t1</code> executes <code>names.remove(0)</code>, which returns <code>Ozymandias</code>.<br/>Thread <code>t2</code> executes <code>names.size()</code>, which returns <code>0</code>.<br/>Thread <code>t2</code> does not call <code>remove(0)</code>.</p>
<p class="indent">The output here is</p>
<p class="imageip"><img src="images/un683-01.jpg" alt="images" /></p>
<p class="indent">However, if we run the program again, something different might happen:</p>
<p class="bq">Thread <code>t1</code> executes <code>names.size()</code>, which returns <code>1</code>.<br/>Thread <code>t2</code> executes <code>names.size()</code>, which returns <code>1</code>.<br/>Thread <code>t1</code> executes <code>names.remove(0)</code>, which returns <code>Ozymandias</code>.<br/>Thread <code>t2</code> executes <code>names.remove(0)</code>, which throws an exception because the list is now empty.</p>
<p class="indent">The thing to realize here is that in a “thread-safe” class like the one returned by <code>synchronizedList()</code>, each <em>individual</em> method is synchronized. So <code>names.size()</code> is <code>synchronized</code>, and <code>names.remove(0)</code> is <code>synchronized</code>. But nothing prevents another thread from doing something else to the list <em>in between</em> those two calls. And that’s where problems can happen.</p>
<p class="indent">There’s a solution here: Don’t rely on <code>Collections.synchronizedList()</code>. Instead, synchronize the code yourself:</p>
<p class="imageip"><img src="images/un683-02.jpg" alt="images" /></p>
<p class="indent">Now the entire <code>removeFirst()</code> method is <code>synchronized</code>, and once one thread starts it and calls <code>names.size()</code>, there’s no way the other thread can cut in and steal the last name. The other thread will just have to wait until the first thread completes the <code>removeFirst()</code> method.</p>
<p class="indent"><span id="page_684" epub:type="pagebreak"></span>The moral here is that just because a class is described as “thread-safe” doesn’t mean it is <em>always</em> thread-safe. If individual methods are synchronized, that may not be enough—you may be better off putting in synchronization at a higher level (i.e., put it in the block or method that <em>calls</em> the other methods). Once you do that, the original synchronization (in this case, the synchronization inside the object returned by <code>Collections.synchronizedList()</code>) may well become redundant.</p>
<h4 class="h4" id="ch10lev2sec11">Thread Deadlock</h4>
<p class="noindent">Perhaps the scariest thing that can happen to a Java program is deadlock. Deadlock occurs when two threads are blocked, with each waiting for the other’s lock. Neither can run until the other gives up its lock, so they’ll sit there forever.</p>
<p class="indent">This can happen, for example, when thread A hits <code>synchronized</code> code, acquires a lock B, and then enters another method (still within the <code>synchronized</code> code it has the lock on) that’s also <code>synchronized</code>. But thread A can’t get the lock to enter this <code>synchronized</code> code—block C—because another thread D has the lock already. So thread A goes off to the waiting-for-the-C-lock pool, hoping that thread D will hurry up and release the lock (by completing the <code>synchronized</code> method). But thread A will wait a very long time indeed, because while thread D picked up lock C, it then entered a method <code>synchronized</code> on lock B. Obviously, thread D can’t get the lock B because thread A has it. And thread A won’t release it until thread D releases lock C. But thread D won’t release lock C until after it can get lock B and continue. And there they sit. The following example demonstrates deadlock:</p>
<p class="imageip"><img src="images/un684-01.jpg" alt="images" /></p>
<p class="imageip"><span id="page_685" epub:type="pagebreak"></span><img src="images/un685-01.jpg" alt="images" /></p>
<p class="indent">Assume that <code>read()</code> is started by one thread and <code>write()</code> is started by another. If there are two different threads that may read and write independently, there is a risk of deadlock at line 8 or 16. The reader thread will have <code>resourceA</code>, the writer thread will have <code>resourceB</code>, and both will get stuck waiting for the other.</p>
<p class="indent">Code like this almost never results in deadlock because the CPU has to switch from the reader thread to the writer thread at a particular point in the code, and the chances of deadlock occurring are quite small. The application may work fine 99.9 percent of the time.</p>
<p class="indent">The preceding simple example is easy to fix; just swap the order of locking for either the reader or the writer at lines 16 and 17 (or lines 8 and 9). More complex deadlock situations can take a long time to figure out.</p>
<p class="indent">Regardless of how little chance there is for your code to deadlock, the bottom line is that if you deadlock, you’re dead. There are design approaches that can help avoid deadlock, including strategies for always acquiring locks in a predetermined order.</p>
<p class="indent">But that’s for you to study and is beyond the scope of this book. We’re just trying to get you through the exam. If you learn everything in this chapter, though, you’ll still know more about threads than most experienced Java programmers.</p>
<h4 class="h4" id="ch10lev2sec12">Thread Livelock</h4>
<p class="noindent">Livelock is almost as scary to a Java program as deadlock. Livelock is similar to deadlock, except that the threads aren’t officially dead; they’re just too busy to make progress.</p>
<p class="indent">Imagine you’ve got a program with two threads and two locks. Each thread must get both locks in order to proceed with the work it needs to do. Thread one successfully acquires lock 1 and then tries to get lock 1 and fails, because thread 2 has already gotten lock 2. Thread 1 then unlocks lock 1, giving thread 2 a chance to get it, waits a little while and then tries to get lock 1 and lock 2 again.</p>
<p class="indent">At the same time, thread 2 gets lock 2 and then attempts to get lock 1. Well, thread 1 already has lock 1, so lock 2 does a similar thing: it unlocks lock 2, giving thread 1 a chance to get it, waits a little while, and then tries to get lock 2 and lock 1 again.</p>
<p class="indent"><span id="page_686" epub:type="pagebreak"></span>Livelock occurs if thread 1 tries to get lock 2 when thread 2 has lock 2, and thread 2 tries to get lock 1 when thread 1 has lock 1; they both free up the locks they have, so then thread 1 and thread 2 are both waiting on the other thread to get the lock each wants and then both get their locks again and go back to trying to get the lock the other thread has…over and over and over again.</p>
<p class="indent">In this situation, the threads are not completely deadlocked, but they are making no progress. This is an extremely tricky problem to detect! The timing has to be just right, so you might find your code runs perfectly fine 99 percent of the time and livelocks 1 percent of the time. Fortunately, Java makes livelock hard to do; with ReentrantLock (more on this in <a href="ch11.xhtml#ch11">Chapter 11</a> where we talk about concurrency) and careful ordering of how your threads attempt to access locks, you will be unlikely to encounter this problem.</p>
<h4 class="h4" id="ch10lev2sec13">Thread Starvation</h4>
<p class="noindent">Starvation is related to livelock. Starvation is when a thread is unable to make progress because it cannot get access to a shared resource that other threads are hogging. This could happen when another thread gets access to a synchronized resource and then goes into an infinite loop or takes a really long time to use the resource. It could also happen if one thread has higher priority than another thread so the first thread always gets a resource when both threads attempt to access that resource at the same time.</p>
<p class="indent">If you are not fiddling with thread priorities—and you are careful about how long a thread can keep access to a resource before yielding or timing out—then you should be able to avoid starvation. Good thread schedulers will help prevent starvation by allocating time fairly between threads behind the scenes.</p>
<h4 class="h4" id="ch10lev2sec14">Race Conditions</h4>
<p class="noindent">A race condition is another scenario that can crop up when working with multiple threads. To understand what a race condition is and how it can occur, let’s revisit the singleton pattern from <a href="ch2.xhtml#ch2">Chapter 2</a>.</p>
<p class="indent">In that chapter, we mentioned that our singleton implementation is not thread-safe without some precautions. Let’s take a look at how we might use the <code>Show</code> singleton from that chapter in a multithreaded program to see where things can go wrong. In the process, we’ll create a race condition.</p>
<p class="imageip"><img src="images/un686-01.jpg" alt="images" /></p>
<p class="imageip"><span id="page_687" epub:type="pagebreak"></span><img src="images/un687-01.jpg" alt="images" /></p>
<p class="indent">When we run the code, here’s what we get:</p>
<p class="imageip"><img src="images/un687-02.jpg" alt="images" /></p>
<p class="indent"><span id="page_688" epub:type="pagebreak"></span>Uh oh. It looks like we’ve sold seat 1A twice! That means two people will show up for the concert and expect to get the same seat.</p>
<p class="indent">This issue is caused by a <em>race condition</em>. A race condition is when two or more threads try to access and change a shared resource at the same time, and the result is dependent on the order in which the code is executed by the threads.</p>
<p class="indent">Let’s step through the code and see how this happens. In <code>TestShow</code>, in <code>go()</code> (which we call from <code>main()</code>), we create two threads. Each thread tries to book seats 1A and 1B by calling <code>ticketAgentBooks()</code>. We start both threads.</p>
<p class="indent">Imagine a scenario where thread one calls <code>ticketAgentBooks()</code> with the argument “1A”. Thread one calls <code>Show.getInstance()</code>. It executes the code:</p>
<p class="imageip"><img src="images/un688-01.jpg" alt="images" /></p>
<p class="noindent">and determines the value in <code>INSTANCE</code> is, indeed, <code>null</code>, and so is just about to execute the next line of code when BOOM! The thread is descheduled, and thread two begins executing.</p>
<p class="indent">Now, thread two calls <code>ticketAgentBooks()</code> with the argument “1A”. Thread two calls <code>Show.getInstance()</code>. It executes the code:</p>
<p class="imageip"><img src="images/un688-02.jpg" alt="images" /></p>
<p class="noindent">and determines the value of INSTANCE is, indeed, null, and so executes the next line of code:</p>
<p class="imageip"><img src="images/un688-03.jpg" alt="images" /></p>
<p class="indent">Thread two then gets descheduled and thread one begins executing again. It then executes the line:</p>
<p class="imageip"><img src="images/un688-04.jpg" alt="images" /></p>
<p class="indent">Now we have two instances of <code>Show</code>. So when thread one then uses its instance of <code>Show</code> to book a seat by calling <code>show.bookSeat()</code> on “1A”, it succeeds. Similarly, when thread two uses its instance of <code>Show</code> to book a seat, it too succeeds. We had two threads racing to get what should have been one shared resource, and because of timing, we end up with two instances of a resource and a failure in our program logic.</p>
<p class="indent">We can fix this race condition by making the <code>getInstance()</code> method <code>synchronized</code> and the <code>INSTANCE</code> variable <code>volatile</code>:</p>
<p class="imageip"><img src="images/un688-05.jpg" alt="images" /></p>
<p class="indent"><span id="page_689" epub:type="pagebreak"></span>The <code>volatile</code> keyword makes sure that the variable <code>INSTANCE</code> is atomic; that is, a write to the variable happens all at once. Nothing can interrupt this process: it either happens completely, or it doesn’t happen at all. So in <code>getInstance()</code>, where we create a new instance of <code>Show()</code> and assign it to <code>INSTANCE</code>, that entire operation must complete before the thread can be interrupted.</p>
<p class="indent">The <em>synchronized</em> keyword makes sure only one thread at a time can access the <code>getInstance()</code> method. That ensures we won’t get a race condition: in other words, we can’t check the value of <code>INSTANCE</code> in one thread, then stop, and do the same in another thread.</p>
<p class="indent">You can run this code, but you might find it still doesn’t work! Why?</p>
<p class="indent">Take a look at the method <code>bookSeat()</code> in <code>Show</code>. When we book a seat by calling this method from the <code>ticketAgentBooks()</code> method, we are changing another shared resource, the <code>availableSeats Set</code>. However, the <code>Set</code> is not thread-safe! That means a thread could be interrupted in the middle of removing seat “1A” from the <code>Set</code>, and another thread could come along and access the <code>Set</code>. If the operations to remove the seat from the <code>availableSeats Set</code> get interleaved, we can still end up in a situation where two threads can book the same seat.</p>
<p class="indent">To solve this problem, we must synchronize the <code>bookSeat()</code> method, too:</p>
<p class="imageip"><img src="images/un689-01.jpg" alt="images" /></p>
<p class="indent">Now when we run the code, we should find that each seat can be booked by only one thread:</p>
<p class="imageip"><img src="images/un689-02.jpg" alt="images" /></p>
<p class="indent">Notice that this does not mean that a thread will get both seats. Right? A thread can still be interrupted in between the two seat bookings:</p>
<p class="imageip"><img src="images/un689-03.jpg" alt="images" /></p>
<p class="indent">If you want to make sure you sell both seats to the same thread, you have to do even more work. But that’s enough for now (and enough about race conditions for the exam).</p>
<p class="indent">In a multithreaded environment, we need to make sure our code is designed so it’s not dependent on the ordering of the threads. In situations where our code is dependent on ordering or dependent on certain operations not being interrupted, <span id="page_690" epub:type="pagebreak"></span>we can get race conditions. As you’ve seen, there are ways to fix race conditions, but like deadlock, livelock, and starvation, they can be tricky to detect.</p>
<p class="indent">You’ve seen an example where a race condition led to two threads both getting seat “1A”. There are also race conditions in which neither thread gets seat “1A”. It’s far better for neither thread to end up with a seat than for two threads to end up with the same seat (while the venue operator might be unhappy having an empty, unsold seat, it’s worse to have customers fighting over seats!). However, by fixing the race conditions in this code, we’ve enabled the seats to be sold to the threads properly, so only one thread gets any given seat.</p>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch10lev1sec4"><strong>Thread Interaction (OCP Objectives 10.2 and 10.3)</strong></h3>
<p class="noindent"><em>10.2   Identify potential threading problems among deadlock, starvation, livelock, and race conditions.</em></p>
<p class="noindent"><em>10.3   Use synchronized keyword and java.util.concurrent.atomic package to control the order of thread execution.</em></p>
<p class="indentt">The last thing we need to look at is how threads can interact with one another to communicate about—among other things—their locking status. The <code>Object</code> class has three methods, <code>wait()</code>, <code>notify()</code>, and <code>notifyAll()</code>, that help threads communicate the status of an event that the threads care about. For example, if one thread is a mail-delivery thread and one thread is a mail-processor thread, the mail-processor thread has to keep checking to see if there’s any mail to process. Using the wait and notify mechanism, the mail-processor thread could check for mail, and if it doesn’t find any, it can say, “Hey, I’m not going to waste my time checking for mail every two seconds. I’m going to go hang out, and when the mail deliverer puts something in the mailbox, have him notify me so I can go back to runnable and do some work.” In other words, using <code>wait()</code> and <code>notify()</code> lets one thread put itself into a “waiting room” until some <em>other</em> thread notifies it that there’s a reason to come back out.</p>
<p class="indent">One key point to remember (and keep in mind for the exam) about <code>wait()</code>/<code>notify()</code> is this:</p>
<p class="bq"><em>wait(), notify(), and notifyAll() must be called from within a synchronized context! A thread can’t invoke a wait() or notify() method on an object unless it owns that object’s lock.</em></p>
<p class="indent"><span id="page_691" epub:type="pagebreak"></span>Here we’ll present an example of two threads that depend on each other to proceed with their execution, and we’ll show how to use <code>wait()</code> and <code>notify()</code> to make them interact safely at the proper moment.</p>
<p class="indent">Think of a computer-controlled machine that cuts pieces of fabric into different shapes and an application that allows users to specify the shape to cut. The current version of the application has one thread, which loops, first asking the user for instructions, and then directs the hardware to cut the requested shape:</p>
<p class="imageip"><img src="images/un691-01.jpg" alt="images" /></p>
<p class="indent">This design is not optimal because the user can’t do anything while the machine is busy and while there are other shapes to define. We need to improve the situation.</p>
<p class="indent">A simple solution is to separate the processes into two different threads, one of them interacting with the user and another managing the hardware. The user thread sends the instructions to the hardware thread and then goes back to interacting with the user immediately. The hardware thread receives the instructions from the user thread and starts directing the machine immediately. Both threads use a common object to communicate, which holds the current design being processed.</p>
<p class="indent">The following pseudocode shows this design:</p>
<p class="imageip"><img src="images/un691-02.jpg" alt="images" /></p>
<p class="indent">The problem now is to get the hardware thread to process the machine steps as soon as they are available. Also, the user thread should not modify them until they have all been sent to the hardware. The solution is to use <code>wait()</code> and <code>notify()</code> and also to synchronize some of the code.</p>
<p class="indent"><span id="page_692" epub:type="pagebreak"></span>The methods <code>wait()</code> and <code>notify()</code>, remember, are instance methods of <code>Object</code>. In the same way that every object has a lock, every object can have a list of threads that are waiting for a signal (a notification) from the object. A thread gets on this waiting list by executing the <code>wait()</code> method of the target object. From that moment, it doesn’t execute any further instructions until the <code>notify()</code> method of the target object is called. If many threads are waiting on the same object, only one will be chosen (in no guaranteed order) to proceed with its execution. If there are no threads waiting, then no particular action is taken. Let’s take a look at some real code that shows one object waiting for another object to notify it (take note, it is somewhat complex):</p>
<p class="imageip"><img src="images/un692-01.jpg" alt="images" /></p>
<p class="indent">This program contains two objects with threads: <code>ThreadA</code> contains the main thread, and <code>ThreadB</code> has a thread that calculates the sum of all numbers from 0 through 99. As soon as line 4 calls the <code>start()</code> method, <code>ThreadA</code> will continue with the next line of code in its own class, which means it could get to line 11 before <code>ThreadB</code> has finished the calculation. To prevent this, we use the <code>wait()</code> method in line 9.</p>
<p class="indent"><span id="page_693" epub:type="pagebreak"></span>Notice in line 6 the code synchronizes itself with the object <code>b</code>—this is because in order to call <code>wait()</code> on the object, <code>ThreadA</code> must own a lock on <code>b</code>. For a thread to call <code>wait()</code> or <code>notify()</code>, the thread has to be the owner of the lock for that object. When the thread waits, it temporarily releases the lock for other threads to use, but it will need it again to continue execution. It’s common to find code like this:</p>
<p class="imageip"><img src="images/un693-01.jpg" alt="images" /></p>
<p class="indent">The preceding code waits until <code>notify()</code> is called on <code>anotherObject</code>.</p>
<p class="imageip"><img src="images/un693-02.jpg" alt="images" /></p>
<p class="indent">This code notifies a single thread currently waiting on the <code>this</code> object. The lock can be acquired much earlier in the code, such as in the calling method. Note that if the thread calling <code>wait()</code> does not own the lock, it will throw an <code>IllegalMonitorStateException</code>. This exception is not a checked exception, so you don’t have to <em>catch</em> it explicitly. You should always be clear whether a thread has the lock of an object in any given block of code.</p>
<p class="indent">Notice in lines 7–10 there is a <code>try/catch</code> block around the <code>wait()</code> method. A waiting thread can be interrupted in the same way as a sleeping thread, so you have to take care of the exception:</p>
<p class="imageip"><img src="images/un693-03.jpg" alt="images" /></p>
<p class="indent">In the next example, the way to use these methods is to have the hardware thread wait on the shape to be available and the user thread to notify after it has written the steps. The machine steps may comprise global steps, such as moving the required fabric to the cutting area, and a number of substeps, such as the direction and length of a cut. As an example, they could be</p>
<p class="imageip"><img src="images/un693-04.jpg" alt="images" /></p>
<p class="indent"><span id="page_694" epub:type="pagebreak"></span>It is important that the user thread does not modify the machine steps while the hardware thread is using them, so this reading and writing should be synchronized.</p>
<p class="indent">The resulting code would look like this:</p>
<p class="imageip"><img src="images/un694-01.jpg" alt="images" /></p>
<p class="indent">The machine thread, once started, will immediately go into the waiting state and will wait patiently until the operator sends the first notification. At that point, it is the operator thread that owns the lock for the object, so the hardware thread gets stuck for a while. It’s only after the operator thread abandons the <code>synchronized</code> block that the hardware thread can really start processing the machine steps.</p>
<p class="indent">While one shape is being processed by the hardware, the user may interact with the system and specify another shape to be cut. When the user is finished with the shape and it is time to cut it, the operator thread attempts to enter the <code>synchronized</code> block, maybe blocking until the machine thread has finished with the previous machine steps. When the machine thread has finished, it repeats the loop, going again to the waiting state (and therefore releasing the lock). Only then can the operator thread enter the <code>synchronized</code> block and overwrite the machine steps with the new ones.</p>
<p class="indent">Having two threads is definitely an improvement over having one, although in this implementation, there is still a possibility of making the user wait. A further improvement would be to have many shapes in a queue, thereby reducing the possibility of requiring the user to wait for the hardware.</p>
<p class="indent"><span id="page_695" epub:type="pagebreak"></span>There is also a second form of <code>wait()</code> that accepts a number of milliseconds as a maximum time to wait. If the thread is not interrupted, it will continue normally whenever it is notified or the specified timeout has elapsed. This normal continuation consists of getting out of the waiting state, but to continue execution, it will have to get the lock for the object:</p>
<p class="imageip"><img src="images/un695-01.jpg" alt="images" /></p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>When the <code>wait()</code> method is invoked on an object, the thread executing that code gives up its lock on the object immediately. However, when <code>notify()</code> is called, that doesn’t mean the thread gives up its lock at that moment. If the thread is still completing synchronized code, the lock is not released until the thread moves out of synchronized code. So just because <code>notify()</code> is called, this doesn’t mean the lock becomes available at that moment.</em></strong></p>
</div>
<h4 class="h4" id="ch10lev2sec15">Using notifyAll( ) When Many Threads May Be Waiting</h4>
<p class="noindent">In most scenarios, it’s preferable to notify <em>all</em> of the threads that are waiting on a particular object. If so, you can use <code>notifyAll()</code> on the object to let all the threads rush out of the waiting area and back to runnable. This is especially important if you have several threads waiting on one object, but for different reasons, and you want to be sure that the <em>right</em> thread (along with all of the others) is notified.</p>
<p class="imageip"><img src="images/un695-02.jpg" alt="images" /></p>
<p class="indent">All of the threads will be notified and start competing to get the lock. As the lock is used and released by each thread, all of them will get into action without a need for further notification.</p>
<p class="indent">As we said earlier, an object can have many threads waiting on it, and using <code>notify()</code> will affect only one of them. Which one, exactly, is not specified and depends on the JVM implementation, so you should never rely on a particular thread being notified in preference to another.</p>
<p class="indent"><span id="page_696" epub:type="pagebreak"></span>In cases in which there might be a lot more waiting, the best way to do this is by using <code>notifyAll()</code>. Let’s take a look at this in some code. In this example, there is one class that performs a calculation and many readers that are waiting to receive the completed calculation. At any given moment, many readers may be waiting.</p>
<p class="imageip"><img src="images/un696-01.jpg" alt="images" /></p>
<p class="indent">The program starts three threads that are all waiting to receive the finished calculation (lines 18–24) and then starts the calculator with its calculation. Note that if the <code>run()</code> method at line 30 used <code>notify()</code> instead of <code>notifyAll()</code>, only one reader would be notified instead of all the readers.</p>
<h5 class="h5"><span id="page_697" epub:type="pagebreak"></span>Using wait( ) in a Loop</h5>
<p class="noindent">Actually, both of the previous examples (Machine/Operator and Reader/Calculator) had a common problem. In each one, there was at least one thread calling <code>wait()</code> and another thread calling <code>notify()</code> or <code>notifyAll()</code>. This works well enough as long as the waiting threads have actually started waiting before the other thread executes the <code>notify()</code> or <code>notifyAll()</code>. But what happens if, for example, the <code>Calculator</code> runs first and calls <code>notify()</code> before the <code>Reader</code>s have started waiting? This could happen since we can’t guarantee the order in which the different parts of the thread will execute. Unfortunately, when the Readers run, they just start waiting right away. They don’t do anything to see if the event they’re waiting for has already happened. So if the <code>Calculator</code> has already called <code>notifyAll()</code>, it’s not going to call <code>notifyAll()</code> again—and the waiting <code>Reader</code>s will keep waiting forever. This is probably <em>not</em> what the programmer wanted to happen. Almost always, when you want to wait for something, you also need to be able to check if it has already happened. Generally, the best way to solve this is to put in some sort of loop that checks on some sort of conditional expressions and only waits if the thing you’re waiting for has not yet happened. Here’s a modified, safer version of the earlier fabric-cutting machine example:</p>
<p class="imageip"><img src="images/un697-01.jpg" alt="images" /></p>
<p class="indent">The operaator will still keep on looping forever, getting more shapes from users, calculating new instructions for those shapes, and sending them to the machine. But now the logic for <code>notify()</code> has been moved into the <code>addJob()</code> method in the <code>Machine</code> class:</p>
<p class="imageip"><img src="images/un697-02.jpg" alt="images" /></p>
<p class="imageip"><span id="page_698" epub:type="pagebreak"></span><img src="images/un698-01.jpg" alt="images" /></p>
<p class="indent">A machine keeps a list of the jobs it’s scheduled to do. Whenever an operator adds a new job to the list, it calls the <code>addJob()</code> method and adds the new job to the list. Meanwhile, the <code>run()</code> method just keeps looping, looking for any jobs on the list. If there are no jobs, it will start waiting. If it’s notified, it will stop waiting and then recheck the loop condition: Is the list still empty? In practice, this double-check is probably not necessary, as the only time a <code>notify()</code> is ever sent is when a new job has been added to the list. However, it’s a good idea to require the thread to recheck the <code>isEmpty()</code> condition whenever it’s been woken up because it’s possible that a thread has accidentally sent an extra <code>notify()</code> that was not intended. There’s also a possible situation called <em>spontaneous wakeup</em> that may exist in some situations—a thread may wake up even though no code has called <code>notify()</code> or <code>notifyAll()</code>. (At least, no code you know about has called these methods. Sometimes, the JVM may call <code>notify()</code> for reasons of its own, or code in some other class calls it for reasons you just don’t know.) What this means is that when your thread wakes up from a <code>wait()</code>, you don’t know for sure why it was awakened. By putting the <code>wait()</code> method in a <code>while</code> loop and rechecking the condition that represents what we were waiting for, we ensure that <em>whatever</em> the reason we woke up, we will re-enter the <code>wait()</code> if (and only if) the thing we were waiting for has not happened yet. In the <code>Machine</code> class, the thing we were waiting for is for the jobs list to not be empty. If it’s empty, we wait, and if it’s not, we don’t.</p>
<p class="indent">Note also that both the <code>run()</code> method and the <code>addJob()</code> method synchronize on the same object—the jobs list. This is for two reasons. One is because we’re calling <code>wait()</code> and <code>notify()</code> on this instance, so we need to synchronize in order to avoid an <code>IllegalMonitorStateException</code>. The other reason is that 700the data in the <span id="page_699" epub:type="pagebreak"></span>jobs list is changeable data stored in a field that is accessed by two different threads. We need to synchronize in order to access that changeable data safely. Fortunately, the same <code>synchronized</code> blocks that allow us to <code>wait()</code> and <code>notify()</code> also provide the required thread safety for our other access to changeable data. In fact, this is a main reason why synchronization is required to use <code>wait()</code> and <code>notify()</code> in the first place—you almost always need to share some mutable data between threads at the same time, and that means you need synchronization. Notice that the <code>synchronized</code> block in <code>addJob()</code> is big enough to also include the call to <code>jobs.add(job)</code>—which modifies shared data. And the <code>synchronized</code> block in <code>run()</code> is large enough to include the whole <code>while</code> loop—which includes the call to <code>jobs.isEmpty()</code>, which accesses shared data.</p>
<p class="indent">The moral here is that when you use <code>wait()</code> and <code>notify()</code> or <code>notifyAll()</code>, you should almost always also have a <code>while</code> loop around the <code>wait()</code> that checks a condition and forces continued waiting until the condition is met. And you should also make use of the required synchronization for the <code>wait()</code> and <code>notify()</code> calls to also protect whatever other data you’re sharing between threads. If you see code that fails to do this, there’s usually something wrong with the code—even if you have a hard time seeing what exactly the problem is.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>The methods <code>wait(), notify(),</code> and <code>notifyAll()</code> are methods of only <code>java.lang.Object</code>, not of <code>java.lang.Thread</code> or <code>java.lang.Runnable.</code> Be sure you know which methods are defined in <code>Thread</code>, which in <code>Object</code>, and which in <code>Runnable</code> (just <code>run()</code>, so that’s an easy one). Of the key methods in <code>Thread</code>, be sure you know which are <code>static</code>—<code>sleep()</code> and <code>yield()</code>—and which are <code>not static—join()</code> and <code>start()</code>. <a href="ch10.xhtml#ch10tab2">Table 10-2</a> lists the key methods you’ll need to know for the exam, with the <code>static</code> methods shown in italics.</em></strong></p>
</div>
<p class="tabcap" id="ch10tab2"><span class="table"><strong>TABLE 10-2</strong></span></p>
<p class="tabcap1">Key <code>Thread</code> Methods</p>
<p class="imaget"><img src="images/tab10-02.jpg" alt="Images" /></p>
<h3 class="h3b" id="ch10lev1sec5"><span id="page_700" epub:type="pagebreak"></span>CERTIFICATION SUMMARY</h3>
<hr/>
<p class="noindent">This chapter covered the required thread knowledge you’ll need to apply on the certification exam. Threads can be created by either extending the <code>Thread</code> class or implementing the <code>Runnable</code> interface. The only method that must be implemented in the <code>Runnable</code> interface is the <code>run()</code> method, but the thread doesn’t become a <em>thread of execution</em> until somebody calls the <code>Thread</code> object’s <code>start()</code> method. We also looked at how the <code>sleep()</code> method can be used to pause a thread, and we saw that when an object goes to sleep, it holds onto any locks it acquired prior to sleeping.</p>
<p class="indent">We looked at five thread states: new, runnable, running, blocked/waiting/sleeping, and dead. You learned that when a thread is dead, it can never be restarted even if it’s still a valid object on the heap. We saw that there is only one way a thread can transition to running, and that’s from runnable. However, once running, a thread can become dead, go to sleep, wait for another thread to finish, block on an object’s lock, wait for a notification, or return to runnable.</p>
<p class="indent">You saw how two threads acting on the same data can cause serious problems (remember Lucy and Fred’s bank account?). We saw that to let one thread execute a method but prevent other threads from running the same object’s method, we use the <code>synchronized</code> keyword. And we saw how the <code>wait()</code>, <code>notify()</code>, and <code>notifyAll()</code> methods can be used to coordinate activity between different threads.</p>
<h3 class="h3b" id="ch10lev1sec6"><span id="page_701" epub:type="pagebreak"></span><img src="images/tick1.jpg" alt="Images" /> TWO-MINUTE DRILL</h3>
<p class="noindent">Here are some of the key points from each certification objective in this chapter. Photocopy it and sleep with it under your pillow for complete absorption.</p>
<h4 class="h4">Defining, Instantiating, and Starting Threads (OCP Objective 10.1)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Threads can be created by extending <code>Thread</code> and overriding the <code>public void run()</code> method.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>Thread</code> objects can also be created by calling the <code>Thread</code> constructor that takes a <code>Runnable</code> argument. The <code>Runnable</code> object is said to be the <em>target</em> of the thread.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A <code>Runnable</code> can be defined as an instance of a class that implements the <code>Runnable</code> interface. You can create a Runnable with a lambda expression, because <code>Runnable</code> is a functional interface.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can call <code>start()</code> on a <code>Thread</code> object only once. If <code>start()</code> is called more than once on a <code>Thread</code> object, it will throw a <code>IllegalThreadStateException</code>.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  It is legal to create many <code>Thread</code> objects using the same <code>Runnable</code> object as the target.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  When a <code>Thread</code> object is created, it does not become a <em>thread of execution</em> until its <code>start()</code> method is invoked. When a <code>Thread</code> object exists but hasn’t been started, it is in the <em>new</em> state and is not considered <em>alive</em>.</p>
<h4 class="h4">Transitioning Between Thread States (OCP Objective 10.1)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Once a new thread is started, it will always enter the runnable state.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The thread scheduler can move a thread back and forth between the runnable state and the running state.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  For a single-processor machine, only one thread can be running at a time, although many threads may be in the runnable state.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  There is no guarantee that the order in which threads were started determines the order in which they’ll run.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  There’s no guarantee that threads will take turns in any fair way. It’s up to the thread scheduler, as determined by the particular virtual machine <span id="page_702" epub:type="pagebreak"></span>implementation. If you want a guarantee that your threads will take turns, regardless of the underlying JVM, you can use the <code>sleep()</code> method. This prevents one thread from hogging the running process while another thread starves. (In most cases, though, <code>yield()</code> works well enough to encourage your threads to play together nicely.)</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A running thread may enter a blocked/waiting state by a <code>wait()</code>, <code>sleep()</code>, or <code>join()</code> call.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A running thread may enter a blocked/waiting state because it can’t acquire the lock for a synchronized block of code.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  When the sleep or wait is over, or an object’s lock becomes available, the thread can only reenter the runnable state. It will <em>go</em> directly from waiting to runnable (well, for all practical purposes anyway).</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A dead thread cannot be started again.</p>
<h4 class="h4">Sleep, Yield, and Join (OCP Objective 10.1)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Sleeping is used to delay execution for a period of time, and no locks are released when a thread goes to sleep.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A sleeping thread is guaranteed to sleep for at least the time specified in the argument to the <code>sleep()</code> method (unless it’s interrupted), but there is no guarantee as to when the newly awakened thread will actually return to running.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>sleep()</code> method is a <code>static</code> method that sleeps the currently executing thread’s state. One thread <em>cannot</em> tell another thread to sleep.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>setPriority()</code> method gives <code>Thread</code> objects a priority of between 1 (low) and 10 (high). Priorities are not guaranteed, and not all JVMs recognize ten distinct priority levels—some levels may be treated as effectively equal.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  If not explicitly set, a thread’s priority will have the same priority as the thread that created it.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>yield()</code> method <em>may</em> cause a running thread to back out if there are runnable threads of the same priority. There is no guarantee that this will happen, and there is no guarantee that when the thread backs out there will be a <em>different</em> thread selected to run. A thread might yield and then immediately reenter the running state.</p>
<p class="bull-image"><span id="page_703" epub:type="pagebreak"></span><img class="inline" src="images/box1.jpg" alt="Images" />  The closest thing to a guarantee is that at any given time, when a thread is running, it will usually not have a lower priority than any thread in the runnable state. If a low-priority thread is running when a high-priority thread enters runnable, the JVM will usually preempt the running low-priority thread and put the high-priority thread in.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  When one thread calls the <code>join()</code> method of another thread, the currently running thread will wait until the thread it joins with has completed. Think of the <code>join()</code> method as saying, “Hey, thread, I want to join on to the end of you. Let me know when you’re done, so I can enter the runnable state.”</p>
<h4 class="h4">Concurrent Access Problems and Synchronized Threads (OCP Objectives 10.2 and 10.3)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>synchronized</code> methods prevent more than one thread from accessing an object’s critical method code simultaneously.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  You can use the <code>synchronized</code> keyword as a method modifier or to start a synchronized block of code.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  To synchronize a block of code (in other words, a scope smaller than the whole method), you must specify an argument that is the object whose lock you want to synchronize on.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  While only one thread can be accessing synchronized code of a particular instance, multiple threads can still access the same object’s unsynchronized code.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  When a thread goes to sleep, its locks will be unavailable to other threads.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  <code>static</code> methods can be <code>synchronized</code> using the lock from the <code>java.lang.Class</code> instance representing that class.</p>
<h4 class="h4">Communicating with Objects by Waiting and Notifying (OCP Objective 10.1)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>wait()</code> method lets a thread say, “There’s nothing for me to do now, so put me in your waiting pool and notify me when something happens that I care about.” Basically, a <code>wait()</code> call means “let me wait in your pool” or “add me to your waiting list.”</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>notify()</code> method is used to send a signal to one and only one of the threads that are waiting in that same object’s waiting pool.</p>
<p class="bull-image"><span id="page_704" epub:type="pagebreak"></span><img class="inline" src="images/box1.jpg" alt="Images" />  The <code>notify()</code> method CANNOT specify which waiting thread to notify.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  The method <code>notifyAll()</code> works in the same way as <code>notify()</code>, only it sends the signal to <em>all</em> of the threads waiting on the object.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  All three methods—<code>wait()</code>, <code>notify()</code>, and <code>notifyAll()</code>—must be called from within a <code>synchronized</code> context! A thread invokes <code>wait()</code> or <code>notify()</code> on a particular object, and the thread must currently hold the lock on that object.</p>
<h4 class="h4">Deadlocked, Livelocked, and Starved Threads and Race Conditions (OCP Objective 10.2)</h4>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Deadlocking is when thread execution grinds to a halt because the code is waiting for locks to be removed from objects.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Deadlocking can occur when a locked object attempts to access another locked object that is trying to access the first locked object. In other words, both threads are waiting for each other’s locks to be released; therefore, the locks will <em>never</em> be released!</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Deadlocking is bad. Don’t do it.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Livelocking is when thread execution grinds to a halt because the threads are too busy to make any progress. The threads are still working but can’t get anywhere.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Thread starvation is when a thread can’t get access to a resource it needs so it starves. It’s still alive, but barely.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  A race condition is when two threads race to get the same shared resource, and the result (often wrong) depends on which thread gets there first.</p>
<p class="bull-image"><img class="inline" src="images/box1.jpg" alt="Images" />  Race conditions are bad. Don’t allow them to happen. Use the <code>volatile</code> keyword to protect variables that should be atomic, and the <code>synchronized</code> keyword to make sure only one thread at a time can run code that manages a resource.</p>
<h3 class="h3b" id="ch10lev1sec7"><span id="page_705" epub:type="pagebreak"></span><img src="images/qs.jpg" alt="Images" /> SELF TEST</h3>
<p class="noindent">The following questions will help you measure your understanding of the material presented in this chapter. If you have a rough time with some of these at first, don’t beat yourself up. Some of these questions are long and intricate. Expect long and intricate questions on the real exam, too!</p>
<p class="que"><strong><a id="ch10ans1" href="ch10.xhtml#r_ch10ans1">1</a>.</strong>   The following block of code creates a <code>Thread</code> using a <code>Runnable</code> target:</p>
<p class="num-pre"><img src="images/un705-01.jpg" alt="images" /></p>
<p class="alpha-no-1">Which of the following classes can be used to create the target so that the preceding code compiles correctly?</p>
<p class="alpha"><img src="images/un705-02.jpg" alt="images" /></p>
<p class="que"><strong><a id="ch10ans2" href="ch10.xhtml#r_ch10ans2">2</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un705-03.jpg" alt="images" /></p>
<p class="alpha-no-1">What is the result of this code?</p>
<p class="alpha">A. Compilation fails</p>
<p class="alpha">B. <code>1..2..3..</code></p>
<p class="alpha">C. <code>0..1..2..3..</code></p>
<p class="alpha">D. <code>0..1..2..</code></p>
<p class="alpha">E. An exception occurs at runtime</p>
<p class="que"><span id="page_706" epub:type="pagebreak"></span><strong><a id="ch10ans3" href="ch10.xhtml#r_ch10ans3">3</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un706-01.jpg" alt="images" /></p>
<p class="alpha-no-1">The <code>static</code> method <code>Thread.currentThread()</code> returns a reference to the currently executing <code>Thread</code> object. What is the result of this code?</p>
<p class="alpha">A. Each <code>String</code> in the array <code>lines</code> will output, with a one-second pause between lines</p>
<p class="alpha">B. Each <code>String</code> in the array <code>lines</code> will output, with no pause in between because this method is not executed in a <code>Thread</code></p>
<p class="alpha">C. Each <code>String</code> in the array <code>lines</code> will output, and there is no guarantee that there will be a pause because <code>currentThread()</code> may not retrieve this thread</p>
<p class="alpha">D. This code will not compile</p>
<p class="alpha">E. Each <code>String</code> in the <code>lines</code> array will print, with at least a one-second pause between lines</p>
<p class="que"><strong><a id="ch10ans4" href="ch10.xhtml#r_ch10ans4">4</a>.</strong>   Assume you have a class that holds two <code>private</code> variables: <code>a</code> and <code>b</code>. Which of the following pairs can prevent concurrent access problems in that class? (Choose all that apply.)</p>
<p class="alpha"><img src="images/un706-02.jpg" alt="images" /></p>
<p class="que"><span id="page_707" epub:type="pagebreak"></span><strong><a id="ch10ans5" href="ch10.xhtml#r_ch10ans5">5</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un707-01.jpg" alt="images" /></p>
<p class="alpha-no-1">What is the result of trying to compile and run this program?</p>
<p class="alpha">A. It fails to compile because the <code>IllegalMonitorStateException</code> of <code>wait()</code> is not dealt with in line 7</p>
<p class="alpha">B. <code>1 2 3</code></p>
<p class="alpha">C. <code>1 3</code></p>
<p class="alpha">D. <code>1 2</code></p>
<p class="alpha">E. At runtime, it throws an <code>IllegalMonitorStateException</code> when trying to wait</p>
<p class="alpha">F. It will fail to compile because it has to be synchronized on the <code>this</code> object</p>
<p class="que"><strong><a id="ch10ans6" href="ch10.xhtml#r_ch10ans6">6</a>.</strong>   Assume the following method is properly synchronized and called from a thread A on an object B:</p>
<p class="num-pre"><img src="images/un707-02.jpg" alt="images" /></p>
<p class="alpha-no-1">After calling this method, when will thread A become a candidate to get another turn at the CPU?</p>
<p class="alpha">A. After object B is notified, or after two seconds</p>
<p class="alpha">B. After the lock on B is released, or after two seconds</p>
<p class="alpha">C. Two seconds after object B is notified</p>
<p class="alpha">D. Two seconds after lock B is released</p>
<p class="que"><strong><a id="ch10ans7" href="ch10.xhtml#r_ch10ans7">7</a>.</strong>   Which are true? (Choose all that apply.)</p>
<p class="alpha">A. The <code>notifyAll()</code> method must be called from a synchronized context</p>
<p class="alpha">B. To call <code>wait()</code>, an object must own the lock on the thread</p>
<p class="alpha">C. The <code>notify()</code> method is defined in class <code>java.lang.Thread</code></p>
<p class="alpha">D. When a thread is waiting as a result of <code>wait()</code>, it releases its lock</p>
<p class="alpha">E. The <code>notify()</code> method causes a thread to immediately release its lock</p>
<p class="alpha">F. The difference between <code>notify()</code> and <code>notifyAll()</code> is that <code>notifyAll()</code> notifies all waiting threads, regardless of the object they’re waiting on</p>
<p class="que"><span id="page_708" epub:type="pagebreak"></span><strong><a id="ch10ans8" href="ch10.xhtml#r_ch10ans8">8</a>.</strong>   Given this scenario: This class is intended to allow users to write a series of messages so that each message is identified with a timestamp and the name of the thread that wrote the message:</p>
<p class="num-pre"><img src="images/un708-01.jpg" alt="images" /></p>
<p class="alpha-no-1">How can we ensure that instances of this class can be safely used by multiple threads?</p>
<p class="alpha">A. This class is already thread-safe</p>
<p class="alpha">B. Replacing <code>StringBuilder</code> with <code>StringBuffer</code> will make this class thread-safe</p>
<p class="alpha">C. Synchronize the <code>log()</code> method only</p>
<p class="alpha">D. Synchronize the <code>getContents()</code> method only</p>
<p class="alpha">E. Synchronize both <code>log()</code> and <code>getContents()</code></p>
<p class="alpha">F. This class cannot be made thread-safe</p>
<p class="que"><strong><a id="ch10ans9" href="ch10.xhtml#r_ch10ans9">9</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un708-02.jpg" alt="images" /></p>
<p class="alpha-no-1">What is the result of this code?</p>
<p class="alpha">A. It prints <code>X</code> and exits</p>
<p class="alpha">B. It prints <code>X</code> and never exits</p>
<p class="alpha">C. It prints <code>XY</code> and exits almost immediately</p>
<p class="alpha">D. It prints <code>XY</code> with a 10-second delay between <code>X</code> and <code>Y</code></p>
<p class="alpha">E. It prints <code>XY</code> with a 10,000-second delay between <code>X</code> and <code>Y</code></p>
<p class="alpha">F. The code does not compile</p>
<p class="alpha">G. An exception is thrown at runtime</p>
<p class="que1"><span id="page_709" epub:type="pagebreak"></span><strong><a id="ch10ans10" href="ch10.xhtml#r_ch10ans10">10</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un709-01.jpg" alt="images" /></p>
<p class="alpha-no-1">What is the result?</p>
<p class="alpha">A. <code>foo</code></p>
<p class="alpha">B. <code>MyThread foo</code></p>
<p class="alpha">C. <code>MyThread bar</code></p>
<p class="alpha">D. <code>foo bar</code></p>
<p class="alpha">E. <code>foo bar baz</code></p>
<p class="alpha">F. <code>bar foo</code></p>
<p class="alpha">G. Compilation fails</p>
<p class="alpha">H. An exception is thrown at runtime</p>
<p class="que1"><strong><a id="ch10ans11" href="ch10.xhtml#r_ch10ans11">11</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un709-02.jpg" alt="images" /></p>
<p class="num-pre"><span id="page_710" epub:type="pagebreak"></span><img src="images/un710-01.jpg" alt="images" /></p>
<p class="alpha-no-1">If the code compiles, which of the following pairs of method invocations could NEVER be executing at the same time? (Choose all that apply.)</p>
<p class="alpha">A. <code>x.a()</code> in <code>thread1</code>, and <code>x.a()</code> in <code>thread2</code></p>
<p class="alpha">B. <code>x.a()</code> in <code>thread1</code>, and <code>x.b()</code> in <code>thread2</code></p>
<p class="alpha">C. <code>x.a()</code> in <code>thread1</code>, and <code>y.a()</code> in <code>thread2</code></p>
<p class="alpha">D. <code>x.a()</code> in <code>thread1</code>, and <code>y.b()</code> in <code>thread2</code></p>
<p class="alpha">E. <code>x.b()</code> in <code>thread1</code>, and <code>x.a()</code> in <code>thread2</code></p>
<p class="alpha">F. <code>x.b()</code> in <code>thread1</code>, and <code>x.b()</code> in <code>thread2</code></p>
<p class="alpha">G. <code>x.b()</code> in <code>thread1</code>, and <code>y.a()</code> in <code>thread2</code></p>
<p class="alpha">H. <code>x.b()</code> in <code>thread1</code>, and <code>y.b()</code> in <code>thread2</code></p>
<p class="alpha">I. Compilation fails due to an error in declaring the <code>Runnable</code></p>
<p class="que1"><strong><a id="ch10ans12" href="ch10.xhtml#r_ch10ans12">12</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un710-03.jpg" alt="images" /></p>
<p class="num-pre"><span id="page_711" epub:type="pagebreak"></span><img src="images/un711-01.jpg" alt="images" /></p>
<p class="alpha-no-1">Which letters will eventually appear somewhere in the output? (Choose all that apply.)</p>
<p class="alpha">A. <code>A</code></p>
<p class="alpha">B. <code>B</code></p>
<p class="alpha">C. <code>C</code></p>
<p class="alpha">D. <code>D</code></p>
<p class="alpha">E. <code>E</code></p>
<p class="alpha">F. <code>F</code></p>
<p class="alpha">G. The answer cannot be reliably determined</p>
<p class="alpha">H. The code does not compile</p>
<p class="que1"><strong><a id="ch10ans13" href="ch10.xhtml#r_ch10ans13">13</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un711-02.jpg" alt="images" /></p>
<p class="alpha-no-1">And given the following five fragments:</p>
<p class="num-pre"><img src="images/un711-03.jpg" alt="images" /></p>
<p class="alpha-no-1"><span id="page_712" epub:type="pagebreak"></span>When the five fragments are inserted, one at a time at line 9, which are true? (Choose all that apply.)</p>
<p class="alpha">A. All five will compile</p>
<p class="alpha">B. Only one might produce the output <code>4 4</code></p>
<p class="alpha">C. Only one might produce the output <code>4 2</code></p>
<p class="alpha">D. Exactly two might produce the output <code>4 4</code></p>
<p class="alpha">E. Exactly two might produce the output <code>4 2</code></p>
<p class="alpha">F. Exactly three might produce the output <code>4 4</code></p>
<p class="alpha">G. Exactly three might produce the output <code>4 2</code></p>
<p class="que1"><strong><a id="ch10ans14" href="ch10.xhtml#r_ch10ans14">14</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un712-01.jpg" alt="images" /></p>
<p class="alpha-no-1">Which are true? (Choose all that apply.)</p>
<p class="alpha">A. Compilation fails</p>
<p class="alpha">B. The output could be <code>r1 r2 m1 m2</code></p>
<p class="alpha">C. The output could be <code>m1 m2 r1 r2</code></p>
<p class="alpha">D. The output could be <code>m1 r1 r2 m2</code></p>
<p class="alpha">E. The output could be <code>m1 r1 m2 r2</code></p>
<p class="alpha">F. An exception is thrown at runtime</p>
<p class="que1"><strong><a id="ch10ans15" href="ch10.xhtml#r_ch10ans15">15</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un712-02.jpg" alt="images" /></p>
<p class="num-pre"><span id="page_713" epub:type="pagebreak"></span><img src="images/un713-01.jpg" alt="images" /></p>
<p class="alpha-no-1">And given these two fragments:</p>
<p class="num-pre"><img src="images/un713-02.jpg" alt="images" /></p>
<p class="alpha-no-1">When fragment I or fragment II is inserted at line 5, which are true? (Choose all that apply.)</p>
<p class="alpha">A. An exception is thrown at runtime</p>
<p class="alpha">B. With fragment I, compilation fails</p>
<p class="alpha">C. With fragment II, compilation fails</p>
<p class="alpha">D. With fragment I, the output could be <code>yo dude dude yo</code></p>
<p class="alpha">E. With fragment I, the output could be <code>dude dude yo yo</code></p>
<p class="alpha">F. With fragment II, the output could be <code>yo dude dude yo</code></p>
<p class="que1"><strong><a id="ch10ans16" href="ch10.xhtml#r_ch10ans16">16</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un713-03.jpg" alt="images" /></p>
<p class="num-pre"><span id="page_714" epub:type="pagebreak"></span><img src="images/un714-01.jpg" alt="images" /></p>
<p class="alpha-no-1">Which are true? (Choose all that apply.)</p>
<p class="alpha">A. Compilation fails</p>
<p class="alpha">B. The output could be <code>4 4 2 3</code></p>
<p class="alpha">C. The output could be <code>4 4 2 2</code></p>
<p class="alpha">D. The output could be <code>4 4 4 2</code></p>
<p class="alpha">E. The output could be <code>2 2 4 4</code></p>
<p class="alpha">F. An exception is thrown at runtime</p>
<p class="que1"><strong><a id="ch10ans17" href="ch10.xhtml#r_ch10ans17">17</a>.</strong>   Given:</p>
<p class="num-pre"><img src="images/un714-02.jpg" alt="images" /></p>
<p class="alpha-no-1">And given these two fragments:</p>
<p class="num-pre"><img src="images/un714-03.jpg" alt="images" /></p>
<p class="alpha-no-1">When either fragment I or fragment II is inserted at line 7, which are true? (Choose all that apply.)</p>
<p class="alpha">A. Compilation fails</p>
<p class="alpha">B. With fragment I, an exception is thrown</p>
<p class="alpha">C. With fragment I, the output could be <code>4 2 4 2</code></p>
<p class="alpha">D. With fragment I, the output could be <code>4 4 2 3</code></p>
<p class="alpha">E. With fragment II, the output could be <code>2 4 2 4</code></p>
<p class="que1"><span id="page_715" epub:type="pagebreak"></span><strong><a id="ch10ans18" href="ch10.xhtml#r_ch10ans18">18</a>.</strong>   You have two threads, t1 and t2, attemping to access a shared resource, and t2 is always descheduled when it tries to access that resource. What is this kind of problem called?</p>
<p class="alpha">A. A race condition</p>
<p class="alpha">B. Deadlock</p>
<p class="alpha">C. Livelock</p>
<p class="alpha">D. Starvation</p>
<p class="alpha">E. Synchronization</p>
<p class="alpha">F. Multitasking</p>
<h3 class="h3b" id="ch10lev2sec16"><span id="page_716" epub:type="pagebreak"></span><img src="images/aself.jpg" alt="Images" /> SELF TEST ANSWERS</h3>
<p class="que-q"><strong><a href="ch10.xhtml#ch10ans1" id="r_ch10ans1">1</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>C</strong> is correct. The class implements the <code>Runnable</code> interface with a legal <code>run()</code> method.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A</strong> is incorrect because interfaces are implemented, not extended. <strong>B</strong> is incorrect because even though the class has a valid <code>public void run()</code> method, it does not implement the <code>Runnable</code> interface. <strong>D</strong> is incorrect because the <code>run()</code> method must be public. <strong>E</strong> is incorrect because the method to implement is <code>run()</code>, not <code>start()</code>. Note that we could replace the first line of code with:</p>
<p class="num-pre"><img src="images/un716-01.jpg" alt="images" /></p>
<p class="alpha-no">and dispense with <code>MyRunnable</code> completely. (OCP Objective 10.1)</p>
<p class="que-q"><strong><a href="ch10.xhtml#ch10ans2" id="r_ch10ans2">2</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>D</strong> is correct. The thread <code>MyThread</code> will start and loop three times (from 0 to 2).</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A</strong> is incorrect because the <code>Thread</code> class implements the <code>Runnable</code> interface; therefore, in line 6, <code>Thread</code> can take an object of type <code>Thread</code> as an argument in the constructor (this is NOT recommended). <strong>B</strong> and <strong>C</strong> are incorrect because the variable <code>i</code> in the <code>for</code> loop starts with a value of 0 and ends with a value of 2. <strong>E</strong> is incorrect based on the above. (OCP Objective 10.1)</p>
<p class="que-q"><strong><a href="ch10.xhtml#ch10ans3" id="r_ch10ans3">3</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>D</strong> is correct. The <code>sleep()</code> method must be enclosed in a <code>try/catch</code> block, or the method <code>printAll()</code> must declare it throws the <code>InterruptedException</code>.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>E</strong> is incorrect, but it would be correct if the <code>InterruptedException</code> was dealt with (<strong>A</strong> is too precise). <strong>B</strong> is incorrect (even if the <code>InterruptedException</code> was dealt with) because all Java code, including the <code>main()</code> method, runs in threads. <strong>C</strong> is incorrect. The <code>sleep()</code> method is <code>static</code>; it always affects the currently executing thread. (OCP Objective 10.1)</p>
<p class="que-q"><strong><a href="ch10.xhtml#ch10ans4" id="r_ch10ans4">4</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>B</strong> and <strong>F</strong> are correct. By marking the methods as <code>synchronized</code>, the threads will get the lock of the <code>this</code> object before proceeding. Only one thread will be setting or reading at any given moment, thereby assuring that <code>read()</code> always returns the addition of a valid pair.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A</strong> is incorrect because it is not synchronized; therefore, there is no guarantee that the values added by the <code>read()</code> method belong to the same pair. <strong>C</strong> and<strong> D</strong> are incorrect; only objects can be used to synchronize on. <strong>E</strong> is incorrect because it fails to compile—it is not possible to select other objects (even <code>this</code>) to synchronize on when declaring a method as <code>synchronized</code>. (OCP Objectives 10.2 and 10.3)</p>
<p class="que-q"><strong><a href="ch10.xhtml#ch10ans5" id="r_ch10ans5">5</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>D</strong> is correct. 1 and 2 will be printed, but there will be no return from the <code>wait</code> call because no other thread will notify the main thread, so 3 will never be printed. It’s frozen at line 7.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A</strong> is incorrect; <code>IllegalMonitorStateException</code> is an unchecked exception. <strong>B</strong> and <strong>C</strong> are incorrect; 3 will never be printed, since this program will wait forever.<strong> E</strong> is incorrect because <code>IllegalMonitorStateException</code> will never be thrown because the <code>wait()</code> is done on <code>args</code> within a block of code synchronized on <code>args</code>. <strong>F</strong> is incorrect because any object can be used to synchronize on, and <code>this</code> and <code>static</code> don’t mix. (OCP Objective 10.3)</p>
<p class="que-q"><span id="page_717" epub:type="pagebreak"></span><strong><a href="ch10.xhtml#ch10ans6" id="r_ch10ans6">6</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>A</strong> is correct. Either of the two events will make the thread a candidate for running again.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>B</strong> is incorrect because a waiting thread will not return to runnable when the lock is released unless a notification occurs. <strong>C</strong> is incorrect because the thread will become a candidate immediately after notification. <strong>D</strong> is also incorrect because a thread will not come out of a waiting pool just because a lock has been released. (OCP Objective 10.3)</p>
<p class="que-q"><strong><a href="ch10.xhtml#ch10ans7" id="r_ch10ans7">7</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>A</strong> is correct because <code>notifyAll()</code> (and <code>wait()</code> and <code>notify()</code>) must be called from within a synchronized context. <strong>D</strong> is a correct statement.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>B</strong> is incorrect because to call <code>wait()</code>, the thread must own the lock on the object that <code>wait()</code> is being invoked on, not the other way around. <strong>C</strong> is incorrect because <code>notify()</code> is defined in <code>java.lang.Object</code>. <strong>E</strong> is incorrect because <code>notify()</code> will not cause a thread to release its locks. The thread can only release its locks by exiting the synchronized code. <strong>F</strong> is incorrect because <code>notifyAll()</code> notifies all the threads waiting on a particular locked object, not all threads waiting on <em>any</em> object. (OCP Objectives 10.2 and 10.3)</p>
<p class="que-q"><strong><a href="ch10.xhtml#ch10ans8" id="r_ch10ans8">8</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>E</strong> is correct because synchronizing the <code>public</code> methods is sufficient to make this safe, which is why<strong> F</strong> is incorrect. This class is not thread-safe unless some sort of synchronization protects the changing data.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>B</strong> is incorrect because although a <code>StringBuffer</code> is synchronized internally, we call <code>append()</code> multiple times, and nothing would prevent two simultaneous <code>log()</code> calls from mixing up their messages. <strong>C</strong> and <strong>D</strong> are incorrect because if one method remains unsynchronized, it can run while the other is executing, which could result in reading the contents while one of the messages is incomplete, or worse. (You don’t want to call <code>toString()</code> on the <code>StringBuffer</code> as it’s resizing its internal character array.) <strong>F</strong> is incorrect based on the information above.(OCP Objective 10.3)</p>
<p class="que-q"><strong><a href="ch10.xhtml#ch10ans9" id="r_ch10ans9">9</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>G</strong> is correct. The code does not acquire a lock on <code>t</code> before calling <code>t.wait()</code>, so it throws an <code>IllegalMonitorStateException</code>. The method is <code>synchronized</code>, but it’s not synchronized on <code>t</code> so the exception will be thrown. If the wait were placed inside a <code>synchronized(t)</code> block, then <strong>D</strong> would be correct.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B, C, D, E,</strong> and <strong>F</strong> are incorrect based on the logic described above. (OCP Objective 10.3)</p>
<p class="que-q1"><strong><a href="ch10.xhtml#ch10ans10" id="r_ch10ans10">10</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>B</strong> is correct. In the first line of <code>main</code> we’re constructing an instance of an anonymous inner class extending from <code>MyThread</code>. So the <code>MyThread</code> constructor runs and prints <code>MyThread</code>. Next, <code>main()</code> invokes <code>start()</code> on the new thread instance, which causes the overridden <code>run()</code> method (the <code>run()</code> method in the anonymous inner class) to be invoked.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, C, D, E, F, G,</strong> and <strong>H</strong> are incorrect based on the logic described above. (OCP Objective 10.1)</p>
<p class="que-q1"><span id="page_718" epub:type="pagebreak"></span><strong><a href="ch10.xhtml#ch10ans11" id="r_ch10ans11">11</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>A, F,</strong> and <strong>H</strong> are correct. <strong>A</strong> is correct because when <code>synchronized</code> instance methods are called on the same <em>instance,</em> they block each other. <strong>F</strong> and <strong>H</strong> can’t happen because <code>synchronized static</code> methods in the same class block each other, regardless of which instance was used to call the methods. (An instance is not required to call <code>static</code> methods; only the class.)</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>C,</strong> although incorrect, could happen because <code>synchronized</code> instance methods called on different instances do not block each other. <strong>B, D, E,</strong> and <strong>G</strong> are incorrect but also could all happen because instance methods and <code>static</code> methods lock on different objects and do not block each other. <strong>I</strong> is incorrect because the code compiles. (OCP Objectives 10.2 and 10.3)</p>
<p class="que-q1"><strong><a href="ch10.xhtml#ch10ans12" id="r_ch10ans12">12</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>A, C, D, E,</strong> and<strong> F</strong> are correct. This may look like <code>laurel</code> and <code>hardy</code> are battling to cause the other to <code>sleep()</code> or <code>wait()</code>—but that’s not the case. Since <code>sleep()</code> is a <code>static</code> method, it affects the current thread, which is <code>laurel</code> (even though the method is invoked using a reference to <code>hardy</code>). That’s misleading, but perfectly legal, and the <code>Thread laurel</code> is able to sleep with no exception, printing <strong>A</strong> and <strong>C</strong> (after at least a one-second delay). Meanwhile, <code>hardy</code> tries to call <code>laurel.wait()</code>—but <code>hardy</code> has not <code>synchronized</code> on <code>laurel</code>, so calling <code>laurel.wait()</code> immediately causes an <code>IllegalMonitorStateException</code>, and so <code>hardy</code> prints <strong>D</strong>, <strong>E</strong>, and <strong>F</strong>. Although the <em>order</em> of the output is somewhat indeterminate (we have no way of knowing whether <strong>A</strong> is printed before <strong>D</strong>, for example), it is guaranteed that <strong>A, C, D, E,</strong> and <strong>F</strong> will all be printed in some order, eventually—so <strong>G</strong> is incorrect.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>B, G,</strong> and <strong>H</strong> are incorrect based on the above. (OCP Objective 10.2)</p>
<p class="que-q1"><strong><a href="ch10.xhtml#ch10ans13" id="r_ch10ans13">13</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>C</strong> and <strong>D</strong> are correct. Fragment I doesn’t start a new thread. Fragment II doesn’t compile. Fragment III creates a new thread but doesn’t start it. Fragment IV creates a new thread and invokes <code>run()</code> directly, but it doesn’t start the new thread. Fragment V creates and starts a new thread.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B, E, F,</strong> and <strong>G</strong> are incorrect based on the above. (OCP Objective 10.1)</p>
<p class="que-q1"><strong><a href="ch10.xhtml#ch10ans14" id="r_ch10ans14">14</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>A</strong> is correct. The <code>join()</code> must be placed in a <code>try/catch</code> block. If it were, answers <strong>B</strong> and <strong>D</strong> would be correct. The <code>join()</code> causes the main thread to pause and join the end of the other thread, meaning <code>"m2"</code> must come last.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>B, C, D, E,</strong> and <strong>F</strong> are incorrect based on the above. (OCP Objective 10.1)</p>
<p class="que-q1"><strong><a href="ch10.xhtml#ch10ans15" id="r_ch10ans15">15</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>F</strong> is correct. With Fragment I, the <code>chat</code> method is <code>synchronized</code>, so the two threads can’t swap back and forth. With either fragment, the first output must be <code>yo</code>.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B, C, D,</strong> and <strong>E</strong> are incorrect based on the above. (OCP Objective 10.3)</p>
<p class="que-q1"><strong><a href="ch10.xhtml#ch10ans16" id="r_ch10ans16">16</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>F</strong> is correct. When <code>run()</code> is invoked, it is with a new instance of <code>ChicksYack</code> and <code>c</code> has not been assigned to an object. If <code>c</code> were static, then because <code>yack</code> is <code>synchronized</code>, answers <strong>C</strong> and <strong>E</strong> would have been correct.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B, C, D,</strong> and <strong>E</strong> are incorrect based on the above. (OCP Objectives 10.1 and 10.3)</p>
<p class="que-q1"><span id="page_719" epub:type="pagebreak"></span><strong><a href="ch10.xhtml#ch10ans17" id="r_ch10ans17">17</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>C</strong> and <strong>E</strong> are correct. <strong>E</strong> should be obvious. <strong>C</strong> is correct because, even though <code>move()</code> is <code>synchronized</code>, it’s being invoked on two different objects.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B,</strong> and <strong>D</strong> are incorrect based on the above. (OCP Objective 10.3)</p>
<p class="que-q1"><strong><a href="ch10.xhtml#ch10ans18" id="r_ch10ans18">18</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>D</strong> is correct. Starvation occurs when one or more threads cannot get access to a resource.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B, C, E</strong> and <strong>F</strong> are incorrect based on the above. (OCP Objective 10.2)</p>
<h3 class="h3" id="ch10lev2sec17">EXERCISE ANSWERS</h3>
<h4 class="h4">Exercise 10-1: Creating a Thread and Putting It to Sleep</h4>
<p class="noindent">The final code should look something like this:</p>
<p class="imageip"><img src="images/un719-01.jpg" alt="images" /></p>
<h4 class="h4">Exercise 10-2: Synchronizing a Block of Code</h4>
<p class="noindent">Your code might look something like this when completed:</p>
<p class="imageip"><img src="images/un719-02.jpg" alt="images" /></p>
<p class="imageip"><span id="page_720" epub:type="pagebreak"></span><img src="images/un720-01.jpg" alt="images" /></p>
<p class="noindent">Just for fun, try removing lines 1 and 2 and then run the program again. It will be unsynchronized—watch what happens.</p>
</section>
</div>
</body>
</html>