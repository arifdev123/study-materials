<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
<head>
  <meta charset="UTF-8" />
  <title>12 JDBC</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  <link type="text/css" rel="stylesheet" media="all" href="core.css" />
</head>
<body>
  <div id="sbo-rt-content"><section epub:type="chapter">
<p class="image"><img src="images/common-01.jpg" alt="Images" /></p>
<h2 class="h2p" id="ch12"><span id="page_813" epub:type="pagebreak"></span>12</h2>
<h2 class="h2p1">JDBC</h2>
<p class="title-o"><span class="white">CERTIFICATION OBJECTIVES</span></p>
<p class="toc-l">•       Describe the interfaces that Make Up the Core of the JDBC API Including the Driver, Connection, Statement, and ResultSet Interfaces and Their Relationship to Provider Implementations</p>
<p class="toc-l">•       Identify the Components Required to Connect to a Database Using the DriverManager Class Including the JDBC URL</p>
<p class="toc-l">•       Submit Queries and Read Results from the Database Including Creating Statements, Returning Result Sets, Iterating Through the Results, and Properly Closing Result Sets, Statements, and Connections</p>
<p class="toc-lq"><img src="images/tick.jpg" alt="Images" />     Two-Minute Drill</p>
<p class="toc-q"><strong>Q&amp;A</strong>   Self Test</p>
<p class="noindent-d"><span id="page_814" epub:type="pagebreak"></span><span class="dropcap">T</span>his chapter covers the JDBC API that was added for the Java SE 7 and 8 exams. The exam developers have long felt that this API is truly a core feature of the language, and being able to demonstrate proficiency with JDBC goes a long way toward demonstrating your skills as a Java programmer.</p>
<p class="indent">Interestingly, JDBC has been a part of the language since JDK version 1.1 (1997) when JDBC 1.0 was introduced. Since then, there has been a steady progression of updates to the API, roughly one major release for each even-numbered JDK release, with the last major update being JDBC 4.0, released in 2006 with Java SE 6. In Java SE 7 and 8, JDBC got some minor updates and is now at version 4.2. While the focus of the exam is on JDBC 4.<em>x</em>, there may be questions about the differences between loading a driver with a JDBC 3.0 and JDBC 4.<em>x</em> implementation, so we’ll talk about that as well.</p>
<p class="indent">The good news is that the exam is not going to test your ability to write SQL statements. That would be an exam all by itself (maybe even more than one—SQL is a BIG topic!). But you will need to recognize some basic SQL syntax and commands, so we’ll start by spending some time covering the basics of relational database systems and give you enough SQL to make you popular at database parties. If you feel you have experience with SQL and understand database concepts, you might just skim the first section or skip right to the first exam objective and dive right in.</p>
<h3 class="h3-a" id="ch12lev1sec1"><strong>Starting Out: Introduction to Databases and JDBC</strong></h3>
<p class="noindent">When you think of organizing information and storing it in some easily understood way, a spreadsheet or a table is often the first approach you might take. A spreadsheet or a table is a natural way of categorizing information: The first row of a table defines the sort of information that the table will hold, and each subsequent row contains a set of data that is related to the key we create on the left. For example, suppose you wanted to chart your monthly spending for several types of expenses (<a href="ch12.xhtml#ch12tab1">Table 12-1</a>).</p>
<p class="tabcap" id="ch12tab1"><span class="table"><strong>TABLE 12-1</strong></span> Methods to Map, Filter, and Reduce</p>
<p class="imaget"><img src="images/tab12-01.jpg" alt="Images" /></p>
<p class="indent"><span id="page_815" epub:type="pagebreak"></span>From the data in the chart, we can determine that your overall expenses are increasing month to month in the first three months of this year. But notice that without the table, without a relationship between the month and the data in the columns, you would just have a pile of receipts with no way to draw out important conclusions, such as</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Assuming you drove the same number of miles per month, gas is getting pricey—maybe it is time to get a Prius.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   You are eating out more month to month (or the price of eating out is going up)—maybe it’s time to start doing some meal planning.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   And maybe you need to be a little less social—that phone bill is high.</p>
<p class="noindent">The point is that this small sample of data is the key to understanding a relational database system. A relational database is really just a software application designed to store and manipulate data in tables. The software itself is actually called a Relational Database Management System (RDBMS), but many people shorten that to just “database”—so know that going forward, when we refer to a database, we are actually talking about an RDBMS (the whole system). What the relational management system adds to a database is the ability to define relationships between tables. It also provides a language to get data in and out in a meaningful way.</p>
<p class="indent">Looking at the simple table in <a href="ch12.xhtml#ch12tab1">Table 12-1</a>, we know that the data in the columns, Gas, EatingOut, Utilities, and Phone, are grouped by the months January, February, and so on. The month is unique to each row and identifies this row of data. In database parlance, the month is a “primary key.” A primary key is generally required for a database table to identify which row of the table you want and to make sure that there are no duplicate rows.</p>
<p class="indent">Extending this a little further, if the data in <a href="ch12.xhtml#ch12tab1">Table 12-1</a> were stored in a database, I could ask the database (write a query) to give me all of the data for the month of January (again, my primary key is “month” for this table). I might write something like:</p>
<p class="bq">“Give me all of my expenses for January.”</p>
<p class="noindent">The result would be something like:</p>
<p class="imageip"><img src="images/un815-01.jpg" alt="images" /></p>
<p class="indent">This kind of query is what makes a database so powerful. With a relatively simple language, you can construct some really powerful queries in order to manipulate your data to tell a story. In most RDBMSs, this language is called the Structured <span id="page_816" epub:type="pagebreak"></span>Query Language (SQL). The same query we wrote out in a sentence earlier would be expressed like this in SQL:</p>
<p class="imageip"><img src="images/un816-01.jpg" alt="images" /></p>
<p class="noindent">which can be translated to “select all of the columns (<code>*</code>) from my table named ‘Expenses’ where the month column is equal to the string <code>'January'</code>.” Let’s look a bit more at how we “talk” to a database and what other sorts of queries we can make with tables in a relational database.</p>
<h4 class="h4" id="ch12lev2sec1">Talking to a Database</h4>
<p class="noindent">There are three important concepts when working with a database:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Creating a connection to the database</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Creating a statement to execute in the database</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   Getting back a set of data that represents the results</p>
<p class="noindent">Let’s look at these concepts in more detail.</p>
<p class="indent">Before we can communicate with the software that manages the database, before we can send it a query, we need to make a connection with the RDBMS itself. There are many different types of connections, and a lot of underlying technology to describe the connection itself, but in general, to communicate with an RDBMS, we need to open a connection using an IP address and port number to the database. Once we have established the connection, we need to send it some parameters (such as a username and password) to authenticate ourselves as a valid user of the RDBMS. Finally, assuming all went well, we can send queries through the connection. This is like logging into your online account at a bank. You provide some credentials, a username and password, and a connection is established and opened between you and the bank. Later in the chapter, when we start writing code, we’ll open a connection using a Java class called the <code>DriverManager</code>, and in one request, pass in the database name, our username, and password.</p>
<p class="indent">Once we have established a connection, we can use some type of application (usually provided by the database vendor) to send query statements to the database, have them executed in the database, and get a set of results returned. A set of results can be one row, as we saw before when we asked for the data from the month of January, or several rows. For example, suppose we wanted to see all of the Gas expenses from our Expenses table. We might query the database like this:</p>
<p class="imageip"><img src="images/un816-02.jpg" alt="images" /></p>
<p class="noindent"><span id="page_817" epub:type="pagebreak"></span>Or as a SQL query:</p>
<p class="imageip"><img src="images/un817-01.jpg" alt="images" /></p>
<p class="noindent">The set of results that would “return” from my query would be three rows, and each row would contain one column.</p>
<p class="image-t"><img src="images/t0817-01.jpg" alt="images" /></p>
<p class="indent">An important aspect of a database is that the data is presented back to you exactly the same way that it is stored. Since Gas expense is a column, the query will return three rows (one for January, one for February, and one for March). Note that because we did not ask the database to include the Month column in the results, all we got was the Gas column. The results do preserve the fact that Gas is a column and not a row and, in general, present the data in the same row-and-column order in which it is stored in the database.</p>
<h5 class="h5">SQL Queries</h5>
<p class="noindent">Let’s look a bit more at the syntax of SQL, the language used to write queries in a database. There are really four basic SQL queries that we are going to use in this chapter and that are common to manipulating data in a database. In summary, the SQL commands we are interested in are used to perform CRUD operations.</p>
<p class="indent">Like most terms presented in all caps, CRUD is an acronym and means <em>Create, Read, Update,</em> and<em> Delete.</em> These are the four basic operations for data in a database. They are represented by four distinct SQL commands, detailed in <a href="ch12.xhtml#ch12tab2">Table 12-2</a>.</p>
<p class="tabcap" id="ch12tab2"><span class="table"><strong>TABLE 12-2</strong></span> Example SQL CRUD Commands</p>
<p class="imaget"><img src="images/tab12-02.jpg" alt="Images" /></p>
<p class="indent">Here is a quick explanation for the examples in <a href="ch12.xhtml#ch12tab2">Table 12-2</a>:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>INSERT</strong>   Add a row to the table Expenses, and set each of the columns in the table to the values expressed in the parentheses.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>SELECT with WHERE</strong>   You have already seen the SELECT clause with a WHERE clause, so you know that this SQL statement returns a single row identified by the primary key—the Month column. Think of this statement as a refinement to Read—more like a Find or Find by primary key.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>SELECT</strong>   When the SELECT clause does not have a WHERE clause, we are asking the database to return every row. Further, because we are using an asterisk (*) following the SELECT, we are asking for every column. Basically, it is a dump of the data shown in Table 15-1. Think of this statement as a Read All.</p>
<p class="bull"><span id="page_818" epub:type="pagebreak"></span><img class="inline" src="images/box.jpg" alt="Images" />   <strong>UPDATE</strong>   Change the data in the Phone and EatingOut cells to the new data provided for February.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>DELETE</strong>   Remove a row altogether from the database where the Month is April.</p>
<p class="indent">Really, this is all the SQL you need to know for this chapter. There are many other SQL commands, but this is the core set. If we need to go beyond this set of four commands in the chapter, we will cover them as they come up. Now, let’s look at a more detailed database example that we will use as the example set of tables for this chapter, using the data requirements of a small bookseller, Bob’s Books.</p>
<p class="text-icon"><img src="images/onjob.jpg" alt="Images" /></p>
<p class="noindent"><strong><em>SQL commands, like SELECT, INSERT, UPDATE, and so on, are case-insensitive. So it is largely by convention (and one we will use in this chapter) that we use all capital letters for SQL commands and key words, such as WHERE, FROM, LIKE, INTO, SET, and VALUES. SQL table names and column names, also called identifiers, can be case-sensitive or case-insensitive, depending on the database. The example code shown in this chapter uses a case-insensitive database, so again, just for convention, we will use upper camel case, that is, the first letter of each noun capitalized and the rest in lowercase.</em></strong></p>
<p class="indent"><strong><em>One final note about case—all databases preserve case when a string is delimited—that is, when it is enclosed in quotes. So a SQL clause that uses single or double quotation marks to delimit an identifier will preserve the case of the identifier.</em></strong></p>
<h4 class="h4" id="ch12lev2sec2"><span id="page_819" epub:type="pagebreak"></span>Bob’s Books, Our Test Database</h4>
<p class="noindent">In this section, we’ll describe a small database with a few tables and a few rows of data. As we work through the various JDBC topics in this chapter, we’ll work with this database.</p>
<p class="indent">Bob is a small bookseller who specializes in children’s books. Bob has designed his data around the need to sell his books online using a database (which one doesn’t really matter) and a Java application. Bob has decided to use the JDBC API to allow him to connect to a database and perform queries through a Java application.</p>
<p class="indent">To start, let’s look at the organization of Bob’s data. In a database, the organization and specification of the tables is called the database schema (<a href="ch12.xhtml#ch12fig1">Figure 12-1</a>). Bob’s is a relatively simple schema, and again, for the purposes of this chapter, we are going to concentrate on just four tables from Bob’s schema.</p>
<p class="figcap" id="ch12fig1"><span class="figure"><strong>FIGURE 12-1</strong></span> Bob’s BookSeller database schema</p>
<p class="imagef"><img src="images/fig12-01.jpg" alt="Images" /></p>
<p class="indent">This is a relatively simple schema that represents a part of the database for a small bookstore. In the schema shown, there is a table for Customer (<a href="ch12.xhtml#ch12tab3">Table 12-3</a>). This table stores data about Bob’s customers—a customer ID, first name and last name, an e-mail address, and phone number. Postal addresses and other information could be stored in another table.</p>
<p class="tabcap" id="ch12tab3"><span class="table"><strong>TABLE 12-3</strong></span> Bob’s Books Customer Table Sample Data</p>
e<p class="imaget"><img src="images/tab12-03.jpg" alt="Images" /></p>
<p class="indent">The next three tables we will look at represent the data required to store information about books that Bob sells. Because a book is a more complex set of data than a customer, we need to use one table for information about books, one for information about authors, and a third to create a relationship between books and authors.</p>
<p class="indent"><span id="page_820" epub:type="pagebreak"></span>Suppose that you tried to store a book in a single table with a column for the ISBN (International Standard Book Number), title, and author name. For many books, this would be fine. But what happens if a book has two authors? Or three authors? Remember that one requirement for a database table is a unique primary key, so you can’t simply repeat the ISBN in the table. In fact, having two rows with the same primary key will violate a key constraint in relational database design: the primary key of every row must be unique.</p>
<p class="imagef"><img src="images/t0820-01.jpg" alt="images" /></p>
<p class="indent">Instead, there needs to be a way to have a separate table of books and authors and some way to link them together. Bob addressed this issue by placing Books in one table (<a href="ch12.xhtml#ch12tab4">Table 12-4</a>) and Authors (<a href="ch12.xhtml#ch12tab5">Table 12-5</a>) in another. The primary key for Books is the ISBN number, and therefore, each Book entry will be unique. For the Author table, Bob is creating a unique AuthorID for each author in the table.<span id="page_821" epub:type="pagebreak"></span></p>
<p class="tabcap" id="ch12tab4"><span class="table"><strong>TABLE 12-4</strong></span> Bob’s Books Sample Data for the “Books” Table</p>
<p class="imaget"><img src="images/tab12-04.jpg" alt="Images" /></p>
<p class="tabcap" id="ch12tab5"><span class="table"><strong>TABLE 12-5</strong></span> Bob’s Books Author Table Sample Data for the “Authors” Table</p>
<p class="imaget"><img src="images/tab12-05.jpg" alt="Images" /></p>
<p class="indent">To tie Authors to Books and Books to Authors, Bob has created a third table called Books_by_Author. This is a unique table type in a relational database. This table is called a <em>join </em>table. In a join table, there are no primary keys—instead, all the columns represent data that can be used by other tables to create a relationship. These columns are referred to as foreign keys—they represent a primary key in <span id="page_822" epub:type="pagebreak"></span>another table. Looking at the last two rows of this table, you can see that the Book with the ISBN 9780545236 has two authors: author id 1008 (Mary Rodgers) and 1009 (Heather Hatch). Using this join table, we can combine the two sets of data without needing duplicate entries in either table. We’ll return to the concept of a join table later in the chapter.</p>
<p class="tabcap" id="ch12tab6"><span class="table"><strong>TABLE 12-6</strong></span> Bob’s Books Books by Author Sample Data</p>
<p class="imaget"><img src="images/tab12-06.jpg" alt="Images" /></p>
<p class="indent">A complete Bob’s Books database schema would include tables for publishers, addresses, stock, purchase orders, and other data that the store needs to run its business. But for our purposes, this part of the schema is sufficient. Using this schema, we can write SQL queries using the SQL CRUD commands you learned earlier.</p>
<p class="indent">To summarize, before looking at JDBC, you should now know about connections, statements, and result sets:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   A connection is how an application communicates with a database.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   A statement is a SQL query that is executed on the database.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   A result set is the data that is returned from a SELECT statement.</p>
<p class="noindent">Having these concepts down, we can use Bob’s Books simple schema to frame some common uses of the JDBC API to submit SQL queries and get results in a Java application.</p>
<p class="title-o"><span id="page_823" epub:type="pagebreak"></span><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch12lev1sec2"><strong>Core Interfaces of the JDBC API (OCP Objective 11.1)</strong></h3>
<p class="noindent"><em>11.1   Describe the interfaces that make up the core of the JDBC API including the Driver, Connection, Statement, and ResultSet interfaces and their relationship to provider implementations.</em></p>
<p class="indentt">As we mentioned in the previous section, the purpose of a relational database is really threefold:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   To provide storage for data in tables</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   To provide a way to create relationships between the data—just as Bob did with the Authors, Books, and Books_by_Author tables</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   To provide a language that can be used to get the data out, update the data, remove the data, and create new data</p>
<p class="indent">The purpose of JDBC is to provide an application programming interface (API) for Java developers to write Java applications that can access and manipulate relational databases and use SQL to perform CRUD operations.</p>
<p class="indent">Once you understand the basics of the JDBC API, you will be able to access a huge list of databases. One of the driving forces behind JDBC was to provide a standard way to access relational databases, but JDBC can also be used to access file systems and object-oriented data sources. The key is that the API provides an abstract view of a database connection, statements, and result sets. These concepts are represented in the API as interfaces in the <code>java.sql</code> package: <code>Connection</code>, <code>Statement</code>, and <code>ResultSet</code>, respectively. What these interfaces define are the <em>contracts</em> between you and the implementing class. In truth, you may not know (nor should you care) <em>how</em> the implementation class works. As long as the implementation class implements the interface you need, you are assured that the methods defined by the interface exist and you can invoke them.</p>
<p class="indent">The <code>java.sql.Connection</code> interface defines the contract for an object that represents the connection with a relational database system. Later, we will look at the methods of this contract, but for now, an instance of a <code>Connection</code> is what we need to communicate with the database. How the <code>Connection</code> interface <span id="page_824" epub:type="pagebreak"></span>is implemented is vendor dependent, and again, we don’t need to worry so much about the how—as long as the vendor follows the contract, we are assured that the object that represents a <code>Connection</code> will allow us to work with a database connection.</p>
<p class="indent">The <code>Statement</code> interface provides an abstraction of the functionality needed to get a SQL statement to execute on a database, and a <code>ResultSet</code> interface is an abstraction functionality needed to process a result set (the table of data) that is returned from the SQL query when the query involves a SQL SELECT statement.</p>
<p class="indent">The classes that implement <code>Connection</code>, <code>Statement</code>, <code>ResultSet</code>, and a number of other interfaces we will look at shortly are created by the vendor of the database we are using. The vendor understands their database product better than anyone else, so it makes sense that they create these classes. And it allows the vendor to optimize or hide any special characteristics of their product. The collection of the implementation classes is called the JDBC driver. A JDBC driver (lowercase “d“) is the collection of classes required to support the API, whereas Driver (uppercase “D“) is one of the implementations required in a driver.</p>
<p class="indent">A JDBC driver is typically provided by the vendor in a JAR or ZIP file. The implementation classes of the driver must meet a minimum set of requirements in order to be JDBC compliant. The JDBC specification provides a list of the functionality that a vendor must support and what functionality a vendor may optionally support.</p>
<p class="indent">Here is a partial list of the requirements for a JDBC driver. For more details, please read the specification (JSR-221). Note that the details of implementing a JDBC driver are NOT on the exam.</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Fully implement the interfaces: <code>java.sql.Driver</code>, <code>java.sql.DatabaseMetaData</code>, <code>java.sql.ResultSetMetaData</code>.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Implement the <code>java.sql.Connection</code> interface. (Note that some methods are optional depending on the SQL version the database supports—more on SQL versions later in the chapter.)</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Implement <code>java.sql.Statement</code>, and <code>java.sql.PreparedStatement</code>.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Implement the <code>java.sql.CallableStatement</code> interfaces if the database supports stored procedures. Again, more on this interface later in the chapter.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Implement the <code>java.sql.ResultSet</code> interface.</p>
<p class="title-o"><span id="page_825" epub:type="pagebreak"></span><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch12lev1sec3"><strong>Connect to a Database Using DriverManager (OCP Objective 11.2)</strong></h3>
<p class="noindent"><em>11.2   Identify the components required to connect to a database using the DriverManager class including the JDBC URL</em></p>
<p class="indentt">Not all of the types defined in the JDBC API are interfaces. One important class for JDBC is the <code>java.sql.DriverManager</code> class. This concrete class is used to interact with a JDBC driver and return instances of <code>Connection</code> objects to you. Conceptually, the way this works is by using a Factory design pattern. Next, we’ll look at <code>DriverManager</code> in more detail.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>Let’s take this opportunity to see the factory design pattern in use. In a factory pattern, a concrete class with static methods is used to create instances of objects that implement an interface. For example, suppose we wanted to create an instance of a <code>Vehicle</code> object:</em></strong></p>
<p class="noindent1"><img src="images/un825-01.jpg" alt="images" /></p>
<p class="noindent"><strong><em>We need an implementation of <code>Vehicle</code> in order to use this contract. So we design a <code>Car</code>:</em></strong></p>
<p class="noindent1"><img src="images/un825-02.jpg" alt="images" /></p>
<p class="noindent"><span id="page_826" epub:type="pagebreak"></span><strong><em>In order to use the <code>Car</code>, we could create one:</em></strong></p>
<p class="noindent1"><img src="images/un826-01.jpg" alt="images" /></p>
<p class="noindent"><strong><em>However, here it would be better to use a factory—that way, we need not know anything about the actual implementation, and, as we will see later with <code>DriverManager</code>, we can use methods of the factory to dynamically determine which implementation to use at runtime.</em></strong></p>
<p class="noindent1"><img src="images/un826-02.jpg" alt="images" /></p>
<p class="noindent"><strong><em>The factory in this case could create a different car based on the string passed to the static <code>getVehicle()</code> method—something like this:</em></strong></p>
<p class="noindent1"><img src="images/un826-03.jpg" alt="images" /></p>
<p class="noindent"><strong><em><code>DriverManager</code> uses this factory pattern to “construct“ an instance of a <code>Connection</code> object by passing a string to its <code>getConnection()</code> method.</em></strong></p>
</div>
<h4 class="h4" id="ch12lev2sec3">The DriverManager Class</h4>
<p class="noindent">The <code>DriverManager</code> class is a concrete, utility class in the JDBC API with static methods. You will recall that static or class methods can be invoked by other classes using the class name. One of those methods is <code>getConnection()</code>, which we look at next.</p>
<p class="indent"><span id="page_827" epub:type="pagebreak"></span>The <code>DriverManager</code> class is so named because it manages which JDBC driver implementation you get when you request an instance of a <code>Connection</code> through the <code>getConnection()</code> method.</p>
<p class="indent">There are several overloaded <code>getConnection</code> methods, but they all share one common parameter: a <code>String</code> URL. One pattern for <code>getConnection</code> is</p>
<p class="imageip"><img src="images/un827-01.jpg" alt="images" /></p>
<p class="noindent">For example:</p>
<p class="imageip"><img src="images/un827-02.jpg" alt="images" /></p>
<p class="indent">In this example, we are creating a connection to a Derby database, on a network, at a localhost address (on the local machine), at port number 1521, to a database called <code>"BookSellerDB"</code>, and we are using the credentials <code>"bookguy"</code> as the user id, and <code>"$3lleR"</code> as the password. Don’t worry too much about the syntax of the URL right now—we’ll cover that soon.</p>
<p class="text-icon"><img src="images/onjob.jpg" alt="Images" /></p>
<p class="noindent"><strong><em>It’s a horrible idea to hard-code a username and password in the <code>getConnection()</code> method. Obviously, anyone reading the code would then know the username and password to the database. A more secure way to handle database credentials would be to separate the code that produces the credentials from the code that makes the connection. In some other class, you would use some type of authentication and authorization code to produce a set of credentials to allow access to the database. For simplicity in the examples in the chapter, we’ll hard-code the username and password, but just keep in mind that on the job, this is not a best practice.</em></strong></p>
<p class="indentt">When you invoke the <code>DriverManager</code>’s <code>getConnection()</code> method, you are asking the <code>DriverManager</code> to try passing the first string in the statement, the driver URL, along with the username and password to each of the driver classes registered with the <code>DriverManager</code> in turn. If one of the driver classes <span id="page_828" epub:type="pagebreak"></span>recognizes the URL string, and the username and password are accepted, the driver returns an instance of a <code>Connection</code> object. If, however, the URL is incorrect, or the username and/or password are incorrect, then the method will throw a <code>SQLException</code>. We’ll spend some time looking at <code>SQLException</code> later in this chapter.</p>
<h5 class="h5">How JDBC Drivers Register with the DriverManager</h5>
<p class="noindent">Because this part of the JDBC process is important to understand, and it involves a little Java magic, let’s spend some time diagramming how driver classes become “registered” with the <code>DriverManager</code>, as shown in <a href="ch12.xhtml#ch12fig2">Figure 12-2</a>.</p>
<p class="figcap" id="ch12fig2"><span class="figure"><strong>FIGURE 12-2</strong></span></p>
<p class="figcap1">How JDBC drivers self-register with <code>DriverManager</code></p>
<p class="imagef"><img src="images/fig12-02.jpg" alt="Images" /></p>
<p class="indent">First, one or more JDBC drivers, in a JAR or ZIP file, are included in the classpath of your application. The <code>DriverManager</code> class uses a service provider mechanism to search the classpath for any JAR or ZIP files that contain a file named <code>java.sql.Driver</code> in the META-INF/services folder of the driver jar or zip. This is simply a text file that contains the full name of the class that the vendor used to implement the <code>jdbc.sql.Driver</code> interface. For example, for a Derby driver, the full name is <code>org.apache.derby.jdbc.ClientDriver</code>.</p>
<p class="indent">The <code>DriverManager</code> will then attempt to load the class it found in the <code>java.sql.</code><code>Driver</code> file using the class loader:</p>
<p class="imageip"><img src="images/un828-01.jpg" alt="images" /></p>
<p class="noindent">When the driver class is loaded, its static initialization block is executed. Per the JDBC specification, one of the first activities of a driver instance is to “self-register” <span id="page_829" epub:type="pagebreak"></span>with the <code>DriverManager</code> class by invoking a static method on <code>DriverManager</code>. The code (minus error handling) looks something like this:</p>
<p class="imageip"><img src="images/un829-01.jpg" alt="images" /></p>
<p class="indent">This registers (stores) an instance of the <code>Driver</code> class into the <code>DriverManager</code>.</p>
<p class="indent">Now, when your application invokes the <code>DriverManager.getConnection()</code> method and passes a JDBC URL, username, and password to the method, the <code>DriverManager</code> simply invokes the <code>connect()</code> method on the registered <code>Driver</code>. If the connection was successful, the method returns a <code>Connection</code> object instance to <code>DriverManager</code>, which, in turn, passes that back to you.</p>
<p class="indent">If there is more than one registered driver, the <code>DriverManager</code> calls each of the drivers in turn and attempts to get a <code>Connection</code> object from them, as shown in <a href="ch12.xhtml#ch12fig3">Figure 12-3</a>.</p>
<p class="figcap" id="ch12fig3"><span class="figure"><strong>FIGURE 12-3</strong></span></p>
<p class="figcap1">How the <code>DriverManager</code> gets a <code>Connection</code></p>
<p class="imagef"><img src="images/fig12-03.jpg" alt="Images" /></p>
<p class="indent"><span id="page_830" epub:type="pagebreak"></span>The first driver that recognizes the JDBC URL and successfully creates a connection using the username and password will return an instance of a <code>Connection</code> object. If no drivers recognize the URL, username, and password combination, or if there are no registered drivers, then a <code>SQLException</code> is thrown instead.</p>
<p class="indent">To summarize:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   The JVM loads the <code>DriverManager</code> class, a concrete class in the JDBC API.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   The <code>DriverManager</code> class loads any instances of classes it finds in the META-INF/services/java.sql.Driver file of JAR/ZIP files on the classpath.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Driver classes call <code>DriverManager.register(this)</code> to self-register with the <code>DriverManager</code>.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   When the <code>DriverManager.getConnection(String url)</code> method is invoked, <code>DriverManager</code> invokes the <code>connect()</code> method of each of these registered <code>Driver</code> instances with the URL string.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   The first <code>Driver</code> that successfully creates a connection with the URL returns an instance of a <code>Connection</code> object to the <code>DriverManager.getConnection</code> method invocation.</p>
<p class="indent">Let’s look at the JDBC URL syntax next.</p>
<h4 class="h4" id="ch12lev2sec4">The JDBC URL</h4>
<p class="noindent">The JDBC URL is what is used to determine which driver implementation to use for a given <code>Connection</code>. Think of the JDBC URL (uniform resource locator) as a way to narrow down the universe of possible drivers to one specific connection. For example, suppose you need to send a package to someone. In order to narrow the universe of possible addresses down to a single unique location, you would have to identify the country, the state, the city, the street, and perhaps a house or address number on your package:</p>
<p class="imageip"><img src="images/un830-01.jpg" alt="images" /></p>
<p class="indent">This string indicates that the address you want is in the United States, California State, San Jose city, First Street, number 15.</p>
<p class="indent">JDBC URLs follow this same idea. To access Bob’s Books, we might write the URL like this:</p>
<p class="imageip"><img src="images/un830-02.jpg" alt="images" /></p>
<p class="indent"><span id="page_831" epub:type="pagebreak"></span>The first part, <code>jdbc</code>, simply identifies that this is a JDBC URL (versus HTTP or something else). The second part indicates that driver vendor is <code>derby</code> driver. The third part indicates that the database is on the <code>localhost</code> of this machine (IP address 127.0.0.1), at port <code>1521</code>, and the final part indicates that we are interested in the <code>BookSellerDB</code> database.</p>
<p class="indent">Just like street addresses, the reason we need this string is because JDBC was designed to work with multiple databases at once. Each of the JDBC database drivers will have a different URL, so we need to be able to pass the JDBC URL string to the <code>DriverManager</code> and ensure that the <code>Connection</code> returned was for the intended database instance.</p>
<p class="indent">Unfortunately, other than a requirement that the JDBC URL begin with “jdbc,” there is very little standard about a JDBC URL. Vendors may modify the URL to define characteristics for a particular driver implementation. The format of the JDBC URL is</p>
<p class="imageip"><img src="images/un831-01.jpg" alt="images" /></p>
<p class="noindent">In general, the subprotocol is the vendor name; for example:</p>
<p class="imageip"><img src="images/un831-02.jpg" alt="images" /></p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>There are two ways to establish a connection in JDBC. The first way is using one of the few concrete classes in the <code>java.sql</code> package, <code>DriverManager</code>. The <code>java.sql.DriverManager</code> class has been a part of the JDBC implementation since the beginning, and is the easiest way to obtain a connection from a Java SE application. The alternative way is with an instance of a class that implements <code>javax.sql.DataSource</code>, introduced in JDBC 2.0.</em></strong></p>
<p class="indent"><strong><em>Since a <code>DataSource</code> instance is typically obtained through a Java Naming and Directory Interface (JNDI) lookup, it is more often used in Java applications where there is a container that supports JNDI—for example, a Java EE application server. For the purposes of this chapter (and because <code>DataSource</code> is not on the exam), we’ll focus on using <code>DriverManager</code> to obtain a connection, but in the end, both ways serve to give you an instance of a <code>Connection</code> object.</em></strong></p>
<p class="indent"><strong><em>To summarize, <code>DriverManager</code> is on the exam and <code>DataSource</code> is not.</em></strong></p>
</div>
<p class="noindent"><span id="page_832" epub:type="pagebreak"></span>The subname field is where things get a bit more vendor specific. Some vendors use the subname to identify the hostname and port, followed by a database name. For example:</p>
<p class="imageip"><img src="images/un832-01.jpg" alt="images" /></p>
<p class="indent">Other vendors may use the subname to identify additional context information about the driver. For example:</p>
<p class="imageip"><img src="images/un832-02.jpg" alt="images" /></p>
<p class="indent">In any case, it is best to consult the documentation for your specific database vendor’s JDBC driver to determine the syntax of the URL.</p>
<h4 class="h4" id="ch12lev2sec5">JDBC Driver Implementation Versions</h4>
<p class="noindent">We talked about how the <code>DriverManager</code> will scan the classpath for JAR files that contain the <code>META-INF/services/java.sql.Driver</code> file and use a classloader to load those drivers. This feature was introduced in the JDBC 4.0 specification. Prior to that, JDBC drivers were loaded manually by the application.</p>
<p class="indent">If you are using a JDBC driver that is an earlier version, say, a JDBC 3.0 driver, then you must explicitly load the class provided by the database vendor that implements the <code>java.sql.Driver</code> interface. Typically, the database vendor’s documentation would tell you what the driver class is. For example, if our Apache Derby JDBC driver were a 3.0 driver, you would manually load the <code>Driver</code> implementation class before calling the <code>getConnection()</code> method:</p>
<p class="imageip"><img src="images/un832-03.jpg" alt="images" /></p>
<p class="noindent">Note that using the <code>Class.forName()</code> method is compatible with both JDBC 3.0 and JDBC 4.0 drivers. It is simply not needed when the driver supports 4.0.</p>
<p class="indent">Here is a quick summary of what we have discussed so far:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   Before you can start working with JDBC, creating queries and getting results, you must first establish a connection.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   In order to establish a connection, you must have a JDBC driver.</p>
<p class="bull"><span id="page_833" epub:type="pagebreak"></span><img class="inline" src="images/box.jpg" alt="Images" />   If your JDBC driver is a JDBC 3.0 driver, then you are required to explicitly load the driver in your code using <code>Class.forName()</code> and the fully qualified path of the <code>Driver</code> implementation class.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   If your JDBC driver is a JDBC 4.0 driver, then simply include the driver (jar or zip) in the classpath.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>Although the certification exam covers up through Java SE 8, the exam developers felt they ought to include some questions about obtaining a connection using both JDBC 3.0 and JDBC 4.0 drivers. So keep in mind that for JDBC 3.0 drivers (and earlier), you are responsible for loading the class using the static <code>forName()</code> method from <code>java.lang.Class</code>.</em></strong></p>
</div>
<p class="title-o"><span class="white"><strong>CERTIFICATION OBJECTIVE</strong></span></p>
<h3 class="h3" id="ch12lev1sec4"><strong>Submit Queries and Read Results from the Database (OCP Objective 11.3)</strong></h3>
<p class="noindent"><em>11.3   Submit queries and read results from the database including creating statements, returning result sets, iterating through the results, and properly closing result sets, statements, and connections.</em></p>
<p class="indentt">In this section, we’ll explore the JDBC API in much greater detail. We will start by looking at a simple example using the <code>Connection</code>, <code>Statement</code>, and <code>ResultSet</code> interfaces to pull together what we’ve learned so far in this chapter. Then we’ll do a deep dive into <code>Statements</code> and <code>ResultSet</code>s.</p>
<h4 class="h4" id="ch12lev2sec6">All of Bob’s Customers</h4>
<p class="noindent">Probably one of the most used SQL queries is SELECT * FROM &lt;Table name&gt;, which is used to print out or see all of the records in a table. Assume that we have a Java DB (Derby) database populated with data from Bob’s Books. To query the <span id="page_834" epub:type="pagebreak"></span>database and return all of the Customers in the database, we would write something like the example shown next.</p>
<p class="indent">Note that to make the code listing a little shorter, going forward, we will use <code>out.println</code> instead of <code>System.out.println</code>. Just assume that means we have included a static import statement, like the one at the top of this example:</p>
<p class="imageip"><img src="images/un834-01.jpg" alt="images" /></p>
<p class="indent">Again, we’ll dive into all of the parts of this example in greater detail, but here is what is happening:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>Get connection</strong>   We are creating a <code>Connection</code> object instance using the information we need to access Bob’s Books Database (stored on a Java DB Relational database, <code>BookSellerDB</code>, and accessed via the credentials <code>"bookguy"</code> with a password of <code>"$3lleR"</code>).</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>Create statement</strong>   We are using the <code>Connection</code> to create a <code>Statement</code> object. The <code>Statement</code> object handles passing <code>Strings</code> to the database as queries for the database to execute.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>Execute query</strong>   We are executing the query string on the database and returning a <code>ResultSet</code> object.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>Process results</strong>   We are iterating through the result set rows—each call to <code>next()</code> moves us to the next row of results.</p>
<p class="bull"><span id="page_835" epub:type="pagebreak"></span><img class="inline" src="images/box.jpg" alt="Images" />   <strong>Print columns</strong>   We are getting the values of the columns in the current result set row and printing them to standard out.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>Catch <code>SQLException</code></strong>   All of the JDBC API method invocations throw <code>SQLException</code>. A <code>SQLException</code> can be thrown when a method is used improperly or if the database is no longer responding. For example, a <code>SQLException</code> is thrown if the JDBC URL, username, or password is invalid. Or we attempted to query a table that does not exist. Or the database is no longer reachable because the network went down or the database went offline. We will look at <code>SQLException</code> in greater detail later in the chapter.</p>
<p class="indent">The output of the previous code will look something like this:</p>
<p class="imageip"><img src="images/un835-01.jpg" alt="images" /></p>
<p class="indent">We’ll take a detailed look at the <code>Statement</code> and <code>ResultSet</code> interfaces and methods in the next two sections.</p>
<h4 class="h4" id="ch12lev2sec7">Statements</h4>
<p class="noindent">Once we have successfully connected to a database, the fun can really start. From a <code>Connection</code> object, we can create an instance of a <code>Statement</code> object (or, to be precise, using the <code>Connection</code> instance we received from the <code>DriverManager</code>, we can get an instance of an object that implements the <code>Statement</code> interface). For example:</p>
<p class="imageip"><img src="images/un835-02.jpg" alt="images" /></p>
<p class="indent"><span id="page_836" epub:type="pagebreak"></span>The primary purpose of a <code>Statement</code> is to execute a SQL statement using a method and return some type of result. There are several forms of <code>Statement</code> methods: those that return a result set, and those that return an integer status. The most commonly used <code>Statement</code> method performs a SQL query that returns some data, like the SELECT call we used earlier to fetch all the <code>Customer</code> table rows.</p>
<h5 class="h5">Constructing and Using Statements</h5>
<p class="noindent">To start, let’s look at the base <code>Statement</code>, which is used to execute a static SQL query and return a result. You’ll recall that we get a <code>Statement</code> from a <code>Connection</code> and then use the <code>Statement</code> object to execute a SQL statement, like a query on the database. For example:</p>
<p class="imageip"><img src="images/un836-01.jpg" alt="images" /></p>
<p class="noindent">Because not all SQL statements return results, the <code>Statement</code> object provides several different methods to execute SQL commands. Some SQL commands do not return a result set, but instead return an integer status. For example, SQL INSERT, UPDATE, and DELETE commands, or any of the SQL Data Definition Language (DDL) statements like CREATE TABLE, return either the number of rows affected by the query or 0.</p>
<p class="indent">Let’s look at each of the execute methods in detail.</p>
<p class="noindentt"><strong>public ResultSet executeQuery(String sql) throws SQLException</strong>   This is the most commonly executed <code>Statement</code> method. This method is used when we know that we want to return results—we are querying the database for one or more rows of data. For example:</p>
<p class="imageip"><img src="images/un836-02.jpg" alt="images" /></p>
<p class="indent">Assuming there is data in the <code>Customer</code> table, this statement should return all of the rows from the <code>Customer</code> table into a <code>ResultSet</code> object—we’ll look at <code>ResultSet</code> in the next section. Notice that the method declaration includes “throws <code>SQLException</code>.” This means that this method must be called in a <code>try-catch</code> block or must be called in a method that also throws <code>SQLException</code>. Again, one reason that these methods all throw <code>SQLException</code> is that a connection to the database is likely <strong>to a database on a network</strong>. As with all things on the network, availability is not guaranteed, so one possible reason for <code>SQLException</code> is the lack of availability of the database itself.</p>
<p class="noindentt"><span id="page_837" epub:type="pagebreak"></span><strong>public int executeUpdate(String sql) throws SQLException</strong>   This method is used for a SQL operation that affects one or more rows and does not return results—for example, SQL INSERT, UPDATE, DELETE, and DDL queries. These statements do not return results, but do return a count of the number of rows affected by the SQL query. For example, here is an example method invocation where we want to update the Book table, increasing the price of every book that is currently priced less than 8.95 and is a hardcover book:</p>
<p class="imageip"><img src="images/un837-01.jpg" alt="images" /></p>
<p class="noindent">When this query executes, we are expecting some number of rows will be affected. The integer that returns is the number of rows that were updated.</p>
<p class="indent">Note that this <code>Statement</code> method can also be used to execute SQL queries that do not return a row count, such as CREATE TABLE or DROP TABLE and other DDL queries. For DDL queries, the return value is 0.</p>
<p class="noindentt"><strong>public boolean execute(String sql) throws SQLException</strong>   This method is used when you are not sure what the result will be—perhaps the query will return a result set and perhaps not. This method can be used to execute a query whose type may not be known until runtime—for example, one constructed in code. The return value is true if the query resulted in a result set and false if the query resulted in an update count or no results.</p>
<p class="indent">However, more often, this method is used when invoking a stored procedure (using the <code>CallableStatement</code>, which we’ll talk about later in the chapter). A stored procedure can return a single result set or row count, or multiple result sets and row counts, so this method was designed to handle what happens when a single database invocation produces more than one result set or row count.</p>
<p class="indent">You might also use this method if you wrote an application to test queries—something that reads a <code>String</code> from the command line and then runs that <code>String</code> against the database as a query. For example:</p>
<p class="imageip"><img src="images/un837-02.jpg" alt="images" /></p>
<p class="imageip"><span id="page_838" epub:type="pagebreak"></span><img src="images/un838-01.jpg" alt="images" /></p>
<p class="indent">Because this statement may return a result set or may simply return an integer row count, there are two additional statement commands you can use to get the results or the count based on whether the <code>execute()</code> method returned true (there is a result set) or false (there is an update count or there was no result). The <code>getResultSet()</code> is used to retrieve results when the <code>execute()</code> method returns true, and the <code>getUpdateCount()</code> is used to retrieve the count when the <code>execute()</code> method returns false. Let’s look at these methods next.</p>
<p class="text-icon"><img src="images/onjob.jpg" alt="Images" /></p>
<p class="noindent"><strong><em>It is generally a very bad idea to allow a user to enter a query string directly in an input field or allow a user to pass a string to construct a query directly. The reason is that if a user can construct a query or even include a freeform string into a query, he or she can use the query to return more data than you intended or alter the database table permissions.</em></strong></p>
<p class="indent"><strong><em>For example, assume that we have a query where the user enters his e-mail address and the string the user enters is inserted directly to the query:</em></strong></p>
<p class="imageip"><img src="images/un838-02.jpg" alt="images" /></p>
<p class="noindent"><strong><em>The user of this code could enter a string like this:</em></strong></p>
<p class="imageip"><img src="images/un838-03.jpg" alt="images" /></p>
<p class="noindent"><strong><em>The resulting query executed by the database becomes:</em></strong></p>
<p class="imageip"><img src="images/un838-04.jpg" alt="images" /></p>
<p class="noindent"><strong><em>Because the OR statement will always return <code>true</code>, the result is that the query will return ALL of the customer rows, effectively the same as the query:</em></strong></p>
<p class="imageip"><img src="images/un838-05.jpg" alt="images" /></p>
<p class="noindent"><strong><em>And now this user of your code has a list of the e-mail addresses of every customer in the database.</em></strong></p>
<p class="indent"><strong><em>This type of attack is called a SQL injection attack. It is easy to prevent by carefully sanitizing any string input used in a query to the database and/or by using one of the other <code>Statement</code> types: <code>PreparedStatement</code> and <code>CallableStatement</code>. Despite how easy it is to prevent, it happens frequently, even to large, experienced companies like Yahoo!</em></strong></p>
<p class="noindentt"><span id="page_839" epub:type="pagebreak"></span><strong>public ResultSet getResultSet() throws SQLException</strong>   If the boolean value from the <code>execute()</code> method returns true, then there is a result set. To get the result set, as shown earlier, call the <code>getResultSet()</code> method on the <code>Statement</code> object. Then you can process the <code>ResultSet</code> object (which we will cover in the next section). This method is basically foolproof—if, in fact, there are no results, the method will return a null.</p>
<p class="imageip"><img src="images/un839-01.jpg" alt="images" /></p>
<p class="noindentt"><strong>public int getUpdateCount() throws SQLException</strong>   If the boolean value from the <code>execute()</code> method returns false, then there is a row count, and this method will return the number of rows affected. A return value of –1 indicates that there are no results.</p>
<p class="imageip"><img src="images/un839-02.jpg" alt="images" /></p>
<p class="indent"><a href="ch12.xhtml#ch12tab7">Table 12-7</a> summarizes the <code>Statement</code> methods we just covered.</p>
<p class="tabcap" id="ch12tab7"><span class="table"><strong>TABLE 12-7</strong></span> Important <code>Statement</code> Methods</p>
<p class="imaget"><img src="images/tab12-07.jpg" alt="Images" /></p>
<h4 class="h4" id="ch12lev2sec8"><span id="page_840" epub:type="pagebreak"></span>ResultSets</h4>
<p class="noindent">When a query returns a result set, an instance of a class that implements the ResultSet interface is returned. The <code>ResultSet</code> object represents the results of the query—all of the data in each row on a per-column basis. Again, as a reminder, <em>how</em> data in a <code>ResultSet</code> are stored is entirely up to the JDBC driver vendor. It is possible that the JDBC driver caches the entire set of results in memory all at once, or that it uses internal buffers and gets only a few rows at a time. From your point of view as the user of the data, it really doesn’t matter much. Using the methods defined in the <code>ResultSet</code> interface, you can read and manipulate the data and that’s all that matters.</p>
<p class="indent">One important thing to keep in mind is that a <code>ResultSet</code> is a <em>copy</em> of the data from the database from the instance in time when the query was executed. Unless you are the only person using the database, you need to always assume that the underlying database table or tables that the <code>ResultSet</code> came from could be changed by some other user or application.</p>
<p class="indent">Because <code>ResultSet</code> is such a comprehensive part of the JDBC API, we are going to tackle it in sections. <a href="ch12.xhtml#ch12tab8">Table 12-8</a> summarizes each section so you can reference these later.</p>
<p class="tabcap" id="ch12tab8"><span class="table"><strong>TABLE 12-8</strong></span> <code>ResultSet</code> Sections</p>
<p class="imaget"><img src="images/tab12-08.jpg" alt="Images" /></p>
<h5 class="h5"><span id="page_841" epub:type="pagebreak"></span>Moving Forward in a ResultSet</h5>
<p class="noindent">The best way to think of a <code>ResultSet</code> object is visually. Assume that in our BookSellerDB database we have several customers whose last name begins with the letter “C.” We could create a query to return those rows “like” this:</p>
<p class="imageip"><img src="images/un841-01.jpg" alt="images" /></p>
<p class="indent">The SQL operator LIKE treats the string that follows as a pattern to match, where the <code>%</code> indicates a wildcard. So, <code>LastName LIKE 'C%'</code> means “any <code>LastName</code> with a <code>C</code>, followed by any other character(s).”</p>
<p class="indent">When we execute this query using the <code>executeQuery()</code> method, the <code>ResultSet</code> returned will contain the <code>FirstName</code>, <code>LastName</code>, and <code>EMail</code> columns where the customer’s <code>LastName</code> starts with the capital letter “C”:</p>
<p class="imageip"><img src="images/un841-02.jpg" alt="images" /></p>
<p class="noindent">The <code>ResultSet</code> object returned contains the data from the query as shown in <a href="ch12.xhtml#ch12fig4">Figure 12-4</a>.</p>
<p class="figcap" id="ch12fig4"><span class="figure"><strong>FIGURE 12-4</strong></span> A <code>ResultSet</code> after the <code>executeQuery</code></p>
<p class="imagef"><img src="images/fig12-04.jpg" alt="Images" /></p>
<p class="indent">Note in <a href="ch12.xhtml#ch12fig4">Figure 12-4</a> that the <code>ResultSet</code> object maintains a cursor, or a pointer, to the current row of the results. When the <code>ResultSet</code> object is first returned from the query, the cursor is not yet pointing to a row of results—the cursor is pointing above the first row. In order to get the results of the table, you must always <span id="page_842" epub:type="pagebreak"></span>call the <code>next()</code> method on the <code>ResultSet</code> object to move the cursor forward to the first row of data. By default, a <code>ResultSet</code> object is read-only (the data in the rows cannot be updated), and you can only move the cursor forward. We’ll look at how to change this behavior a little later on.</p>
<p class="indent">So the first method you will need to know for <code>ResultSet</code> is the <code>next()</code> method.</p>
<p class="noindentt"><strong>public boolean next()</strong>   The <code>next()</code> method moves the cursor forward one row and returns true if the cursor now points to a row of data in the <code>ResultSet</code>. If the cursor points beyond the last row of data as a result of the <code>next()</code> method (or if the <code>ResultSet</code> contains no rows), the return value is false.</p>
<p class="indent">So in order to read the three rows of data in the table shown in <a href="ch12.xhtml#ch12fig4">Figure 12-4</a>, we need to call the <code>next()</code> method, read the row of data, and then call <code>next()</code>again twice more. When the <code>next()</code>method is invoked the fourth time, the method will return false. The easiest way to read all of the rows from first to last is in a <code>while</code> loop:</p>
<p class="imageip"><img src="images/un842-01.jpg" alt="images" /></p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>Because the cursor is such a fundamental concept in JDBC, the exam will test you on the status of the cursor in a <code>ResultSet</code>. As long as you keep in mind that you must call the <code>next()</code> method before processing even one row of data in a <code>ResultSet</code>, then you’ll be fine. Maybe you could use a memory device like this one: “When getting results, don’t vex, always call next!” Okay, maybe not.</em></strong></p>
</div>
<h5 class="h5">Reading Data from a ResultSet</h5>
<p class="noindent">Moving the cursor forward through the <code>ResultSet</code> is just the start of reading data from the results of the query. Let’s look at the two ways to get the data from each row in a result set.</p>
<p class="indent"><span id="page_843" epub:type="pagebreak"></span>When a <code>ResultSet</code> is returned and you have dutifully called <code>next()</code> to move the cursor to the first actual row of data, you can now read the data in each column of the current row. As illustrated in <a href="ch12.xhtml#ch12fig4">Figure 12-4</a>, a result set from a database query is like a table or a spreadsheet. Each row contains (typically) one or more columns, and the data in each column is one of the SQL data types. In order to bring the data from each column into your Java application, you must use a <code>ResultSet</code> method to retrieve each of the SQL column values into an appropriate Java type. So SQL INTEGER, for example, can be read as a Java int primitive, SQL VARCHAR can be read as a Java String, SQL DATE can be read as a <code>java.sql.Date</code> object, and so on. <code>ResultSet</code> defines several other types as well, but whether or not the database or the driver supports all of the types defined by the specification depends on the database vendor. For the exam, we recommend you focus on the most common SQL data types and the <code>ResultSet</code> methods shown in <a href="ch12.xhtml#ch12tab9">Table 12-9</a>.</p>
<p class="tabcap" id="ch12tab9"><span class="table"><strong>TABLE 12-9</strong></span> SQL Types and JDBC Types</p>
<p class="imaget"><img src="images/tab12-09.jpg" alt="Images" /></p>
<p class="text-icon"><img src="images/onjob.jpg" alt="Images" /></p>
<p class="noindent"><strong><em>SQL has been around for a long time. The first formalized American National Standards Institute (ANSI)–approved version was adopted in 1986 (SQL-86). The next major revision was in 1992, SQL-92, which is widely considered the “base” release for every database. SQL-92 defined a number of new data types, including DATE, TIME, TIMESTAMP, BIT, and VARCHAR strings. SQL-92 has multiple levels; each level adds a bit more functionality to the previous level. JDBC drivers recognize three ANSI SQL-92 levels: Entry, Intermediate, and Full.</em></strong></p>
<p class="indent"><strong><em>SQL-1999, also known as SQL-3, added LARGE OBJECT types, including BINARY LARGE OBJECT (BLOB) and CHARACTER LARGE OBJECT (CLOB). SQL-1999 also introduced the BOOLEAN type and a composite type, ARRAY and ROW, to store collections directly into the database. In addition, SQL-1999 added a number of features to SQL, including triggers, regular expressions, and procedural and flow control.</em></strong></p>
<p class="indent"><strong><em>SQL-2003 introduced XML to the database, and importantly, added columns with auto-generated values, including columns that support identity, like the primary key and foreign key columns. Believe it or not, other standards have been proposed, including SQL-2006, SQL-2008, and SQL-2011.</em></strong></p>
<p class="indent"><strong><em>The reason this matters is because the JDBC specification has attempted to be consistent with features from the most widely adopted specification at the time. Thus, JDBC 3.0 supports SQL-92 and a part of the SQL-1999 specification, and JDBC 4.0 supports parts of the SQL-2003 specification. In this chapter, we’ll try to stick to the most widely used SQL-92 features and the most commonly supported SQL-1999 features that JDBC also supports.</em></strong></p>
<p class="indentt">One way to read the column data is by using the names of the columns themselves as string values. For example, using the column names from Bob’s <span id="page_844" epub:type="pagebreak"></span>Book table (<a href="ch12.xhtml#ch12tab4">Table 12-4</a>), in these <code>ResultSet</code> methods, the <code>String</code> name of the column from the Book table is passed to the method to read the column data type:</p>
<p class="imageip"><img src="images/un844-01.jpg" alt="images" /></p>
<p class="indent">Note that although here the column names were retrieved from the <code>ResultSet</code> row in the order they were requested in the SQL query, they could have been processed in any order.</p>
<p class="indent"><code>ResultSet</code> also provides an overloaded method that takes an integer index value for each of the SQL types. This value is the integer position of the column in the result set, numbered from 1 to the number of columns returned. So we could write the same statements earlier like this:</p>
<p class="imageip"><img src="images/un844-02.jpg" alt="images" /></p>
<p class="noindent">Using the positional methods shown earlier, the order of the column in the <code>ResultSet</code> does matter. In our query, Title is in position 1, PubDate is in position 2, and Price is in position 3.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>Remember: Column indexes start with 1.</em></strong></p>
<p class="indent"><strong><em>It is important to keep in mind that when you are accessing columns using integer index values, the column indexes always start with 1, not 0 as in traditional arrays. If you attempt to access a column with an index of less than 1 or greater than the number of columns returned, a <code>SQLException</code> will be thrown. You can get the number of columns returned in a <code>ResultSet</code> through the result set’s metadata object. See the section on <code>ResultSetMetaData</code> to learn more.</em></strong></p>
</div>
<p class="text-icon"><span id="page_845" epub:type="pagebreak"></span><img src="images/onjob.jpg" alt="Images" /></p>
<p class="noindent"><strong><em>What the database stores as a type, the SQL type, and what JDBC returns as a type are often two different things. It is important to understand that the JDBC specification provides a set of standard mappings—the best match between what the database provides as a type and the Java type a programmer should use with that type. Rather than repeating what is in the specification, we encourage you to look at Appendix B of the JDBC (JSR-221) specification.</em></strong></p>
<p class="indentt">The most commonly used <code>ResultSet</code> <code>get</code> methods are listed next. Let’s look at these methods in detail.</p>
<p class="noindentt"><strong>public boolean getBoolean(String columnLabel)</strong>   This method retrieves the value of the named column in the <code>ResultSet</code> as a Java boolean. Boolean values are rarely returned in SQL queries, and some databases may not support a SQL BOOLEAN type, so check with your database vendor. In this contrived example here, we are returning employment status:</p>
<p class="imageip"><img src="images/un845-01.jpg" alt="images" /></p>
<p class="noindentt"><strong>public double getDouble(String columnLabel)</strong>   This method retrieves the value of the column as a Java double. This method is recommended for returning the value stored in the database as SQL DOUBLE and SQL FLOAT types.</p>
<p class="imageip"><img src="images/un845-02.jpg" alt="images" /></p>
<p class="noindentt"><strong>public int getInt(String columnLabel)</strong>   This method retrieves the value of the column as a Java int. Integers are often a good choice for primary keys. This method is recommended for returning values stored in the database as SQL INTEGER types.</p>
<p class="imageip"><img src="images/un845-03.jpg" alt="images" /></p>
<p class="noindentt"><strong>public float getFloat(String columnLabel)</strong>   This method retrieves the value of the column as a Java float. It is recommended for SQL REAL types.</p>
<p class="imageip"><img src="images/un845-04.jpg" alt="images" /></p>
<p class="noindentt"><strong>public long getLong(String columnLabel)</strong>   This method retrieves the value of the column as a Java long. It is recommended for SQL BIGINT types.</p>
<p class="imageip"><img src="images/un845-05.jpg" alt="images" /></p>
<p class="noindentt"><span id="page_846" epub:type="pagebreak"></span><strong>public java.sql.Date getDate(String columnLabel)</strong>   This method retrieves the value of the column as a Java <code>Date</code> object. Note that <code>java.sql.Date</code> extends <code>java.util.Date</code>. One difference between the two is that the <code>toString()</code> method of <code>java.sql.Date</code> returns a date string in the form: “yyyy mm dd.” This method is recommended for SQL DATE types.</p>
<p class="imageip"><img src="images/un846-01.jpg" alt="images" /></p>
<p class="noindentt"><strong>public java.lang.String getString(String columnLabel)</strong>   This method retrieves the value of the column as a Java <code>String</code> object. It is good for reading SQL columns with CHAR, VARCHAR, and LONGVARCHAR types.</p>
<p class="imageip"><img src="images/un846-02.jpg" alt="images" /></p>
<p class="noindentt"><strong>public java.sql.Time getTime(String columnLabel)</strong>   This method retrieves the value of the column as a Java <code>Time</code> object. Like <code>java.sql.Date</code>, this class extends <code>java.util.Date</code>, and its <code>toString()</code> method returns a time string in the form: “hh:mm:ss.” TIME is the SQL type that this method is designed to read.</p>
<p class="imageip"><img src="images/un846-03.jpg" alt="images" /></p>
<p class="noindentt"><strong>public java.sql.Timestamp getTimestamp(String columnLabel)</strong>   This method retrieves the value of the column as a <code>Timestamp</code> object. Its <code>toString()</code> method formats the result in the form: yyyy-mm-dd hh:mm:ss.fffffffff, where ffffffffff is nanoseconds. This method is recommended for reading SQL TIMESTAMP types.</p>
<p class="imageip"><img src="images/un846-04.jpg" alt="images" /></p>
<p class="noindentt"><strong>public java.lang.Object getObject(String columnLabel)</strong>   This method retrieves the value of the column as a Java <code>Object</code><code>. It can be used as a general-purpose method for reading data in a column. This method works by reading the value returned as the appropriate Java wrapper class for the type and returning that as a Java <code>Object</code> object. So, for example, reading an integer (SQL INTEGER type) using this method returns an object that is a <code>java.lang.Integer</code> type. We can use <code>instanceof</code> to check for an </code><code>Integer</code> and get the <code>int</code> value:</p>
<p class="imageip"><img src="images/un846-05.jpg" alt="images" /><span id="page_847" epub:type="pagebreak"></span></p>
<p class="noindent"><a href="ch12.xhtml#ch12tab9">Table 12-9</a> lists the most commonly used methods to retrieve specific data from a <code>ResultSet</code>. For the complete and exhaustive set of <code>ResultSet</code> get methods, see the Java documentation for <code>java.sql.ResultSet</code>.</p>
<div class="side">
<p class="exam"><img src="images/exam.jpg" alt="Images" /></p>
</div>
<div class="side1">
<p class="indent"><strong><em>The exam is not going to test your knowledge of all of the <code>ResultSet get</code> and <code>set</code> methods for SQL types. For the exam, just remember the basic Java types: <code>String</code> and <code>int</code>. Each <code>ResultSet</code> getter method is named by its closest Java type, so, for example, to read a database column that holds an integer into a Java <code>int</code> type, you invoke the <code>getInt()</code> method with either the <code>String</code> column or the column index of the column you wish to read.</em></strong></p>
</div>
<h5 class="h5"><span id="page_848" epub:type="pagebreak"></span>Getting Information about a ResultSet</h5>
<p class="noindent">When you write a query using a string, as we have in the examples so far, you know the name and type of the columns returned. However, what happens when you want to allow your users to dynamically construct the query? You may not always know in advance how many columns are returned and the type and name of the columns returned.</p>
<p class="indent">Fortunately, the <code>ResultSetMetaData</code> class was designed to provide just that information. Using <code>ResultSetMetaData</code>, you can get important information about the results returned from the query, including the number of columns, the table name, the column name, and the column class name—the Java class that is used to represent this column when the column is returned as an <code>Object</code>. Here is a simple example, and then we’ll look at these methods in more detail:</p>
<p class="imageip"><img src="images/un848-01.jpg" alt="images" /></p>
<p class="indent">Running this code using the BookSeller database (Bob’s Books) produces the following output:</p>
<p class="imageip"><img src="images/un848-02.jpg" alt="images" /></p>
<p class="indent"><code>ResultSetMetaData</code> is often used to generate reports, so here are the most commonly used methods. For more information and more methods, check out the JavaDocs.</p>
<p class="noindentt"><strong>public int getColumnCount() throws SQLException</strong>   This method is probably the most used <code>ResultSetMetaData</code> method. It returns the integer count of the number of columns returned by the query. With this method, you can iterate through the columns to get information about each column.</p>
<p class="imageip"><img src="images/un848-03.jpg" alt="images" /></p>
<p class="imageip"><span id="page_849" epub:type="pagebreak"></span><img src="images/un849-01.jpg" alt="images" /></p>
<p class="noindent">The value of <code>columnCount</code> for the <code>Author</code> table is 3. We can use this value to iterate through the columns using the methods illustrated next.</p>
<p class="noindentt"><strong>public String getColumnName(int column) throws SQLException</strong>   This method returns the <code>String</code> name of this column. Using the <code>columnCount</code>, we can create an output of the data from the database in a report-like format. For example:</p>
<p class="imageip"><img src="images/un849-02.jpg" alt="images" /></p>
<p class="noindent">This example is somewhat rudimentary, as we probably need to do some better formatting on the data, but it will produce a table of output:</p>
<p class="imageip"><img src="images/un849-03.jpg" alt="images" /></p>
<p class="noindentt"><span id="page_850" epub:type="pagebreak"></span><strong>public String getTableName(int column) throws SQLException</strong>   The method returns the <code>String</code> name of the table that this column belongs to. This method is useful when the query is a join of two or more tables and we need to know which table a column came from. For example, suppose that we want to get a list of books by author’s last name:</p>
<p class="imageip"><img src="images/un850-01.jpg" alt="images" /></p>
<p class="noindent">With a query like this, we might want to know which table the column data came from:</p>
<p class="imageip"><img src="images/un850-02.jpg" alt="images" /></p>
<p class="noindent">This code will print the name of the table, a colon, and the column name. The output might look something like this:</p>
<p class="imageip"><img src="images/un850-03.jpg" alt="images" /></p>
<p class="noindentt"><strong>public int getColumnDisplaySize(int column) throws SQLException</strong>   This method returns an integer of the size of the column. This information is useful for determining the maximum number of characters a column can hold (if it is a VARCHAR type) and the spacing that is required between columns for a report.</p>
<h5 class="h5">Printing a Report</h5>
<p class="noindent">To make a prettier report than the one in the <code>getColumnName</code> method earlier, for example, we could use the display size to pad the column name and data with spaces. What we want is a table with spaces between the columns and headings that looks something like this when we query the Author table:</p>
<p class="imageip"><img src="images/un850-04.jpg" alt="images" /></p>
<p class="indent"><span id="page_851" epub:type="pagebreak"></span>Using the methods we have discussed so far, here is code that produces a pretty report from a query:</p>
<p class="imageip"><img src="images/un851-01.jpg" alt="images" /></p>
<p class="indent">A couple of things to note about the example code: first, the <code>leftJustify</code> method, which takes a string to print left-justified and an integer for the total number of characters in the string. The difference between the actual string length and the integer value will be filled with spaces. This method uses the <code>String format()</code> method and the <code>"-"</code> (dash) flag to return a <code>String</code> that is left-justified with spaces. The <code>%1$</code> part indicates the flag should be applied to the first argument. What we are building is a format string dynamically. If the column display size is 20, the format string will be <code>%1$-20s</code>, which says “print the argument passed (the first argument) on the left with a width of 20 and use a string conversion.”</p>
<p class="indent">Note that if the length of the string passed in and the integer field length (<code>n</code>) are the same, we add one space to the length to make it look pretty:</p>
<p class="imageip"><img src="images/un851-02.jpg" alt="images" /></p>
<p class="indent"><span id="page_852" epub:type="pagebreak"></span>Second, databases can store NULL values. If the value of a column is NULL, the object returned in the <code>rs.getObject()</code> method is a Java null. So we have to test for null to avoid getting a null pointer exception when we execute the <code>toString()</code> method.</p>
<p class="indent">Notice that we don’t have to use the <code>next()</code> method before reading the <code>ResultSetMetaData</code>—we can do that at any time after obtaining a valid result set. Running this code and passing it a query like “SELECT * FROM Author” returns a neatly printed set of authors:</p>
<p class="imageip"><img src="images/un852-01.jpg" alt="images" /></p>
<h5 class="h5">Moving Around in ResultSets</h5>
<p class="noindent">So far, for all the result sets we looked at, we simply moved the cursor forward by calling <code>next()</code>. The default characteristics of a <code>Statement</code> are cursors that only move forward and result sets that do not support changes. The <code>ResultSet</code> interface actually defines these characteristics as static int variables: TYPE_FORWARD_ONLY and CONCUR_READ_ONLY. However, the JDBC specification defines additional static <code>int</code> types (shown next) that allow a developer to move the cursor forward, backward, and to a specific position in the result set. In addition, the result set can be modified while open and the changes written to the database. Note that support for cursor movement and updatable result sets is not a requirement on a driver, but most drivers provide this capability. In order to create a result set that uses positionable cursors and/or supports updates, you must create a <code>Statement</code> with the appropriate scroll type and concurrency setting, and then use that <code>Statement</code> to create the <code>ResultSet</code> object.</p>
<p class="indent">The ability to move the cursor to a particular position is the key to being able to determine how many rows are returned from a result set—something we will look at shortly. The ability to modify an open result set may seem odd, particularly if you are a seasoned database developer. After all, isn’t that what a SQL UPDATE command is for?</p>
<p class="indent">Consider a situation in which you want to perform a series of calculations using the data from the result set rows, then write a change to each row based on some <span id="page_853" epub:type="pagebreak"></span>criteria, and finally write the data back to the database. For example, imagine a database table that contains customer data, including the date they joined as a customer, their purchase history, and the total number of orders in the last two months. After reading this data into a result set, you could iterate over each customer record and modify it based on business rules: set their minimum discount higher if they have been a customer for more than a year with at least one purchase per year or set their preferred credit status if they have been purchasing more than $100 per month. With an updatable result set, you can modify several customer rows, each in a different way, and commit the rows to the database without having to write a complex SQL query or a set of SQL queries—you simply commit the updates on the open result set.</p>
<p class="indent">Let’s look at how to modify a result set in more detail. There are three <code>ResultSet</code> cursor types:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>TYPE_FORWARD_ONLY</strong> The default value for a <code>ResultSet</code>—the cursor moves forward only through a set of results.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>TYPE_SCROLL_INSENSITIVE</strong> A cursor position can be moved in the result forward or backward, or positioned to a particular cursor location. Any changes made to the underlying data—the database itself—are not reflected in the result set. In other words, the result set does not have to “keep state” with the database. This type is generally supported by databases.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>TYPE_SCROLL_SENSITIVE</strong> A cursor can be moved in the results forward or backward, or positioned to a particular cursor location. Any changes made to the underlying data are reflected in the open result set. As you can imagine, this is difficult to implement and is, therefore, not implemented in a database or JDBC driver very often.</p>
<p class="indent">JDBC provides two options for data concurrency with a result set:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>CONCUR_READ_ONLY</strong> This is the default value for result set concurrency. Any open result set is read-only and cannot be modified or changed.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   <strong>CONCUR_UPDATABLE</strong> A result set can be modified through the <code>ResultSet</code> methods while the result set is open.</p>
<p class="indent">Because a database and JDBC driver are not required to support cursor movement and concurrent updates, the JDBC provides methods to query the database and <span id="page_854" epub:type="pagebreak"></span>driver using the <code>DatabaseMetaData</code> object to determine if your driver supports these capabilities. For example:</p>
<p class="imageip"><img src="images/un854-01.jpg" alt="images" /></p>
<p class="indent">Running this code on the Java DB (Derby) database, these are the results:</p>
<p class="imageip"><img src="images/un854-02.jpg" alt="images" /></p>
<p class="indent">In order to create a <code>ResultSet</code> with TYPE_SCROLL_INSENSITIVE and CONCUR_UPDATABLE, the <code>Statement</code> used to create the <code>ResultSet</code> must be created (from the <code>Connection</code>) with the cursor type and concurrency you want. You can determine what cursor type and concurrency the <code>Statement</code> was created with, but once created, you can’t change the cursor type or concurrency of an existing <code>Statement</code> object. Also, note that just because you set a cursor type or concurrency setting, that doesn’t mean you will get those settings. As you will see in the section on exceptions, the driver can determine that the database doesn’t support one or both of the settings you chose and it will throw a warning and <span id="page_855" epub:type="pagebreak"></span>(silently) revert to its default settings, if they are not supported. You will see how to detect these JDBC warnings in the section on exceptions and warnings.</p>
<p class="imageip"><img src="images/un855-01.jpg" alt="images" /></p>
<p class="indent">Besides being able to use a <code>ResultSet</code> object to update results, which we’ll look at next, being able to manipulate the cursor provides a side benefit—we can use the cursor to determine the number of rows returned in a query. Although it would seem like there ought to be a method in <code>ResultSet</code> or <code>ResultSetMetaData</code> to do this, this method does not exist.</p>
<p class="indent">In general, you should not need to know how many rows are returned, but during debugging, you may want to diagnose your queries with a stand-alone database and use cursor movement to read the number of rows returned.</p>
<p class="indent">Something like this would work:</p>
<p class="imageip"><img src="images/un855-02.jpg" alt="images" /></p>
<p class="indent">Of course, you may also want to have a more sophisticated method that preserves the current cursor position and returns the cursor to that position, regardless of when the method was called. Before we look at that code, let’s look at the other cursor movement methods and test methods (besides <code>next</code>) in <code>ResultSet</code>. As a quick summary, <a href="ch12.xhtml#ch12tab10">Table 12-10</a> lists the methods you use to change the cursor position in a <code>ResultSet</code>.</p>
<p class="tabcap" id="ch12tab10"><span class="table"><strong>TABLE 12-10</strong></span> <code>ResultSet</code> Cursor Positioning Methods</p>
<p class="imaget"><img src="images/tab12-10.jpg" alt="Images" /></p>
<p class="indent">Let’s look at each of these methods in more detail.</p>
<p class="noindentt"><strong>public boolean absolute(int row) throws SQLException</strong>   This method positions the cursor to an absolute row number. The contrasting method is relative. Passing <code>0</code> as the row argument positions the cursor to before the first row. Passing a negative value, like <code>-1</code>, positions the cursor to the position after the last row minus one—in other words, the last row. If you attempt to position the cursor beyond the last row, say at position 22 in a 19-row result set, the cursor will be positioned beyond the last row, the implications of which we’ll discuss next. <a href="ch12.xhtml#ch12fig5">Figure 12-5</a> illustrates how invocations of <code>absolute()</code> position the cursor.<span id="page_856" epub:type="pagebreak"></span></p>
<p class="figcap" id="ch12fig5"><span class="figure"><strong>FIGURE 12-5</strong></span></p>
<p class="figcap1">Absolute cursor positioning</p>
<p class="imagef"><img src="images/fig12-05.jpg" alt="Images" /></p>
<p class="indent"><span id="page_857" epub:type="pagebreak"></span>The <code>absolute()</code> method returns <code>true</code> if the cursor was successfully positioned within the <code>ResultSet</code> and <code>false</code> if the cursor ended up before the first or after the last row. For example, suppose you wanted to process only every other row:</p>
<p class="imageip"><img src="images/un857-01.jpg" alt="images" /></p>
<p class="noindentt"><strong>public int getRow() throws SQLException</strong>   This method returns the current row position as a positive integer (1 for the first row, 2 for the second, and so on) or 0 if there is no current row—the cursor is either before the first row or after the last row. This is the only method of this set of cursor methods that is optionally supported for TYPE_FORWARD_ONLY <code>ResultSets.</code></p>
<p class="noindentt"><strong>public boolean relative(int rows) throws SQLException</strong>   The <code>relative()</code> method is the cousin to <code>absolute</code>. Get it, cousin? Okay, anyway, <code>relative()</code> will position the cursor either before or after the current position of the number of rows passed in to the method. So if the cursor is on row 15 of a 30-row <code>ResultSet</code>, calling <code>relative(2)</code> will position the cursor to row 17, and then calling <code>relative(-5)</code> positions the cursor to row 12. <a href="ch12.xhtml#ch12fig6">Figure 12-6</a> shows how the cursor is moved based on calls to <code>absolute()</code> and <code>relative()</code>.</p>
<p class="figcap" id="ch12fig6"><span class="figure"><strong>FIGURE 12-6</strong></span></p>
<p class="figcap1">Relative cursor positioning (Circled numbers indicate order of invocation.)</p>
<p class="imagef"><img src="images/fig12-06.jpg" alt="Images" /></p>
<p class="indent">Like absolute positioning, attempting to position the cursor beyond the last row or before the first row simply results in the cursor being after the last row or before the first row, respectively, and the method returns false. Also, calling relative with an argument of 0 does exactly what you might expect—the cursor remains where it is. Why would you use relative? Let’s assume you are displaying a fairly long database table on a web page using an HTML table. You might want to allow your user to be able to page forward or backward relative to the currently selected row—maybe something like this:</p>
<p class="imageip"><img src="images/un857-02.jpg" alt="images" /><span id="page_858" epub:type="pagebreak"></span></p>
<p class="noindentt"><strong>public boolean previous() throws SQLException</strong>   The <code>previous()</code> method works exactly the same as the <code>next()</code> method, only it backs up through the <code>ResultSet</code>. Using this method with the <code>afterLast()</code> method described next, you can move through a <code>ResultSet</code> in reverse order (from last row to first).</p>
<p class="noindentt"><strong>public void afterLast() throws SQLException</strong>   This method positions the cursor after the last row. Using this method and then the <code>previous()</code> method, you can iterate through a <code>ResultSet</code> in reverse. For example:</p>
<p class="imageip"><img src="images/un858-01.jpg" alt="images" /></p>
<p class="indent">Just like <code>next()</code>, when <code>previous()</code> backs up all the way to before the first row, the method returns <code>false</code>.</p>
<p class="noindentt"><span id="page_859" epub:type="pagebreak"></span><strong>public void beforeFirst() throws SQLException</strong>   This method will return the cursor to the position it held when the <code>ResultSet</code> was first created and returned by a <code>Statement</code> object.</p>
<p class="imageip"><img src="images/un859-01.jpg" alt="images" /></p>
<p class="noindentt"><strong>public boolean first() throws SQLException</strong>   The <code>first()</code> method positions the cursor on the first row. It is the equivalent of calling <code>absolute(1)</code>. This method returns <code>true</code> if the cursor was moved to a valid row and <code>false</code> if the <code>ResultSet</code> has no rows.</p>
<p class="imageip"><img src="images/un859-02.jpg" alt="images" /></p>
<p class="noindentt"><strong>public boolean last() throws SQLException</strong>   The <code>last()</code> method positions the cursor on the last row. This method is the equivalent of calling <code>absolute(-1)</code>. This method returns <code>true</code> if the cursor was moved to a valid row and <code>false</code> if the <code>ResultSet</code> has no rows.</p>
<p class="imageip"><img src="images/un859-03.jpg" alt="images" /></p>
<p class="indent">A couple of notes on the exceptions thrown by all of these methods:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   A <code>SQLException</code> will be thrown by these methods if the type of the <code>ResultSet</code> is TYPE_FORWARD_ONLY, if the <code>ResultSet</code> is closed (we will look at how a result set is closed in an upcoming section), or if a database error occurs.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   A <code>SQLFeatureNotSupportedException</code> will be thrown by these methods if the JDBC driver does not support the method. This exception is a subclass of <code>SQLException</code>.</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   Most of these methods have no effect if the <code>ResultSet</code> has no rows—for example, a <code>ResultSet</code> returned by a query that returned no rows.</p>
<p class="indent">The following methods return a boolean to allow you to “test” the current cursor position without moving the cursor. Note that these are not on the exam but are provided to you for completeness:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><code>isBeforeFirst()</code></strong> True if the cursor is positioned before the first row</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><code>isAfterLast()</code></strong> True if the cursor is positioned after the last row</p>
<p class="bull"><span id="page_860" epub:type="pagebreak"></span><img class="inline" src="images/box.jpg" alt="Images" />   <strong><code>isFirst()</code></strong> True if the cursor is on the first row</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><code>isLast()</code></strong> True if the cursor is on the last row</p>
<p class="indent">So now that we have looked at the cursor positioning methods, let’s revisit the code to calculate the row count. We will create a general-purpose method to allow the row count to be calculated at any time and at any current cursor position. Here is the code:</p>
<p class="imageip"><img src="images/un860-01.jpg" alt="images" /></p>
<p class="indent">Looking through the code, you notice that we took special care to preserve the current position of the cursor in the <code>ResultSet</code>. We called <code>getRow()</code> to get the current position, and if the value returned was 0, the current position of the <code>ResultSet</code> could be either before the first row or after the last row, so we used the <code>isAfterLast()</code> method to determine where the cursor was. If the cursor was after the last row, then we stored a <code>-1</code> in the <code>currRow</code> integer.</p>
<p class="indent"><span id="page_861" epub:type="pagebreak"></span>We then moved the cursor to the last position in the <code>ResultSet</code>, and if that move was successful, we get the current position and save it as the <code>rowCount</code> (the last row and, therefore, the count of rows in the <code>ResultSet</code>). Finally, we use the value of <code>currRow</code> to determine where to return the cursor. If the value of the cursor is <code>-1</code>, we need to position the cursor after the last row. Otherwise, we simply use <code>absolute()</code> to return the cursor to the appropriate position in the <code>ResultSet</code>.</p>
<p class="indent">While this may seem like several extra steps, we will look at why preserving the cursor can be important when we look at updating <code>ResultSet</code>s next.</p>
<h5 class="h5">Updating ResultSets</h5>
<p class="noindent"><strong>Please note that you might not get any questions on the real exam for this section and the subsections that follow.</strong></p>
<p class="indent">If you have casually used JDBC, or are new to JDBC, you may be surprised to know that a <code>ResultSet</code> object can do more than just provide the results of a query to your application. Besides just returning the results of a query, a <code>ResultSet</code> object may be used to modify the contents of a database table, including update existing rows, delete existing rows, and add new rows.</p>
<p class="indent">In a traditional SQL application, you might perform the following SQL queries to raise the price of all of the hardcover books in inventory that are currently 10.95 to 11.95 in price:</p>
<p class="imageip"><img src="images/un861-01.jpg" alt="images" /></p>
<p class="indent">Hopefully, by now you feel comfortable creating a <code>Statement</code> to perform this query using a SQL UPDATE:</p>
<p class="imageip"><img src="images/un861-02.jpg" alt="images" /></p>
<p class="indent">But what if you wanted to do the updates on a book-by-book basis? What if you only want to increase the price of your bestsellers, rather than every single book?</p>
<p class="indent">You would have to get the values from the database using a SELECT, then store the values in an array indexed somehow (perhaps with the primary key), then construct the appropriate UPDATE command strings, and call <code>executeUpdate()</code> one row at a time. Another option is to update the <code>ResultSet</code> directly.</p>
<p class="indent"><span id="page_862" epub:type="pagebreak"></span>When you create a <code>Statement</code> with concurrency set to CONCUR_UPDATABLE, you can modify the data in a result set and then apply your changes back to the database without having to issue another query.</p>
<p class="indent">In addition to the <code>getXXXX</code> methods we looked at for <code>ResultSet</code>—methods that get column values as integers, <code>Date</code> objects, <code>String</code>s, etc.—there is an equivalent <code>updateXXXX</code> method for each type. And, just like the <code>getXXXX</code> methods, the <code>updateXXXX</code> methods can take either a <code>String</code> column name or an integer column index.</p>
<p class="indent">Let’s rewrite the previous update example using an updatable <code>ResultSet</code>:</p>
<p class="imageip"><img src="images/un862-01.jpg" alt="images" /></p>
<p class="indent">Notice that after modifying the value of <code>UnitPrice</code> using the <code>updateFloat()</code> method, we called the method <code>updateRow()</code>. This method writes the current row to the database. This two-step approach ensures that all of the changes are made to the row before the row is written to the database. And you can change your mind with a <code>cancelRowUpdates()</code> method call.</p>
<p class="indent"><a href="ch12.xhtml#ch12tab11">Table 12-11</a> summarizes methods that are commonly used with updatable <code>ResultSet</code>s (whose concurrency type is set to CONCUR_UPDATABLE).</p>
<p class="indent">Let’s look at the common methods used for altering database contents through the <code>ResultSet</code> in detail.</p>
<p class="tabcap" id="ch12tab11"><span class="table"><strong>TABLE 12-11</strong></span> Methods Used with Updatable <code>ResultSets</code></p>
<p class="imaget"><img src="images/tab12-11.jpg" alt="Images" /></p>
<p class="noindentt"><strong>public void updateRow() throws SQLException</strong>   This method updates the database with the contents of the current row of the <code>ResultSet</code>. There are a couple of caveats for this method. First, the <code>ResultSet</code> must be from a SQL SELECT statement on a single table—a SQL statement that includes a JOIN or a SQL statement with two tables cannot be updated. Second, the <code>updateRow()</code> method should be called <em>before</em> moving to the next row. Otherwise, the updates to the current row may be lost.<span id="page_863" epub:type="pagebreak"></span></p>
<p class="indent">So the typical use for this method is to update the contents of a row using the appropriate <code>updateXXXX()</code> methods and then update the database with the contents of the row using the <code>updateRow()</code> method. For example, in this fragment, we are updating the <code>UnitPrice</code> of a row to $11.95:</p>
<p class="imageip"><img src="images/un863-01.jpg" alt="images" /></p>
<p class="noindentt"><strong>public boolean rowUpdated() throws SQLException</strong>   This method returns true if the current row was updated. Note that not all databases can detect updates. However, JDBC provides a method in <code>DatabaseMetaData</code> to determine if updates are detectable, <code>DatabaseMetaData.updatesAreDetected(int type)</code>, where the type is one of the <code>ResultSet</code> types—TYPE_SCROLL_INSENSITIVE, for example. We will cover the <code>DatabaseMetaData</code> interface and its methods a little later in this section.</p>
<p class="imageip"><img src="images/un863-02.jpg" alt="images" /></p>
<p class="noindentt"><span id="page_864" epub:type="pagebreak"></span><strong>public void cancelRowUpdates() throws SQLException</strong>   This method allows you to “back out” changes made to the row. This method is important, because the <code>updateXXXX</code> methods should not be called twice on the same column. In other words, if you set the value of <code>UnitPrice</code> to 11.95 in the previous example and then decided to switch the price back to 10.95, calling the <code>updateFloat()</code> method again can lead to unpredictable results. So the better approach is to call <code>cancelRowUpdates()</code> before changing the value of a column a second time.</p>
<p class="imageip"><img src="images/un864-01.jpg" alt="images" /></p>
<p class="noindentt"><strong>public void deleteRow() throws SQLException</strong>   This method will remove the current row from the <code>ResultSet</code> and from the underlying database. The row in the database is removed (similar to the result of a DELETE statement).</p>
<p class="imageip"><img src="images/un864-02.jpg" alt="images" /></p>
<p class="indent">What happens to the <code>ResultSet</code> after a <code>deleteRow()</code> method depends on whether the <code>ResultSet</code> can detect deletions. And this ability depends on the JDBC driver.</p>
<p class="indent">The <code>DatabaseMetaData</code> interface can be used to determine if the <code>ResultSet</code> can detect deletions:</p>
<p class="imageip"><img src="images/un864-03.jpg" alt="images" /></p>
<p class="indent"><span id="page_865" epub:type="pagebreak"></span>In general, to maintain an up-to-date <code>ResultSet</code> after a deletion, the <code>ResultSet</code> should be re-created with a query.</p>
<p class="indent">Deleting the current row does not move the cursor—it remains on the current row—so if you deleted row 1, the cursor is still positioned at row 1. However, if the deleted row was the last row, then the cursor is positioned after the last row. Note that there is no undo for <code>deleteRow()</code>, at least, not by default.</p>
<p class="noindentt"><strong>public boolean rowDeleted() throws SQLException</strong>   As described earlier, when a <code>ResultSet</code> can detect deletes, the <code>rowDeleted()</code> method is used to indicate a row has been deleted but remains as a part of the <code>ResultSet</code> object. For example, suppose that we deleted the second row of the Customer table. Printing the results (after the delete) to the console would look like <a href="ch12.xhtml#ch12fig7">Figure 12-7</a>.</p>
<p class="figcap" id="ch12fig7"><span class="figure"><strong>FIGURE 12-7</strong></span></p>
<p class="figcap1">A <code>ResultSet</code> after <code>deleteRow()</code> is called on the second row</p>
<p class="imagef"><img src="images/fig12-07.jpg" alt="Images" /></p>
<p class="indent">So if you are working with a <code>ResultSet</code> that is being passed around between methods and shared across classes, you might use <code>rowDeleted()</code> to detect if the current row contains valid data.</p>
<p class="noindentt"><strong>Updating Columns Using Objects</strong>   An interesting aspect of the <code>getObject()</code> and <code>updateObject()</code> methods is that they retrieve a column as a Java object. <span id="page_866" epub:type="pagebreak"></span>And because every Java object can be turned into a <code>String</code> using the object’s <code>toString()</code> method, you can retrieve the value of any column in the database and print the value to the console as a <code>String</code>, as you saw in the section “Printing a Report.”</p>
<p class="indent">Going the other way, toward the database, you can also use <code>String</code>s to update almost every column in a <code>ResultSet</code>. All of the most common SQL types—integer, float, double, long, and date—are wrapped by their representative Java object: <code>Integer</code>, <code>Float</code>, <code>Double</code>, <code>Long</code>, and <code>java.sql.Date</code>. Each of these objects has a method <code>valueOf()</code> that takes a <code>String</code>.</p>
<p class="indent">The <code>updateObject()</code> method takes two arguments: the first, a column name (<code>String</code>) or column index; and the second, an <code>Object</code>. We can pass a <code>String</code> as the <code>Object</code> type, and as long as the <code>String</code> meets the requirements of the <code>valueOf()</code> method for the column type, the <code>String</code> will be properly converted and stored in the database as the desired SQL type.</p>
<p class="indent">For example, suppose that we are going to update the publish date (<code>PubDate</code>) of one of our books:</p>
<p class="imageip"><img src="images/un866-01.jpg" alt="images" /></p>
<p class="indent">The <code>String</code> we passed meets the requirements for java.sql.Date, “yyyy-[m]m-[d]d,” so the <code>String</code> is properly converted and stored in the database as the SQL Date value: 2005-04-23. Note this technique is limited to those SQL types that can be converted to and from a <code>String</code>, and if the <code>String</code> passed to the <code>valueOf()</code> method for the SQL type of the column is not properly formatted for the Java object, an <code>IllegalArgumentException</code> is thrown.</p>
<h5 class="h5">Inserting New Rows Using a ResultSet</h5>
<p class="noindent">In the last section, we looked at modifying the existing column data in a <code>ResultSet</code> and removing existing rows. In our final section on <code>ResultSet</code>s, we’ll look at how to create and insert a new row. First, you must have a valid <code>ResultSet</code> open, so typically, you have performed some query. <code>ResultSet</code> provides a special row, called the insert row, that you are actually modifying (updating) before performing <span id="page_867" epub:type="pagebreak"></span>the insert. Think of the insert row as a buffer where you can modify an empty row of your <code>ResultSet</code> with values.</p>
<p class="indent">Inserting a row is a three-step process, as shown in <a href="ch12.xhtml#ch12fig8">Figure 12-8</a>: First (1) move to the special insert row, then (2) update the values of the columns for the new row, and finally (3) perform the actual insert (write to the underlying database). The existing <code>ResultSet</code> is not changed—you must rerun your query to see the underlying changes in the database. However, you can insert as many rows as you like. Note that each of these methods throws a <code>SQLException</code> if the concurrency type of the result set is set to CONCUR_READ_ONLY. Let’s look at the methods before we look at example code.</p>
<p class="figcap" id="ch12fig8"><span class="figure"><strong>FIGURE 12-8</strong></span></p>
<p class="figcap1">The <code>ResultSet</code> insert row</p>
<p class="imagef"><img src="images/fig12-08.jpg" alt="Images" /></p>
<p class="noindentt"><strong>public void moveToInsertRow() throws SQLException</strong>   This method moves the cursor to insert a row buffer. Wherever the cursor was when this method was called is remembered. After calling this method, the appropriate updater methods are called to update the values of the columns.</p>
<p class="imageip"><img src="images/un867-01.jpg" alt="images" /></p>
<p class="noindentt"><span id="page_868" epub:type="pagebreak"></span><strong>public void insertRow() throws SQLException</strong>   This method writes the insert row buffer to the database. Note that the cursor must be on the insert row when this method is called. Also, note that each column must be set to a value before the row is inserted in the database or a <code>SQLException</code> will be thrown. The <code>insertRow()</code> method can be called more than once—however, the <code>insertRow</code> follows the same rules as a SQL INSERT command. Unless the primary key is auto-generated, two inserts of the same data will result in a <code>SQLException</code> (duplicate primary key).</p>
<p class="imageip"><img src="images/un868-01.jpg" alt="images" /></p>
<p class="noindentt"><strong>public void moveToCurrentRow() throws SQLException</strong>   This method returns the result set cursor to the row the cursor was on before the <code>moveToInsertRow()</code> method was called.</p>
<p class="indent">Let’s look at a simple example, where we will add a new row in the Author table:</p>
<p class="imageip"><img src="images/un868-02.jpg" alt="images" /></p>
<h5 class="h5">Getting Information about a Database Using DatabaseMetaData</h5>
<p class="noindent">Note: On the real exam, you might not get any questions about <code>DatabaseMetaData</code>.</p>
<p class="indent">In the example we are using in this chapter, Bob’s Books, we know quite a lot about the tables, columns, and relationships between the tables because we had that nifty data model earlier. But what if that were not the case? This section covers <code>DatabaseMetaData</code>, an interface that provides a significant amount of information about the database itself. This topic is fairly advanced stuff and is not on the exam, but it is provided here to give you an idea about how you can use metadata to build a model of a database without having to know anything about the database in advance.</p>
<p class="indent"><span id="page_869" epub:type="pagebreak"></span>Recall that the <code>Connection</code> object we obtained from <code>DriverManager</code> is an object that represents an actual connection with the database. And while the <code>Connection</code> object is primarily used to create <code>Statement</code> objects, there are a couple of important methods to study in the <code>Connection</code> interface. A <code>Connection</code> can be used to obtain information <em>about</em> the database as well. This data is called “metadata,” or “data about data.”</p>
<p class="indent">One of <code>Connection</code>’s methods returns a <code>DatabaseMetaData</code> object instance, through which we can get information about the database, about the driver, and about transaction semantics that the database and JDBC driver support.</p>
<p class="indent">To obtain an instance of a <code>DatabaseMetaData</code> object, we use <code>Connection</code>’s <code>getMetaData()</code> method:</p>
<p class="imageip"><img src="images/un869-01.jpg" alt="images" /></p>
<p class="indent"><code>DatabaseMetaData</code> is a comprehensive interface, and through an object instance, we can determine a great deal about the database and the supporting driver. Most of the time, as a developer, you aren’t coding against a database blindly and know the capabilities of the database and the driver before you write any code. Still, it is helpful to know that you can use <code>getObject</code> to return the value of the column, regardless of its type—very useful when all you want to do is create a report. We’ll look at an example.</p>
<p class="indent">Here are a few methods we will highlight:</p>
<p class="bullt"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><code>getColumns()</code></strong> Returns a description of columns in a specified catalog and schema</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><code>getProcedures()</code></strong> Returns a description of the stored procedures in a given catalog and schema</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><code>getDriverName()</code></strong> Returns the name of the JDBC driver</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><code>getDriverVersion()</code></strong> Returns the version number of the JDBC driver as a string</p>
<p class="bullb"><img class="inline" src="images/box.jpg" alt="Images" />   <strong><code>supportsANSI92EntryLevelSQL()</code></strong> Returns a boolean true if this database supports ANSI92 entry-level grammar</p>
<p class="indent"><span id="page_870" epub:type="pagebreak"></span>It is interesting to note that <code>DatabaseMetaData</code> methods also use <code>ResultSet</code> objects to return data about the database. Let’s look at these methods in more detail.</p>
<p class="noindentt"><strong>public ResultSet getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException</strong>   This method is one of the best all-purpose data retrieval methods for details about the tables and columns in your database. Before we look at a code sample, it might be helpful to define catalogs and schemas. In a database, a schema is an object that enforces the integrity of the tables in the database. The schema name is generally the name of the person who created the database. In our examples, the BookGuy database holds the collection of tables and is the name of the schema. Databases may have multiple schemas stored in a catalog.</p>
<p class="indent">In this example, using the Java DB database as our sample database, the catalog is null and our schema is “BOOKGUY”, and we are using a SQL catch-all pattern “<code>%</code>” for the table and column name patterns, like the “<code>*</code>” character you are probably used to with file systems like Windows. Thus, we are going to retrieve all of the tables and columns in the schema. Specifically, we are going to print out the table name, column name, the SQL data type for the column, and the size of the column. Note that here we used uppercase column identifiers. These are the column names verbatim from the JavaDoc, but in truth, they are not case-sensitive either, so “<code>Table_Name</code>” would have worked just as well. Also, the JavaDoc specifies the column index for these column headings, so we could have also used <code>rs.getString(3)</code> to get the table name.</p>
<p class="imageip"><img src="images/un870-01.jpg" alt="images" /></p>
<p class="indent"><span id="page_871" epub:type="pagebreak"></span>Running this code produces output something like this:</p>
<p class="imageip"><img src="images/un871-01.jpg" alt="images" /></p>
<p class="noindentt"><strong>public ResultSet getProcedures(String catalog, String schemaPattern, String procedureNamePattern) throws SQLException</strong>   Stored procedures are functions that are sometimes built into a database and often defined by a database developer or database admin. These functions can range from data cleanup to complex queries. This method returns a result set that contains descriptive information about the stored procedures for a catalog and schema. In the example code, we will use null for the catalog name and schema pattern. The null indicates that we do not wish to narrow the search (effectively, the same as using a catch-all “<code>%</code>” search). Note that this example is returning the name of every stored procedure in the database. A little later, we’ll look at how to actually call a stored procedure.</p>
<p class="imageip"><img src="images/un871-02.jpg" alt="images" /></p>
<p class="imageip"><span id="page_872" epub:type="pagebreak"></span><img src="images/un872-01.jpg" alt="images" /></p>
<p class="indent">Note that the output from this code fragment is highly database dependent. Here is sample output from the Derby (JavaDB) database that ships with the JDK:</p>
<p class="imageip"><img src="images/un872-02.jpg" alt="images" /></p>
<p class="noindentt"><strong>public String getDriverName() throws SQLException</strong>   This method simply returns the name of the JDBC driver as a string. This method would be useful to log at the start of the application, as you’ll see in the next section.</p>
<p class="imageip"><img src="images/un872-03.jpg" alt="images" /></p>
<p class="noindent">Obviously, the name of the driver depends on the JDBC driver you are using. Again, with the Derby database and JDBC driver, the output from this method looks something like this:</p>
<p class="imageip"><img src="images/un872-04.jpg" alt="images" /></p>
<p class="noindentt"><strong>public String getDriverVersion() throws SQLException</strong>   This method returns the JDBC driver version number as a string. This information and the driver name would be good to log in at startup of an application.</p>
<p class="imageip"><img src="images/un872-05.jpg" alt="images" /></p>
<p class="indent">Statements written to the log are generally recorded in a log file, but depending on the IDE, they can also be written to the console. In NetBeans, for example, the log statements look something like this in the console:</p>
<p class="imageip"><img src="images/un872-06.jpg" alt="images" /></p>
<p class="noindentt"><span id="page_873" epub:type="pagebreak"></span><strong>public boolean supportsANSI92EntryLevelSQL() throws SQLException</strong>   This method returns true if the database and JDBC driver support ANSI SQL-92 entry-level grammar. Support for this level (at a minimum) is a requirement for JDBC drivers (and, therefore, the database).</p>
<p class="imageip"><img src="images/un873-01.jpg" alt="images" /></p>
<h4 class="h4" id="ch12lev2sec9">When Things Go Wrong—Exceptions and Warnings</h4>
<p class="noindent">Whenever you are working with a database using JDBC, there is a possibility that something can go wrong. A JDBC connection is typically through a socket to a database resource on the network. So already we have at least two possible points of failure—the network can be down and/or the database can be down. And that assumes everything else you are doing with your database is correct, that all your queries are perfect! Like other Java exceptions, <code>SQLException</code> is a way for your application to determine what the problem is and take action if necessary.</p>
<p class="indent">Let’s look at the type of data you get from a <code>SQLException</code> through its methods.</p>
<p class="noindentt"><strong>public String getMessage()</strong>   This method is actually inherited from <code>java.lang.Exception</code>, which <code>SQLException</code> extends from. This method returns the detailed reason why the exception was thrown. Often, the message contents <code>SQLState</code> and error code provide specific information about what went wrong.</p>
<p class="noindentt"><strong>public String getSQLState()</strong>   The <code>String</code> returned by <code>getSQLState</code> provides a specific code and related message. <code>SQLState</code> messages are defined by the X/Open and SQL:2003 standards; however, it is up to the implementation to use these values. You can determine which standard your JDBC driver uses (or if it does not) through the <code>DatabaseMetaData.getSQLStateType()</code> method. Your implementation may also define additional codes specific to the implementation, so in either case, it is a good idea to consult your JDBC driver and database documentation. Because the <code>SQLState</code> messages and codes tend to be specific to the driver and database, the typical use of these in an application is limited to either logging messages or debugging information.</p>
<p class="noindentt"><span id="page_874" epub:type="pagebreak"></span><strong>public int getErrorCode()</strong>   Error codes are not defined by a standard and are thus implementation specific. They can be used to pass an actual error code or severity level, depending on the implementation.</p>
<p class="noindentt"><strong>public SQLException getNextException()</strong>   One of the interesting aspects of <code>SQLException</code> is that the exception thrown could be the result of more than one issue. Fortunately, JDBC simply tacks each exception onto the next in a process called chaining. Typically, the most severe exception is thrown last, so it is the first exception in the chain.</p>
<p class="indent">You can get a list of all of the exceptions in the chain using the <code>getNextException()</code> method to iterate through the list. When the end of the list is reached, <code>getNextException()</code> returns a null. In this example, the <code>SQLException</code>s, <code>SQLState</code>, and vendor error codes are logged:</p>
<p class="imageip"><img src="images/un874-01.jpg" alt="images" /></p>
<h5 class="h5">Warnings</h5>
<p class="noindent">Although <code>SQLWarning</code> is a subclass of <code>SQLException</code>, warnings are silently chained to the JDBC object that reported them. This is probably one of the few times in Java where an object that is part of an exception hierarchy is not thrown as an exception. The reason is that a warning is not an exception per se. Warnings can be reported on <code>Connection</code>, <code>Statement</code>, and <code>ResultSet</code> objects.</p>
<p class="indent">For example, suppose that we mistakenly set the result-set type to TYPE_SCROLL_SENSITIVE when creating a <code>Statement</code> object. This does not create an exception; instead, the database will handle the situation by chaining a <code>SQLWarning</code> to the <code>Connection</code> object and resetting the type to TYPE_FORWARD_ONLY (the default) and continue on. Everything would be fine, of course, until we tried to <span id="page_875" epub:type="pagebreak"></span>position the cursor, at which point a <code>SQLException</code> would be thrown. And, like <code>SQLException</code>, you can retrieve warnings from the <code>SQLWarning</code> object using the <code>getNextWarning()</code> method.</p>
<p class="imageip"><img src="images/un875-01.jpg" alt="images" /></p>
<p class="indent"><code>Connection</code> objects will add warnings (if necessary) until the <code>Connection</code> is closed or until the <code>clearWarnings()</code> method is called on the <code>Connection</code> instance. The <code>clearWarnings()</code> method sets the list of warnings to null until another warning is reported for this <code>Connection</code> object.</p>
<p class="indent"><code>Statement</code>s and <code>ResultSet</code>s also generate <code>SQLWarning</code>s, and these objects have their own <code>clearWarnings()</code> methods. <code>Statement</code> warnings are cleared automatically when a statement is reexecuted, and <code>ResultSet</code> warnings are cleared each time a new row is read from the result set.</p>
<p class="indent">The following sections summarize the methods associated with <code>SQLWarning</code>s.</p>
<p class="noindentt"><strong>SQLWarning getWarnings() throws SQLException</strong>   This method gets the first <code>SQLWarning</code> object or returns null if there are no warnings for this <code>Connection</code>, <code>Statement</code>, or <code>ResultSet</code> object. A <code>SQLException</code> is thrown if the method is called on a closed object.</p>
<p class="noindentt"><strong>void clearWarnings() throws SQLException</strong>   This method clears and resets the current set of warnings for this <code>Connection</code>, <code>Statement</code>, or <code>ResultSet</code> object. A <code>SQLException</code> is thrown if the method is called on a closed object.</p>
<h5 class="h5">Properly Closing SQL Resources</h5>
<p class="noindent">In this chapter, we have looked at some very simple examples where we create a <code>Connection</code> and <code>Statement</code> and a <code>ResultSet</code> all within a single <code>try</code> block <span id="page_876" epub:type="pagebreak"></span>and catch any <code>SQLException</code>s thrown. What we have not done so far is properly close these resources. The reality is that it is probably less important for such small examples, but for any code that uses a resource, like a socket, or a file, or a JDBC database connection, closing the open resources is a good practice.</p>
<p class="indent">It is also important to know when a resource is closed automatically. Each of the three major JDBC objects—<code>Connection</code>, <code>Statement</code>, and <code>ResultSet</code>—has a <code>close()</code> method to explicitly close the resource associated with the object and explicitly release the resource. We hope by now you also realize that the objects have a relationship with each other, so if one object executes <code>close()</code>, it will have an impact on the other objects. The following table should help explain this.</p>
<p class="imagef"><img src="images/t0876-01.jpg" alt="images" /></p>
<p class="indent">It is also a good practice to minimize the number of times you close and re-create <code>Connection</code> objects. As a rule, creating the connection to the database and passing the username and password credentials for authentication is a relatively expensive process, so performing the activity once for every SQL query can cause code to execute slowly. In fact, typically, database connections are created in a pool and connection instances are handed out to applications as needed, rather than allowing or requiring individual applications to create them.</p>
<p class="indent"><code>Statement</code> objects are less expensive to create. There are ways to precompile SQL statements using a <code>PreparedStatement</code>, which reduces the overhead associated with creating SQL query strings and sending those strings to the database for execution, but understanding <code>PreparedStatement</code> is no longer on the exam.</p>
<p class="indent"><code>ResultSet</code>s are the least expensive of the objects to create, and as you saw in the section “ResultSets,” for results from a single table, you can use the <code>ResultSet</code> to update, insert, and delete rows, so it can be very efficient to use a <code>ResultSet</code>.</p>
<p class="indent"><span id="page_877" epub:type="pagebreak"></span>Let’s look at one of our previous examples, where we used a <code>Connection</code>, a <code>Statement</code>, and a <code>ResultSet</code>, and rewrite this code to close the resources properly.</p>
<p class="imageip"><img src="images/un877-01.jpg" alt="images" /></p>
<p class="indent">Notice all the work we have to go through to close the <code>Connection</code>—we first need to make sure we actually got an object and not a null, and then we need to try the <code>close()</code> method inside of another <code>try</code> inside of the <code>finally</code> block! Fortunately, there is an easier way….</p>
<h5 class="h5">Using try-with-resources to Close Connections, Statements, and ResultSets</h5>
<p class="noindent">One of the most useful changes in Java SE 7 (JDK 7) was a number of small modifications to the language, including a new <code>try</code> statement to support automatic resource management. This language change is called <code>try</code>-with-resources, and its longer name belies how much simpler it makes writing code with resources that should be closed. The <code>try</code>-with-resources statement will automatically call the <code>close()</code> method on any resource declared in the parentheses at the end of the <code>try</code> block.</p>
<p class="indent"><span id="page_878" epub:type="pagebreak"></span>There is a caveat: A resource declared in the <code>try</code>-with-resource statement must implement the <code>AutoCloseable</code> interface. One of the changes for JDBC in Java SE 7 (JDBC 4.1) was the modification of the API so that <code>Connection</code>, <code>Statement</code>, and <code>ResultSet</code> all extend the <code>AutoCloseable</code> interface and support automatic resource management. So we can rewrite our previous code example using <code>try</code>-with-resources:</p>
<p class="imageip"><img src="images/un878-01.jpg" alt="images" /></p>
<p class="indent">Notice that we must include the object type in the declaration inside of the parentheses. The following will throw a compilation error:</p>
<p class="imageip"><img src="images/un878-02.jpg" alt="images" /></p>
<p class="indent">The <code>try</code>-with-resources can also be used with multiple resources, so you could include the <code>Statement</code> declaration in the <code>try</code> as well:</p>
<p class="imageip"><img src="images/un878-03.jpg" alt="images" /></p>
<p class="noindent">Note that when more than one resource is declared in the <code>try</code>-with-resources statement, the resources are closed in the reverse order of their declaration—so <code>stmt.close()</code> will be called first, followed by <code>conn.close()</code>.</p>
<p class="indent">It probably makes sense that, if an exception is thrown from the <code>try</code> block, the exception will be caught by the <code>catch</code> statement, but what happens to exceptions thrown as a result of closing the resources in the <code>try</code>-with-resources statement? Any exceptions thrown as a result of closing resources at the end of the <code>try</code> block are suppressed, if there was also an exception thrown in the <code>try</code> block. These exceptions can be retrieved from the exception thrown by calling the <code>getSuppressed()</code> method on the exception thrown.</p>
<p class="indent"><span id="page_879" epub:type="pagebreak"></span>For example:</p>
<p class="imageip"><img src="images/un879-01.jpg" alt="images" /></p>
<h3 class="h3b" id="ch12lev1sec5">CERTIFICATION SUMMARY</h3>
<hr/>
<h5 class="h5">Core JDBC API</h5>
<p class="noindent">Remember that the JDBC API is a set of interfaces with one important concrete class, the <code>DriverManager</code> class. You write code using the well-defined set of JDBC interfaces, and the provider of your JDBC driver writes code implementations of those interfaces. The key (and, therefore, required) interfaces a JDBC driver must implement include <code>Driver</code>, <code>Connection</code>, <code>Statement</code>, and <code>ResultSet</code>.</p>
<p class="indent">The driver provider will also implement an instance of <code>DatabaseMetaData</code>, which you use to invoke a method to query the driver for information about the database and JDBC driver. One important piece of information is if the database is SQL-92 compliant, and there are a number of methods that begin with “supports” to determine the capabilities of the driver. One important method is <code>supportsResultSetType()</code>, which is used to determine if the driver supports scrolling result sets.</p>
<h5 class="h5">DriverManager</h5>
<p class="noindent">The <code>DriverManager</code> is one of the few concrete classes in the JDBC API, and you will recall that the <code>DriverManager</code> is a factory class—using the <code>DriverManager</code>, you construct instances of <code>Connection</code> objects. In reality, the <code>DriverManager</code> simply holds references to registered JDBC drivers, and when you invoke the <code>getConnection()</code> method with a JDBC URL, the <code>DriverManager</code> passes the URL to each driver in turn. If the URL matches a valid driver, host, port number, username, and password, then that driver returns an instance of a <code>Connection</code> object. Remember that the JDBC URL is simply a string that encodes the information required to make a connection to a database.</p>
<p class="indent"><span id="page_880" epub:type="pagebreak"></span>How a JDBC driver is registered with the <code>DriverManager</code> is also important. In JDBC 4.0 and later, the driver jar file simply needs to be on the classpath, and the <code>DriverManager</code> will take care of finding the driver’s <code>Driver</code> class implementation and load that. JDBC 3.0 and earlier, require that the driver’s <code>Driver</code> class implementation be manually loaded using the <code>Class.forName()</code> method with the fully qualified class name of the class.</p>
<h5 class="h5">Statements and ResultSets</h5>
<p class="noindent">The most important use of a database is clearly using SQL statements and queries to create, read, update, and delete database records. The <code>Statement</code> interface provides the methods needed to create SQL statements and execute them. Remember that there are three different <code>Statement</code> methods to execute SQL queries: one that returns a result set, <code>executeQuery()</code>; one that returns an affected row count, <code>executeUpdate()</code>; and one general-purpose method that returns a boolean to indicate if the query produced a result set, <code>execute()</code>.</p>
<p class="indent"><code>ResultSet</code> is the interface used to read columns of data returned from a query, one row at a time. <code>ResultSet</code> objects represent a snapshot (a copy) of the data returned from a query, and there is a cursor that points to just above the first row when the results are returned. Unless you created a <code>Statement</code> object using the <code>Connection.createStatement(int, int)</code> method that takes <code>resultSetType</code> and <code>resultSetConcurrency</code> parameters, <code>ResultSet</code>s are not updatable and only allow the cursor to move forward through the results. However, if your database supports it, you can create a <code>Statement</code> object with a type of <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> and/or a concurrency of <code>ResultSet.CONCUR_UPDATABLE</code>, which allows any result set created with the <code>Statement</code> object to position the cursor anywhere in the results (scrollable) and allows you to change the value of any column in any row in the result set (updatable). Finally, when using a <code>ResultSet</code> that is scrollable, you can determine the number of rows returned from a query—and this is the only way to determine the row count because there is no “<code>rowCount</code>” method.</p>
<p class="indent"><code>SQLException</code> is the base class for exceptions thrown by JDBC, and because one query can result in a number of exceptions, the exceptions are chained. To determine all of the reasons a method call returned a <code>SQLException</code>, you must iterate through the exception by calling the <code>getNextException()</code> method. JDBC also keeps track of warnings for methods on <code>Connection</code>, <code>Statement</code>, and <code>ResultSet</code> objects using a <code>SQLWarning</code> exception type. Like <code>SQLException</code>, <code>SQLWarning</code> is silently chained to the object that caused the warning—for example, <span id="page_881" epub:type="pagebreak"></span>suppose that you attempt to create a <code>Statement</code> object that supports the scrollable <code>ResultSet</code>, but the database does not support that type. A <code>SQLWarning</code> will be added to the <code>Connection</code> object (the <code>Connection.createStatement(int, int)</code> method creates a <code>Statement</code> object). The <code>getWarnings()</code> method is used to return any <code>SQLWarnings</code>.</p>
<p class="indent">One of the important additions to Java SE 7 was the <code>try</code>-with-resources statement, and all of the JDBC interfaces have been updated to support the new <code>AutoCloseable</code> interface. However, bear in mind that there is an order of precedence when closing <code>Connection</code>s, <code>Statement</code>s, and <code>ResultSet</code>s. So when a <code>Connection</code> is closed, any <code>Statement</code> created from that <code>Connection</code> is also closed, and likewise, when a <code>Statement</code> is closed, any <code>ResultSet</code> created using that <code>Statement</code> is also closed. And attempting to invoke a method on a closed object will result in a <code>SQLException</code>!</p>
<h3 class="h3b" id="ch12lev1sec6"><span id="page_882" epub:type="pagebreak"></span><img src="images/tick1.jpg" alt="Images" /> TWO-MINUTE DRILL</h3>
<p class="noindent">Here are some of the key points from the certification objectives in this chapter.</p>
<h4 class="h4">Core Interfaces of the JDBC API (OCP Objective 11.1)</h4>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   To be compliant with JDBC, driver vendors must provide implementations for the key JDBC interfaces: <code>Driver</code>, <code>Connection</code>, <code>Statement</code>, and <code>ResultSet</code>.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <code>D</code><code>atabaseMetaData</code> can be used to determine which SQL-92 level your driver and database support.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <code>D</code><code>atabaseMetaData</code> provides methods to interrogate the driver for capabilities and features.</p>
<h4 class="h4">Connect to a Database Using DriverManager (OCP Objective 11.2)</h4>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   The JDBC API follows a factory pattern, where the <code>DriverManager</code> class is used to construct instances of <code>Connection</code> objects.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   The JDBC URL is passed to each registered driver, in turn, in an attempt to create a valid <code>Connection</code>.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Identify the Java statements required to connect to a database using JDBC.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   JDBC 3.0 (and earlier) drivers must be loaded prior to their use.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   JDBC 4.0 drivers just need to be part of the classpath, and they are automatically loaded by the <code>DriverManager</code>.</p>
<h4 class="h4">Submit Queries and Read Results from the Database (OCP Objective 11.3)</h4>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   The <code>next()</code> method must be called on a <code>ResultSet</code> before reading the first row of results.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   When a <code>Statement execute()</code> method is executed, any open <code>ResultSet</code>s tied to that <code>Statement</code> are automatically closed.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   When a <code>Statement</code> is closed, any related <code>ResultSet</code>s are also closed.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <code>R</code><code>esultSet</code> column indexes are numbered from 1, not 0.</p>
<p class="bull"><span id="page_883" epub:type="pagebreak"></span><img class="inline" src="images/box.jpg" alt="Images" />   The default <code>ResultSet</code> is not updatable (read-only), and the cursor moves forward only.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   A <code>ResultSet</code> that is scrollable and updatable can be modified, and the cursor can be positioned anywhere within the <code>ResultSet</code>.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <code>R</code><code>esultSetMetaData</code> can be used to dynamically discover the number of columns and their type returned in a <code>ResultSet</code>.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <code>R</code><code>esultSetMetaData</code> does not have a row count method. To determine the number of rows returned, the <code>ResultSet</code> must be scrollable.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <code>R</code><code>esultSet</code> fetch size can be controlled for large data sets; however, it is a hint to the driver and may be ignored.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <code>S</code><code>QLException</code>s are chained. You must iterate through the exceptions thrown to get all of the reasons why an exception was thrown.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   <code>S</code><code>QLException</code> also contains database-specific error codes and status codes.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   The <code>executeQuery</code> method is used to return a <code>ResultSet</code> (SELECT).</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   The <code>executeUpdate</code> method is used to update data, to modify the database, and to return the number of rows affected (INSERT, UPDATE, DELETE, and DDLs).</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   The <code>execute</code> method is used to perform any SQL command. A boolean <code>true</code> is returned when the query produces a <code>ResultSet</code> and <code>false</code> when there are no results, or if the result is an update count.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   There is an order of precedence in the closing of <code>Connection</code>s, <code>Statement</code>s, and <code>ResultSet</code>s.</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   Using the <code>try</code>-with-resources statement, you can close <code>Connection</code>s, <code>Statement</code>s, and <code>ResultSet</code>s automatically (they implement the new <code>AutoCloseable</code> interface in Java SE 7).</p>
<p class="bull"><img class="inline" src="images/box.jpg" alt="Images" />   When a <code>Connection</code> is closed, all of the related <code>Statement</code>s and <code>ResultSet</code>s are closed.</p>
<h3 class="h3b" id="ch12lev1sec7"><span id="page_884" epub:type="pagebreak"></span><img src="images/qs.jpg" alt="Images" /> SELF TEST</h3>
<p class="que"><strong><a id="ch12ans1" href="ch12.xhtml#r_ch12ans1">1</a></strong>   Given:</p>
<p class="num-pre"><img src="images/un884-01.jpg" alt="images" /></p>
<p class="alpha-no">Assuming <code>"org.gjt.mm.mysql.Driver"</code> is a legitimate class, which line, when inserted at <code>// INSERT CODE HERE</code>, will correctly load this JDBC 3.0 driver?</p>
<p class="alpha"><img src="images/un884-02.jpg" alt="images" /></p>
<p class="que"><strong><a id="ch12ans2" href="ch12.xhtml#r_ch12ans2">2</a></strong>   Given that you are working with a JDBC 4.0 driver, which three are required for this JDBC driver to be compliant?</p>
<p class="alpha">A. Must include a <code>META-INF/services/java.sql.Driver</code> file</p>
<p class="alpha">B. Must provide implementations of <code>Driver</code>, <code>Connection</code>, <code>Statement</code>, and <code>ResultSet</code> interfaces</p>
<p class="alpha">C. Must support scrollable <code>ResultSets</code></p>
<p class="alpha">D. Must support updatable <code>ResultSets</code></p>
<p class="alpha">E. Must support transactions</p>
<p class="alpha">F. Must support the SQL99 standard</p>
<p class="alpha">G. Must support <code>PreparedStatement</code> and <code>CallableStatement</code></p>
<p class="que"><strong><a id="ch12ans3" href="ch12.xhtml#r_ch12ans3">3</a></strong>   Which three are available through an instance of <code>DatabaseMetaData</code>?</p>
<p class="alpha">A. The number of columns returned</p>
<p class="alpha">B. The number of rows returned</p>
<p class="alpha">C. The name of the JDBC driver</p>
<p class="alpha">D. The default transaction isolation level</p>
<p class="alpha">E. The last query used</p>
<p class="alpha">F. The names of stored procedures in the database</p>
<p class="que"><span id="page_885" epub:type="pagebreak"></span><strong><a id="ch12ans4" href="ch12.xhtml#r_ch12ans4">4</a></strong>   Given:</p>
<p class="num-pre"><img src="images/un885-01.jpg" alt="images" /></p>
<p class="alpha-no">Assuming a <code>Connection</code> object has already been created (conn) and that the query produces a valid result, what is the result?</p>
<p class="alpha">A. Compiler error at line X</p>
<p class="alpha">B. Compiler error at line Y</p>
<p class="alpha">C. No result</p>
<p class="alpha">D. The first name from the first row that matches ‘Rand%’</p>
<p class="alpha">E. <code>SQLException</code></p>
<p class="alpha">F. A runtime exception</p>
<p class="que"><strong><a id="ch12ans5" href="ch12.xhtml#r_ch12ans5">5</a></strong>   Given the SQL query:</p>
<p class="num-pre"><img src="images/un885-02.jpg" alt="images" /></p>
<p class="alpha-no">Assuming this is a valid SQL query and there is a valid <code>Connection</code> object (conn), which will compile correctly and execute this query?</p>
<p class="alpha"><img src="images/un885-03.jpg" alt="images" /></p>
<p class="que"><span id="page_886" epub:type="pagebreak"></span><strong><a id="ch12ans6" href="ch12.xhtml#r_ch12ans6">6</a></strong>   Given:</p>
<p class="num-pre"><img src="images/un886-01.jpg" alt="images" /></p>
<p class="alpha-no">And assuming a valid <code>Connection</code> object (conn) and that the query will return results, what is the result?</p>
<p class="alpha">A. The customer names will be printed out</p>
<p class="alpha">B. Compiler error at line X</p>
<p class="alpha">C. Illegal query</p>
<p class="alpha">D. Compiler error at line Y</p>
<p class="alpha">E. <code>SQLException</code></p>
<p class="alpha">F. Runtime exception</p>
<p class="que"><strong><a id="ch12ans7" href="ch12.xhtml#r_ch12ans7">7</a></strong>   Which interfaces must a vendor implement to be JDBC compliant? (Choose all that apply.)</p>
<p class="alpha">A. Query</p>
<p class="alpha">B. Driver</p>
<p class="alpha">C. ResultSet</p>
<p class="alpha">D. Statement</p>
<p class="alpha">E. Connection</p>
<p class="alpha">F. SQLException</p>
<p class="que"><strong><a id="ch12ans8" href="ch12.xhtml#r_ch12ans8">8</a></strong>   Given this code fragment:</p>
<p class="num-pre"><img src="images/un886-02.jpg" alt="images" /></p>
<p class="alpha-no"><span id="page_887" epub:type="pagebreak"></span>Assuming each query is valid and that all tables have valid row data, which query statements entered into <code>&lt;QUERY HERE&gt;</code> produce the output that follows the query string (in the following answer? (Choose all that apply.)</p>
<p class="alpha"><img src="images/un887-01.jpg" alt="images" /></p>
<p class="que"><strong><a id="ch12ans9" href="ch12.xhtml#r_ch12ans9">9</a></strong>   Which are true about queries that throw <code>SQLException</code>s? (Choose all that apply.)</p>
<p class="alpha">A. A single query either executes correctly or throws a single exception</p>
<p class="alpha">B. A single query can throw many exceptions</p>
<p class="alpha">C. If a single query throws many exceptions, the exceptions can be captured by invoking <code>SQLException.getExceptions()</code>, which returns a <code>List</code></p>
<p class="alpha">D. If a single query encounters more than one exception-worthy problem, a <code>SQLException</code> is created for each problem encountered</p>
<p class="alpha">E. If a single query throws many exceptions, the exceptions can be captured by iterating through the exceptions using <code>SQLException.getNextException()</code></p>
<p class="que1"><strong><a id="ch12ans10" href="ch12.xhtml#r_ch12ans10">10</a></strong>   Which are true about the results of a query?</p>
<p class="alpha">A. The results are stored in a <code>ResultSet</code> object</p>
<p class="alpha">B. The results are stored in a <code>List</code> of type <code>Result</code></p>
<p class="alpha">C. By default, the results remain synchronized with the database</p>
<p class="alpha">D. The results are accessed via iteration</p>
<p class="alpha">E. Once you have the results, you can retrieve a given row without needing to iterate</p>
<p class="alpha">F. The results are stored in a <code>List</code> of type <code>ResultSet</code></p>
<h3 class="h3b" id="ch12lev2sec10"><span id="page_888" epub:type="pagebreak"></span><img src="images/aself.jpg" alt="Images" /> SELF TEST ANSWERS</h3>
<p class="que-q"><strong><a href="ch12.xhtml#ch12ans1" id="r_ch12ans1">1</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>B</strong> is correct. Prior to JDBC 4.0, JDBC drivers were required to register themselves with the <code>DriverManager</code> class by invoking <code>DriverManager.register(this);</code> after the driver was instantiated through a call from the classloader. The <code>Class.forName()</code> method calls the classloader, which, in turn, creates an instance of the class passed as a <code>String</code> to the method.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A</strong> is incorrect because this method is meant to be invoked with an instance of a <code>Driver</code> class. <strong>C</strong> is incorrect because <code>DatabaseMetaData</code> does not have a <code>loadDriver</code> method, and the purpose of <code>DatabaseMetaData</code> is to return information about a database connection. <strong>D</strong> is incorrect because, again, while the method sounds right, the arguments are not of the right types, and this method is actually the one called by <code>DriverManager.getConnection</code> to get a <code>Connection</code> object. <strong>E</strong> is incorrect because although this method returns a <code>Driver</code> instance, one has to be loaded and registered with the <code>DriverManager</code> first. (OCP Objective 11.2)</p>
<p class="que-q"><strong><a href="ch12.xhtml#ch12ans2" id="r_ch12ans2">2</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>A, B,</strong> and <strong>E</strong> are correct. To be JDBC 4.0 compliant, a JDBC driver must support the ability to autoload the driver by providing a file, <code>META-INF/services/java.sql.Driver</code>, that indicates the fully qualified class name of the <code>Driver</code> class that <code>DriverManager</code> should load on startup. The JDBC driver must implement the interfaces for <code>Driver</code>, <code>Connection</code>, <code>Statement</code>, <code>ResultSet</code>, and others. The driver must also support transactions.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>C</strong> and <strong>D</strong> are incorrect. It is not a requirement to support scrollable or updatable <code>ResultSet</code>s, although many drivers do. If, however, the driver reports that through <code>DatabaseMetaData</code> it supports scrollable and updatable <code>ResultSet</code>s, then the driver must support all of the methods associated with cursor movement and updates. <strong>F</strong> is incorrect. The JDBC requires that the driver support SQL92 entry-level grammar and the SQL command DROP TABLE (from SQL92 Transitional Level). <strong>G</strong> is incorrect. Although JDBC 4.0 drivers must support <code>PreparedStatement</code>, <code>CallableStatement</code> is optional and only required if the driver returns true for the method <code>DatabaseMetaData.supportsStoredProcedures</code>. (OCP Objective 11.2)</p>
<p class="que-q"><strong><a href="ch12.xhtml#ch12ans3" id="r_ch12ans3">3</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>C, D,</strong> and <strong>F</strong> are correct. <code>DatabaseMetaData</code> provides data about the database and the <code>Connection</code> object. The name, version, and other JDBC driver information are available, plus information about the database, including the names of stored procedures, functions, SQL keywords, and more. Finally, the default transaction isolation level and data about what transaction levels are supported are also available through <code>DatabaseMetaData</code>.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A</strong> and <strong>B</strong> are incorrect, as they are really about the result of a query with the database. Column count is available through a <code>ResultSetMetaData</code> object, but a row count requires that you, as the developer, move the cursor to the end of a result set and then evaluate the <span id="page_889" epub:type="pagebreak"></span>cursor position. <strong>E</strong> is incorrect. There is no method defined to return the last query in JDBC. (OCP Objective 11.1)</p>
<p class="que-q"><strong><a href="ch12.xhtml#ch12ans4" id="r_ch12ans4">4</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>E</strong> is correct. When the <code>ResultSet</code> returns, the cursor is pointing before the first row of the <code>ResultSet</code>. You must invoke the <code>next()</code> method to move to the next row of results <em>before</em> you can read any data from the columns. Trying to read a result using a <code>getXXXX</code> method will result in a <code>SQLException</code> when the cursor is before the first row or after the last row.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B, D,</strong> and <strong>F</strong> are incorrect based on the above. Note about <strong>C</strong>: the <code>ResultSet</code> returned from <code>executeQuery</code> will never be null. (OCP Objective 11.3)</p>
<p class="que-q"><strong><a href="ch12.xhtml#ch12ans5" id="r_ch12ans5">5</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>D</strong> is correct.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> Note that answer <strong>E</strong> is close, but will not compile because the <code>executeUpdate(query)</code> method returns an integer result. <strong>A</strong> will compile correctly, but throw a <code>SQLException</code> at runtime—the <code>executeQuery</code> method cannot be used on INSERT, UPDATE, DELETE, or DDL SQL queries. <strong>B</strong> will not compile because the <code>createStatement</code> method does not take a <code>String</code> argument for the query. <strong>C</strong> is incorrect because <code>Statement</code> does not have a <code>setQuery</code> method and this fragment will not compile. (OCP Objective 11.3)</p>
<p class="que-q"><strong><a href="ch12.xhtml#ch12ans6" id="r_ch12ans6">6</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>E</strong> is correct. Recall that the <code>try</code>-with-resources statement on line X will automatically close the resource specified at the close of the <code>try</code> block (when the closing curly brace is reached) and closing the <code>Statement</code> object automatically closes any open <code>ResultSet</code>s associated with the <code>Statement</code>. The <code>SQLException</code> thrown is that the <code>ResultSet</code> is not open. To fix this code, move the <code>while</code> statement into the <code>try</code>-with-resources block.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A, B, C, D,</strong> and <strong>F</strong> are incorrect based on the above. (OCP Objective 11.3)</p>
<p class="que-q"><strong><a href="ch12.xhtml#ch12ans7" id="r_ch12ans7">7</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>B, C, D,</strong> and <strong>E</strong> are correct. </p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A</strong> and <strong>F</strong> are incorrect. They are not interfaces required by JDBC. To query a database, the <code>Stat</code><code>ement</code> interface is used, not the plausibly named, but mythical, <code>Query</code> interface. (OCP Objective 11.1)</p>
<p class="que-q"><strong><a href="ch12.xhtml#ch12ans8" id="r_ch12ans8">8</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> All of the answers are correct (<strong>A, B, C, D, E</strong>). SELECT statements will produce a <code>Resu</code><code>ltSet</code> even if there are no rows. INSERT, UPDATE, and DELETE statements all produce an update count, even when the number of rows affected is 0. (OCP Objective 9.3)</p>
<p class="que-q"><strong><a href="ch12.xhtml#ch12ans9" id="r_ch12ans9">9</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>B, D,</strong> and <strong>E</strong> are correct. </p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>A</strong> is incorrect because a single query can throw many exceptions. <strong>C</strong> is incorrect; when many exceptions are thrown, you must use <code>getNextException()</code> to iterate through them. (OCP Objective 11.3)</p>
<p class="que-q1"><span id="page_890" epub:type="pagebreak"></span><strong><a href="ch12.xhtml#ch12ans10" id="r_ch12ans10">10</a>.</strong>   <img src="images/tick2.jpg" alt="Images" /> <strong>A, D,</strong> and <strong>E</strong> are correct. For <strong>E</strong> you can use, for example, <code>getRow()</code>.</p>
<p class="quep"><img src="images/times.jpg" alt="Images" /> <strong>B</strong> is incorrect; results are stored in a <code>ResultSet</code> object. <strong>C</strong> is incorrect; once a <code>ResultSet</code> is created, it does NOT stay synchronized with the database unless the <code>ResultSet</code> was created with one of the <code>CONCUR_XXX</code> cursor types. <strong>F</strong> is incorrect based on the above. (OCP Objective 11.3)</p>
</section>
</div>
</body>
</html>